<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>/posts/0.html</url>
    <content><![CDATA[<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h4 id="-1"><a href="#-1" class="headerlink" title=""></a></h4><h4 id="-2"><a href="#-2" class="headerlink" title=""></a></h4><h3 id="-3"><a href="#-3" class="headerlink" title=""></a></h3><h4 id="-4"><a href="#-4" class="headerlink" title=""></a></h4><h4 id="-5"><a href="#-5" class="headerlink" title=""></a></h4><h3 id="-6"><a href="#-6" class="headerlink" title=""></a></h3><h4 id="-7"><a href="#-7" class="headerlink" title=""></a></h4><h4 id="-8"><a href="#-8" class="headerlink" title=""></a></h4><hr>
<p>END</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
  </entry>
  <entry>
    <title>Java面试题</title>
    <url>/posts/a7ef9c4d.html</url>
    <content><![CDATA[<h4 id="❓-面向对象的三个基本特征？"><a href="#❓-面向对象的三个基本特征？" class="headerlink" title="❓ 面向对象的三个基本特征？"></a>❓ 面向对象的三个基本特征？</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>继承：让某个类型的对象获得另一个类型的对象的属性的方法。继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。</p>
<p>封装：隐藏部分对象的属性和实现细节，对数据的访问只能通过外公开的接口。通过这种方式，对象对内部数据提供了不同级别的保护，以防止程序中无关的部分意外的改变或错误的使用了对象的私有部分。</p>
<p>多态：对于同一个行为，不同的子类对象具有不同的表现形式。多态存在的3个条件：1）继承；2）重写；3）父类引用指向子类对象。</p>
</div></div>

<h4 id="❓-下面两个代码块能正常编译和执行吗？"><a href="#❓-下面两个代码块能正常编译和执行吗？" class="headerlink" title="❓ 下面两个代码块能正常编译和执行吗？"></a>❓ 下面两个代码块能正常编译和执行吗？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码块1</span></span><br><span class="line"><span class="type">short</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="number">1</span>; s1 = s1 + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 代码块2</span></span><br><span class="line"><span class="type">short</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="number">1</span>; s1 += <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>代码块1编译报错，错误原因是：不兼容的类型: 从int转换到short可能会有损失”。<br>代码块2正常编译和执行。原因：代码块2编译后，字节码中包含了 i2s 指令，该指令用于将 int 转成 short</p>
</div></div>

<h4 id="❓-amp-和-amp-amp-的区别？"><a href="#❓-amp-和-amp-amp-的区别？" class="headerlink" title="❓ &amp;和&amp;&amp;的区别？"></a>❓ &amp;和&amp;&amp;的区别？</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>&amp;&amp;：逻辑与运算符。当运算符左右两边的表达式都为 true，才返回 true。同时具有短路性，如果第一个表达式为 false，则直接返回 false。</p>
<p>&amp;：逻辑与运算符、按位与运算符。<br>按位与运算符：用于二进制的计算，只有对应的两个二进位均为1时，结果位才为1 ，否则为0。<br>逻辑与运算符：&amp; 在用于逻辑与时，和 &amp;&amp; 的区别是不具有短路性。所在通常使用逻辑与运算符都会使用 &amp;&amp;，而 &amp; 更多的适用于位运算。</p>
</div></div>

<h4 id="❓-String-是-Java-基本数据类型吗？"><a href="#❓-String-是-Java-基本数据类型吗？" class="headerlink" title="❓  String 是 Java 基本数据类型吗？"></a>❓  String 是 Java 基本数据类型吗？</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>不是。Java 中的基本数据类型只有8个：byte、short、int、long、float、double、char、boolean；<br>除了基本类型（primitive type），剩下的都是引用类型（reference type）。</p>
<p>基本数据类型：数据直接存储在栈上<br>引用数据类型区别：数据存储在堆上，栈上只存储引用地址</p>
</div></div>

<h4 id="❓-String-类可以继承吗？"><a href="#❓-String-类可以继承吗？" class="headerlink" title="❓  String 类可以继承吗？"></a>❓  String 类可以继承吗？</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>不行。String 类使用 final 修饰，无法被继承。</p>
</div></div>

<h4 id="❓-String和StringBuilder、StringBuffer的区别？"><a href="#❓-String和StringBuilder、StringBuffer的区别？" class="headerlink" title="❓  String和StringBuilder、StringBuffer的区别？"></a>❓  String和StringBuilder、StringBuffer的区别？</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>String：String 的值被创建后不能修改，任何对 String 的修改都会引发新的 String 对象的生成。<br>StringBuffer：跟 String 类似，但是值可以被修改，使用 synchronized 来保证线程安全。<br>StringBuilder：StringBuffer 的非线程安全版本，没有使用 synchronized，具有更高的性能，推荐优先使用。</p>
</div></div>

<h4 id="❓-String-s-x3D-new-String-“xyz”-创建了几个字符串对象？"><a href="#❓-String-s-x3D-new-String-“xyz”-创建了几个字符串对象？" class="headerlink" title="❓  String s &#x3D; new String(“xyz”) 创建了几个字符串对象？"></a>❓  String s &#x3D; new String(“xyz”) 创建了几个字符串对象？</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>一个或两个。如果字符串常量池已经有“xyz”，则是一个；否则，两个。</p>
<p>当字符串常量池没有 “xyz”，此时会创建如下两个对象：<br>一个是字符串字面量 “xyz” 所对应的、驻留（intern）在一个全局共享的字符串常量池中的实例，此时该实例也是在堆中，字符串常量池只放引用。<br>另一个是通过 new String() 创建并初始化的，内容与”xyz”相同的实例，也是在堆中。</p>
</div></div>

<h4 id="❓-String-s-x3D-“xyz”-和-String-s-x3D-new-String-“xyz”-区别？"><a href="#❓-String-s-x3D-“xyz”-和-String-s-x3D-new-String-“xyz”-区别？" class="headerlink" title="❓  String s &#x3D; “xyz” 和 String s &#x3D; new String(“xyz”) 区别？"></a>❓  String s &#x3D; “xyz” 和 String s &#x3D; new String(“xyz”) 区别？</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>两个语句都会先去字符串常量池中检查是否已经存在 “xyz”，如果有则直接使用，如果没有则会在常量池中创建 “xyz” 对象。<br>另外，String s &#x3D; new String(“xyz”) 还会通过 new String() 在堆里创建一个内容与 “xyz” 相同的对象实例。<br>所以前者其实理解为被后者的所包含。</p>
</div></div>

<h4 id="❓-x3D-x3D-和-equals-的区别是什么？"><a href="#❓-x3D-x3D-和-equals-的区别是什么？" class="headerlink" title="❓  &#x3D;&#x3D; 和 equals 的区别是什么？"></a>❓  &#x3D;&#x3D; 和 equals 的区别是什么？</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>&#x3D;&#x3D;：运算符，用于比较基础类型变量和引用类型变量。<br>对于基础类型变量，比较的变量保存的值是否相同，类型不一定要相同。<br>对于引用类型变量，比较的是两个对象的地址是否相同。<br>equals：Object 类中定义的方法，通常用于比较两个对象的值是否相等。<br>equals 在 Object 方法中其实等同于 &#x3D;&#x3D;，但是在实际的使用中，equals 通常被重写用于比较两个对象的值是否相同。</p>
</div></div>

<h4 id="❓-两个对象的-hashCode-相同，则-equals-也一定为-true，对吗？"><a href="#❓-两个对象的-hashCode-相同，则-equals-也一定为-true，对吗？" class="headerlink" title="❓  两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗？"></a>❓  两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗？</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>不对。hashCode() 和 equals() 之间的关系如下：<br>当有 a.equals(b) &#x3D;&#x3D; true 时，则 a.hashCode() &#x3D;&#x3D; b.hashCode() 必然成立，<br>反过来，当 a.hashCode() &#x3D;&#x3D; b.hashCode() 时，a.equals(b) 不一定为 true。</p>
</div></div>


<h4 id="❓-什么是反射"><a href="#❓-什么是反射" class="headerlink" title="❓  什么是反射"></a>❓  什么是反射</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>反射是指在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法；并且对于任意一个对象，都能够调用它的任意一个方法；这种动态获取信息以及动态调用对象方法的功能称为反射机制。</p>
</div></div>


<h4 id="❓-深拷贝和浅拷贝区别是什么？"><a href="#❓-深拷贝和浅拷贝区别是什么？" class="headerlink" title="❓  深拷贝和浅拷贝区别是什么？"></a>❓  深拷贝和浅拷贝区别是什么？</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>数据分为基本数据类型和引用数据类型。基本数据类型：数据直接存储在栈中；引用数据类型：存储在栈中的是对象的引用地址，真实的对象数据存放在堆内存里。<br>浅拷贝：对于基础数据类型：直接复制数据值；对于引用数据类型：只是复制了对象的引用地址，新旧对象指向同一个内存地址，修改其中一个对象的值，另一个对象的值随之改变。<br>深拷贝：对于基础数据类型：直接复制数据值；对于引用数据类型：开辟新的内存空间，在新的内存空间里复制一个一模一样的对象，新老对象不共享内存，修改其中一个对象的值，不会影响另一个对象。<br>深拷贝相比于浅拷贝速度较慢并且花销较大。</p>
</div></div>

<h4 id="❓-并发和并行有什么区别？"><a href="#❓-并发和并行有什么区别？" class="headerlink" title="❓  并发和并行有什么区别？"></a>❓  并发和并行有什么区别？</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>并发：两个或多个事件在同一时间间隔发生。<br>并行：两个或者多个事件在同一时刻发生。<br>并行是真正意义上，同一时刻做多件事情，而并发在同一时刻只会做一件事件，只是可以将时间切碎，交替做多件事情。</p>
</div></div>


<h4 id="❓-构造器是否可被-重写"><a href="#❓-构造器是否可被-重写" class="headerlink" title="❓  构造器是否可被 重写?"></a>❓  构造器是否可被 重写?</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>Constructor 不能被 override（重写），但是可以 overload（重载），所以你可以看到⼀个类中有多个构造函数的情况。</p>
</div></div>


<h4 id="❓-重载（Overload）和重写（Override）的区别？"><a href="#❓-重载（Overload）和重写（Override）的区别？" class="headerlink" title="❓  重载（Overload）和重写（Override）的区别？"></a>❓  重载（Overload）和重写（Override）的区别？</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。</p>
<p>重载：一个类中有多个同名的方法，但是具有有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）。</p>
<p>重写：发生在子类与父类之间，子类对父类的方法进行重写，参数都不能改变，返回值类型可以不相同，但是必须是父类返回值的派生类。即外壳不变，核心重写！重写的好处在于子类可以根据需要，定义特定于自己的行为。</p>
</div></div>

<h4 id="❓-Error-和-Exception-有什么区别？"><a href="#❓-Error-和-Exception-有什么区别？" class="headerlink" title="❓  Error 和 Exception 有什么区别？"></a>❓  Error 和 Exception 有什么区别？</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>Error 和 Exception 都是 Throwable 的子类，用于表示程序出现了不正常的情况。区别在于：<br>Error 表示系统级的错误和程序不必处理的异常，是恢复不是不可能但很困难的情况下的一种严重问题，比如内存溢出，不可能指望程序能处理这样的情况。<br>Exception 表示需要捕捉或者需要程序进行处理的异常，是一种设计或实现问题，也就是说，它表示如果程序运行正常，从不会发生的情况。</p>
</div></div>


<h4 id="❓-wait-和-sleep-方法的区别"><a href="#❓-wait-和-sleep-方法的区别" class="headerlink" title="❓  wait() 和 sleep() 方法的区别"></a>❓  wait() 和 sleep() 方法的区别</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>来源不同：sleep() 来自 Thread 类，wait() 来自 Object 类。</p>
<p>对于同步锁的影响不同：sleep() 不会改变同步锁的行为，如果当前线程持有同步锁，那么 sleep 是不会让线程释放同步锁的。wait() 会释放同步锁，让其他线程进入 synchronized 代码块执行。</p>
<p>使用范围不同：sleep() 可以在任何地方使用。wait() 只能在同步控制方法或者同步控制块里面使用，否则会抛 IllegalMonitorStateException。</p>
<p>恢复方式不同：两者会暂停当前线程，但是在恢复上不太一样。sleep() 在时间到了之后会重新恢复；wait() 则需要其他线程调用同一对象的 notify()&#x2F;nofityAll() 才能重新恢复。</p>
</div></div>


<h4 id="❓-线程的-join-方法是干啥用的？"><a href="#❓-线程的-join-方法是干啥用的？" class="headerlink" title="❓  线程的 join() 方法是干啥用的？"></a>❓  线程的 join() 方法是干啥用的？</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>用于等待当前线程终止。如果一个线程A执行了 threadB.join() 语句，其含义是：当前线程A等待 threadB 线程终止之后才从 threadB.join() 返回继续往下执行自己的代码。</p>
</div></div>

<h4 id="❓-编写多线程程序有几种实现方式？"><a href="#❓-编写多线程程序有几种实现方式？" class="headerlink" title="❓  编写多线程程序有几种实现方式？"></a>❓  编写多线程程序有几种实现方式？</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>通常来说，可以认为有三种方式：1）继承 Thread 类；2）实现 Runnable 接口；3）实现 Callable 接口。</p>
<p>其中，Thread 其实也是实现了 Runable 接口。Runnable 和 Callable 的主要区别在于是否有返回值。</p>
</div></div>


<h4 id="❓-synchronized-和-Lock-的区别"><a href="#❓-synchronized-和-Lock-的区别" class="headerlink" title="❓  synchronized 和 Lock 的区别"></a>❓  synchronized 和 Lock 的区别</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>1）Lock 是一个接口；synchronized 是 Java 中的关键字，synchronized 是内置的语言实现；</p>
<p>2）Lock 在发生异常时，如果没有主动通过 unLock() 去释放锁，很可能会造成死锁现象，因此使用 Lock 时需要在 finally 块中释放锁；synchronized 不需要手动获取锁和释放锁，在发生异常时，会自动释放锁，因此不会导致死锁现象发生；</p>
<p>3）Lock 的使用更加灵活，可以有响应中断、有超时时间等；而 synchronized 却不行，使用 synchronized 时，等待的线程会一直等待下去，直到获取到锁；</p>
<p>4）在性能上，随着近些年 synchronized 的不断优化，Lock 和 synchronized 在性能上已经没有很明显的差距了，所以性能不应该成为我们选择两者的主要原因。官方推荐尽量使用 synchronized，除非 synchronized 无法满足需求时，则可以使用 Lock。</p>
</div></div>

<h4 id="❓-线程池的核心属性有哪些？"><a href="#❓-线程池的核心属性有哪些？" class="headerlink" title="❓  线程池的核心属性有哪些？"></a>❓  线程池的核心属性有哪些？</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>threadFactory（线程工厂）：用于创建工作线程的工厂。</p>
<p>corePoolSize（核心线程数）：当线程池运行的线程少于 corePoolSize 时，将创建一个新线程来处理请求，即使其他工作线程处于空闲状态。</p>
<p>workQueue（队列）：用于保留任务并移交给工作线程的阻塞队列。</p>
<p>maximumPoolSize（最大线程数）：线程池允许开启的最大线程数。</p>
<p>handler（拒绝策略）：往线程池添加任务时，将在下面两种情况触发拒绝策略：1）线程池运行状态不是 RUNNING；2）线程池已经达到最大线程数，并且阻塞队列已满时。</p>
<p>keepAliveTime（保持存活时间）：如果线程池当前线程数超过 corePoolSize，则多余的线程空闲时间超过 keepAliveTime 时会被终止。</p>
</div></div>

<h4 id="❓-线程池有哪些拒绝策略？"><a href="#❓-线程池有哪些拒绝策略？" class="headerlink" title="❓  线程池有哪些拒绝策略？"></a>❓  线程池有哪些拒绝策略？</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>AbortPolicy：中止策略。默认的拒绝策略，直接抛出 RejectedExecutionException。调用者可以捕获这个异常，然后根据需求编写自己的处理代码。</p>
<p>DiscardPolicy：抛弃策略。什么都不做，直接抛弃被拒绝的任务。</p>
<p>DiscardOldestPolicy：抛弃最老策略。抛弃阻塞队列中最老的任务，相当于就是队列中下一个将要被执行的任务，然后重新提交被拒绝的任务。如果阻塞队列是一个优先队列，那么“抛弃最旧的”策略将导致抛弃优先级最高的任务，因此最好不要将该策略和优先级队列放在一起使用。</p>
<p>CallerRunsPolicy：调用者运行策略。在调用者线程中执行该任务。该策略实现了一种调节机制，该策略既不会抛弃任务，也不会抛出异常，而是将任务回退到调用者（调用线程池执行任务的主线程），由于执行任务需要一定时间，因此主线程至少在一段时间内不能提交任务，从而使得线程池有时间来处理完正在执行的任务。</p>
</div></div>

<h4 id="❓-ArrayList-和-LinkedList-的区别。"><a href="#❓-ArrayList-和-LinkedList-的区别。" class="headerlink" title="❓  ArrayList 和 LinkedList 的区别。"></a>❓  ArrayList 和 LinkedList 的区别。</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>ArrayList 底层基于动态数组实现，LinkedList 底层基于链表实现。</p>
<p>对于按 index 索引数据（get&#x2F;set方法）：ArrayList 通过 index 直接定位到数组对应位置的节点，而 LinkedList需要从头结点或尾节点开始遍历，直到寻找到目标节点，因此在效率上 ArrayList 优于 LinkedList。</p>
<p>对于随机插入和删除：ArrayList 需要移动目标节点后面的节点（使用System.arraycopy 方法移动节点），而 LinkedList 只需修改目标节点前后节点的 next 或 prev 属性即可，因此在效率上 LinkedList 优于 ArrayList。</p>
<p>对于顺序插入和删除：由于 ArrayList 不需要移动节点，因此在效率上比 LinkedList 更好。这也是为什么在实际使用中 ArrayList 更多，因为大部分情况下我们的使用都是顺序插入。</p>
</div></div>

<h4 id="❓-什么是双亲委派模型？"><a href="#❓-什么是双亲委派模型？" class="headerlink" title="❓  什么是双亲委派模型？"></a>❓  什么是双亲委派模型？</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。</p>
</div></div>

<h4 id="❓-介绍下垃圾收集机制（在什么时候，对什么，做了什么）？"><a href="#❓-介绍下垃圾收集机制（在什么时候，对什么，做了什么）？" class="headerlink" title="❓  介绍下垃圾收集机制（在什么时候，对什么，做了什么）？"></a>❓  介绍下垃圾收集机制（在什么时候，对什么，做了什么）？</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>在什么时候？<br>在触发GC的时候，具体如下，这里只说常见的 Young GC 和 Full GC。<br>触发Young GC：当新生代中的 Eden 区没有足够空间进行分配时会触发Young GC。<br>触发Full GC：<br>当准备要触发一次Young GC时，如果发现统计数据说之前Young GC的平均晋升大小比目前老年代剩余的空间大，则不会触发Young GC而是转为触发Full GC。（通常情况）<br>如果有永久代的话，在永久代需要分配空间但已经没有足够空间时，也要触发一次Full GC。<br>System.gc()默认也是触发Full GC。<br>heap dump带GC默认也是触发Full GC。<br>CMS GC时出现Concurrent Mode Failure会导致一次Full GC的产生。</p>
<p>对什么？<br>对那些JVM认为已经“死掉”的对象。即从GC Root开始搜索，搜索不到的，并且经过一次筛选标记没有复活的对象。</p>
<p>做了什么？<br>对这些JVM认为已经“死掉”的对象进行垃圾收集，新生代使用复制算法，老年代使用标记-清除和标记-整理算法。</p>
</div></div>
]]></content>
      <categories>
        <category>资源</category>
        <category>面试题</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>网络协议面试题</title>
    <url>/posts/e172783f.html</url>
    <content><![CDATA[<h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><h4 id="❓-当你用浏览器打开一个链接的时候，计算机做了哪些工作步骤。"><a href="#❓-当你用浏览器打开一个链接的时候，计算机做了哪些工作步骤。" class="headerlink" title="❓  当你用浏览器打开一个链接的时候，计算机做了哪些工作步骤。"></a>❓  当你用浏览器打开一个链接的时候，计算机做了哪些工作步骤。</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>（1）解析域名。<br>​ （2）发起TCP的3次握手。<br>​ （3）建立TCP请求后发起HTTP请求。<br>​ （4）服务器相应HTTP请求。<br>​ （5）浏览器得到HTML代码，进行解析和处理JSON数据，并请求HTML代码中的静态资源（JS、CSS、图片等）。<br>​ （6）浏览器对页面进行渲染。</p>
</div></div>

<h4 id="❓-HTTPS的加密方式是什么，讲讲整个加密解密流程。"><a href="#❓-HTTPS的加密方式是什么，讲讲整个加密解密流程。" class="headerlink" title="❓  HTTPS的加密方式是什么，讲讲整个加密解密流程。"></a>❓  HTTPS的加密方式是什么，讲讲整个加密解密流程。</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>1）对称密码算法：指加密和解密使用相同的密钥，速度高，可加密内容较大，用来加密会话过程中的消息。典型算法DES、AES、RC5、IDEA（分组加密）RC4。</p>
<p> 2）非对称密码算法：又称为公钥加密算法，是指加密和解密使用不同的密钥，加密速度较慢，但能提供更好的身份认证技术，用来加密对称加密的密钥（公开的密钥用于加密，私有的密钥用于解密）典型的算法RSA、DSA、DH。</p>
<p> 3）散列算法：将文件内容通过此算法加密变成固定长度的值（散列值），这个过程可以使用密钥也可以不使用。这种散列变化是不可逆的，也就是说不能从散列值编程原文，因此散列变化通道常用语验证原文是否被篡改。典型的算法MD5、SHA、BASE64、CRC等。</p>
</div></div>

<h4 id="❓-Http与Https的区别："><a href="#❓-Http与Https的区别：" class="headerlink" title="❓  Http与Https的区别："></a>❓  Http与Https的区别：</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>HTTP 的URL 以http:&#x2F;&#x2F; 开头，而HTTPS 的URL 以https:&#x2F;&#x2F; 开头</p>
<p>HTTP 是不安全的，而 HTTPS 是安全的</p>
<p>HTTP 标准端口是80 ，而 HTTPS 的标准端口是443</p>
<p>在OSI 网络模型中，HTTP工作于应用层，而HTTPS 的安全传输机制工作在传输层</p>
<p>HTTP 无法加密，而HTTPS 对传输的数据进行加密</p>
<p>HTTP无需证书，而HTTPS 需要CA机构颁发的SSL证书</p>
</div></div>

<h4 id="❓-什么是Http协议无状态协议-怎么解决Http协议无状态协议"><a href="#❓-什么是Http协议无状态协议-怎么解决Http协议无状态协议" class="headerlink" title="❓  什么是Http协议无状态协议?怎么解决Http协议无状态协议?"></a>❓  什么是Http协议无状态协议?怎么解决Http协议无状态协议?</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>无状态协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息</p>
<p>也就是说，当客户端一次HTTP请求完成以后，客户端再发送一次HTTP请求，HTTP并不知道当前客户端是一个”老用户“。</p>
<p>可以使用Cookie来解决无状态的问题，Cookie就相当于一个通行证，第一次访问的时候给客户端发送一个Cookie，当客户端再次来的时候，拿着Cookie(通行证)，那么服务器就知道这个是”老用户“</p>
</div></div>

<h4 id="❓-常见的HTTP相应状态码"><a href="#❓-常见的HTTP相应状态码" class="headerlink" title="❓  常见的HTTP相应状态码"></a>❓  常见的HTTP相应状态码</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>200：请求被正常处理</p>
<p>204：请求被受理但没有资源可以返回</p>
<p>206：客户端只是请求资源的一部分，服务器只对请求的部分资源执行GET方法，相应报文中通过Content-Range指定范围的资源。</p>
<p>301：永久性重定向</p>
<p>302：临时重定向</p>
<p>303：与302状态码有相似功能，只是它希望客户端在请求一个URI的时候，能通过GET方法重定向到另一个URI上</p>
<p>304：发送附带条件的请求时，条件不满足时返回，与重定向无关</p>
<p>307：临时重定向，与302类似，只是强制要求使用POST方法</p>
<p>400：请求报文语法有误，服务器无法识别</p>
<p>401：请求需要认证</p>
<p>403：请求的对应资源禁止被访问</p>
<p>404：服务器无法找到对应资源</p>
<p>500：服务器内部错误</p>
<p>503：服务器正忙</p>
</div></div>

<h4 id="❓-Session和cookie的区别。"><a href="#❓-Session和cookie的区别。" class="headerlink" title="❓  Session和cookie的区别。"></a>❓  Session和cookie的区别。</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>（1）Cookie保存在客户端，未设置存储时间的Cookie，关闭浏览器会话Cookie就会被删除；设置了存储时间的Cookie保存在用户设备的磁盘中知道过期，同时Cookie在客户端所以可以伪造，不是十分安全，敏感数据不易保存。Session保存在服务器端，存储在IIS的进程开辟的内存中，而Session过多会消耗服务器资源，所以尽量少使用Session。<br>（2）Session是服务器用来跟踪用户的一种手段，每个Session都有一个唯一标识：session ID。当服务端生成一个Session时就会向客户端发送一个Cookie保存到客户端，这个Cookie保存的是Session的SessionId这样才能保证客户端发起请求后，用户能够与服务器端成千上万的Session进行匹配，同时也保证了不同页面之间传值的正确性.<br>（3）存储数据类型不同：Session能够存储任意的JAVA对象，Cookie只能存储String类型的对象。<br>（4）长于10K的数据，不要用到Cookies。</p>
</div></div>

<h3 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h3><h4 id="❓-网络的七层结构及其作用"><a href="#❓-网络的七层结构及其作用" class="headerlink" title="❓  网络的七层结构及其作用"></a>❓  网络的七层结构及其作用</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>自上而下是：</p>
<p>应用层（数据）：确定进程之间通信的性质以满足用户需要以及提供网络与用户应用</p>
<p>表示层（数据）：主要解决用户信息的语法表示问题，如加密解密</p>
<p>会话层（数据）：提供包括访问验证和会话管理在内的建立和维护应用之间通信的机制，如服务器验证用户登录便是由会话层完成的</p>
<p>传输层（段）：实现网络不同主机上用户进程之间的数据通信，可靠</p>
<p>与不可靠的传输，传输层的错误检测，流量控制等</p>
<p>网络层（包）：提供逻辑地址（IP）、选路，数据从源端到目的端的</p>
<p>传输</p>
<p>数据链路层（帧）：将上层数据封装成帧，用MAC地址访问媒介，错误检测与修正</p>
<p>物理层（比特流）：设备之间比特流的传输，物理接口，电气特性等</p>
</div></div>

<h4 id="❓-为什么-TCP-连接需要三次握手，两次不可以么，为什么？"><a href="#❓-为什么-TCP-连接需要三次握手，两次不可以么，为什么？" class="headerlink" title="❓  为什么 TCP 连接需要三次握手，两次不可以么，为什么？"></a>❓  为什么 TCP 连接需要三次握手，两次不可以么，为什么？</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>为了防止已失效的连接请求报文突然又传送到了服务端，因而产生错误。客户端发出的连接请求报文并未丢失，而是在某个网络节点长时间滞留了，以致延误到链接释放以后的某个时间才到达 Server 。</p>
</div></div>

<h4 id="❓-什么是-TCP-四次挥手？"><a href="#❓-什么是-TCP-四次挥手？" class="headerlink" title="❓  什么是 TCP 四次挥手？"></a>❓  什么是 TCP 四次挥手？</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>四次挥手，简单来说，就是：</p>
<p>发送方：我要和你断开连接！</p>
<p>接收方：好的，断吧。</p>
<p>接收方：我也要和你断开连接！</p>
<p>发送方：好的，断吧。</p>
</div></div>

<h3 id="UDP-协议"><a href="#UDP-协议" class="headerlink" title="UDP 协议"></a>UDP 协议</h3><h4 id="❓-UDP-是什么？"><a href="#❓-UDP-是什么？" class="headerlink" title="❓  UDP 是什么？"></a>❓  UDP 是什么？</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>UDP（User Data Protocol，用户数据报协议），是与 TCP 相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去。</p>
</div></div>

<h4 id="❓-UDP-主要特点"><a href="#❓-UDP-主要特点" class="headerlink" title="❓  UDP 主要特点"></a>❓  UDP 主要特点</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>UDP 是无连接的。</p>
<p>UDP 使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态（这里面有许多参数）。</p>
<p>UDP 是面向报文的。</p>
<p>UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低。</p>
</div></div>

<h4 id="❓-TCP与UDP的区别"><a href="#❓-TCP与UDP的区别" class="headerlink" title="❓  TCP与UDP的区别"></a>❓  TCP与UDP的区别</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>TCP 是面向连接的；UDP 是无连接的。</p>
<p>TCP 是可靠的；UDP 是不可靠的。</p>
<p>TCP 只支持点对点通信；UDP 支持一对一、一对多、多对一、多对多的通信模式。</p>
<p>TCP 是面向字节流的；UDP 是面向报文的。</p>
<p>TCP 有拥塞控制机制；UDP 没有拥塞控制，适合媒体通信。</p>
<p>TCP 首部开销(20 个字节)，比 UDP 的首部开销(8 个字节)要大。</p>
</div></div>
]]></content>
      <categories>
        <category>资源</category>
        <category>面试题</category>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>cdn内容分发网络</title>
    <url>/posts/3a9c487b.html</url>
    <content><![CDATA[<h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><p>Content Delivery Network，内容分发网络。</p>
<h3 id="核心理念"><a href="#核心理念" class="headerlink" title="核心理念"></a>核心理念</h3><p>将内容缓存在终端用户附近。<br>具体就是，CDN就是采用更多的缓存服务器（CDN边缘节点），布放在用户访问相对集中的地区或网络中。当用户访问网站时，利用全局负载技术，将用户的访问指向距离最近的缓存服务器上，由缓存服务器响应用户请求。<br>确切地说，CDN&#x3D;更智能的镜像+缓存+流量导流。</p>
<h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p>①、当用户点击APP上的内容，APP会根据URL地址去本地DNS（域名解析系统）寻求IP地址解析。</p>
<p>②、本地DNS系统会将域名的解析权交给CDN专用DNS服务器。</p>
<p>③、CDN专用DNS服务器，将CDN的全局负载均衡设备IP地址返回用户。</p>
<p>④、用户向CDN的负载均衡设备发起内容URL访问请求。</p>
<p>⑤、CDN负载均衡设备根据用户IP地址，以及用户请求的内容URL，选择一台用户所属区域的缓存服务器。</p>
<p>⑥、负载均衡设备告诉用户这台缓存服务器的IP地址，让用户向所选择的缓存服务器发起请求。</p>
<p>⑦、用户向缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端。</p>
<p>⑧、如果这台缓存服务器上并没有用户想要的内容，那么这台缓存服务器就要网站的源服务器请求内容。</p>
<p>⑨、源服务器返回内容给缓存服务器，缓存服务器发给用户，并根据用户自定义的缓存策略，判断要不要把内容缓存到缓存服务器上。</p>
<h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><p>加速了网站的访问<br>安全，内容进行分发后，源服务器的IP被隐藏，受到攻击的概率会大幅下降。而且，当某个服务器故障时，系统会调用临近的健康服务器，进行服务，避免对用户造成影响。</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>内容发布：它借助于建立索引、缓存、流分裂、组播（Multicast）等技术</p>
<p>内容路由：它是整体性的网络负载均衡技术，通过内容路由器中的重定向（DNS）机制，在多个远程POP上均衡用户的请求，以使用户请求得到最近内容源的响应；</p>
<p>内容交换：它根据内容的可用性、服务器的可用性以及用户的背景，在POP的缓存服务器上，利用应用层交换、流分裂、重定向（ICP、WCCP）等技术，智能地平衡负载流量；</p>
<p>性能管理：它通过内部和外部监控系统，获取网络部件的状况信息，测量内容发布的端到端性能（如包丢失、延时、平均带宽、启动时间、帧速率等），保证网络处于最佳的运行状态。</p>
<hr>
<p>END</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>CDN</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL面试题</title>
    <url>/posts/d4eb4c98.html</url>
    <content><![CDATA[<h4 id="❓-日常是怎么优化-SQL-的？"><a href="#❓-日常是怎么优化-SQL-的？" class="headerlink" title="❓  日常是怎么优化 SQL 的？"></a>❓  日常是怎么优化 SQL 的？</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>通过慢查询日志、EXPLAIN 分析查询、show profile 分析、以及 show 命令查询系统状态及系统变量</p>
</div></div>

<h4 id="❓-MySQL-如何对大表-千万-x2F-亿级-做优化？"><a href="#❓-MySQL-如何对大表-千万-x2F-亿级-做优化？" class="headerlink" title="❓  MySQL 如何对大表(千万&#x2F;亿级)做优化？"></a>❓  MySQL 如何对大表(千万&#x2F;亿级)做优化？</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>优化顺序：</p>
<p>优化 SQL 语句和索引</p>
<p>对频繁查询的数据进行缓存</p>
<p>对数据库进行主从复制，读写分离，从库可以使用 MyISAM，查询效率会更高</p>
<p>对表进行分区，SQL 条件中需要带上做分区的列，可以使查询定位到少量的分区上，查询会比较快，如果每用到分区的列会扫描全部分区</p>
<p>垂直拆分，对大表拆分成小表</p>
<p>水平拆分，将数据分片，拆分到其他表或数据库上</p>
</div></div>

<h4 id="❓-分区、分表、分库有什么作用？"><a href="#❓-分区、分表、分库有什么作用？" class="headerlink" title="❓  分区、分表、分库有什么作用？"></a>❓  分区、分表、分库有什么作用？</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>逻辑数据分割</p>
<p>提高单一的写和读应用速度</p>
<p>提高分区范围读查询的速度</p>
<p>分割数据能够有多个不同的物理文件路径，避免单目录或单文件过大</p>
<p>高效的保存历史记录</p>
<p>便于磁盘清理</p>
</div></div>

<h4 id="❓-如何分区、分表、分库？"><a href="#❓-如何分区、分表、分库？" class="headerlink" title="❓  如何分区、分表、分库？"></a>❓  如何分区、分表、分库？</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>分区：<br>RANGE 分区，LIST 分区，HASH 分区，KEY 分区<br>分表：<br>范围分表，哈希取余分表<br>分库：<br>业务分库，垂直分库。</p>
</div></div>

<h4 id="❓-MySQL-如何实现高可用？"><a href="#❓-MySQL-如何实现高可用？" class="headerlink" title="❓  MySQL 如何实现高可用？"></a>❓  MySQL 如何实现高可用？</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>实现高可用的手段主要是数据备份和失效转移机制。</p>
<p>MySQL 采用 Master-Slave 同步机制，通过主从复制的方式实现数据的热备。</p>
<p>失效转移需要从应用层面实现，如对服务器进行心跳检测，或通过应用程序访问失败的报告来判断失效，控制中心判断失效之后对服务进行切换，MySQL 如果做了主主备份，那么就切换到备份的主库上。</p>
</div></div>

<h4 id="❓-MySQL-主从复制的原理？"><a href="#❓-MySQL-主从复制的原理？" class="headerlink" title="❓  MySQL 主从复制的原理？"></a>❓  MySQL 主从复制的原理？</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>MySQL 主从复制主要涉及三个异步线程：</p>
<p>binlog 线程：负责将主服务器上所有的更改操作写入到二进制日志中(binary log)</p>
<p>I&#x2F;O 线程：负责从主服务器上读取二进制的日志，并写入到从服务器的中继日志中(Relay log)</p>
<p>SQL 线程：负责读取中继日志，解析出主服务器已经执行的数据更改操作，并在 Slave 机器上重放</p>
</div></div>

<h4 id="❓-MySql-读写分离的作用？"><a href="#❓-MySql-读写分离的作用？" class="headerlink" title="❓  MySql 读写分离的作用？"></a>❓  MySql 读写分离的作用？</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>读写分离：主服务器负责处理写操作和对数据实时性要求比较高的读操作，从服务器只负责处理读操作。</p>
<p>读写分离主要有以下几个作用：</p>
<p>提高读写的性能，由于主从服务器负责各自的读写，极大程度缓解了锁的争用</p>
<p>从服务器可以使用 MyISAM 存储引擎，提升查询性能，节约系统开销</p>
<p>增加了服务器冗余，提高可用性</p>
</div></div>

<h4 id="❓-聚集索引和非聚集索引区别？"><a href="#❓-聚集索引和非聚集索引区别？" class="headerlink" title="❓  聚集索引和非聚集索引区别？"></a>❓  聚集索引和非聚集索引区别？</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>根本区别：聚集索引和非聚集索引的根本区别是表记录的排列顺序和与索引的排列顺序是否一致。<br>聚集索引表记录的排列顺序和索引的排列顺序一致，所以查询效率快，只要找到第一个索引值记录，其余就连续性的记录在物理也一样连续存放。聚集索引对应的缺点就是修改慢，因为为了保证表中记录的物理和索引顺序一致，在记录插入的时候，会对数据页重新排序。<br>非聚集索引制定了表中记录的逻辑顺序，但是记录的物理和索引不一定一致，两种索引都采用B+树结构，非聚集索引的叶子层并不和实际数据页相重叠，而采用叶子层包含一个指向表中的记录在数据页中的指针方式。非聚集索引层次多，不会造成数据重排。</p>
</div></div>
<h4 id="❓-有哪些锁（乐观锁悲观锁），select-时怎么加排它锁？"><a href="#❓-有哪些锁（乐观锁悲观锁），select-时怎么加排它锁？" class="headerlink" title="❓  有哪些锁（乐观锁悲观锁），select 时怎么加排它锁？"></a>❓  有哪些锁（乐观锁悲观锁），select 时怎么加排它锁？</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>悲观锁和乐观锁是数据库用来保证数据并发安全防止更新丢失的两种方法，例子在select … for update前加个事务就可以防止更新丢失。悲观锁和乐观锁大部分场景下差异不大，一些独特场景下有一些差别，一般我们可以从如下几个方面来判断。</p>
<p>响应速度：如果需要非常高的响应速度，建议采用乐观锁方案，成功就执行，不成功就失败，不需要等待其他并发去释放锁。<br>冲突频率：如果冲突频率非常高，建议采用悲观锁，保证成功率，如果冲突频率大，乐观锁会需要多次重试才能成功，代价比较大。<br>重试代价：如果重试代价大，建议采用悲观锁。</p>
</div></div>
<h4 id="❓-SQL语句主要分为哪几类"><a href="#❓-SQL语句主要分为哪几类" class="headerlink" title="❓  SQL语句主要分为哪几类"></a>❓  SQL语句主要分为哪几类</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>数据据定义语言DDL（Data Definition Language）：主要有CREATE，DROP，ALTER等对逻辑结构有操作的，包括表结构、视图和索引。<br>数据库查询语言DQL（Data Query Language）：主要以SELECT为主<br>数据操纵语言DML（Data Manipulation Language）：主要包括INSERT，UPDATE，DELETE<br>数据控制功能DCL（Data Control Language）：主要是权限控制能操作，包括GRANT，REVOKE，COMMIT，ROLLBACK等。</p>
</div></div>
<h4 id="❓-什么是临时表，什么时候会使用到临时表，什么时候删除临时表？"><a href="#❓-什么是临时表，什么时候会使用到临时表，什么时候删除临时表？" class="headerlink" title="❓  什么是临时表，什么时候会使用到临时表，什么时候删除临时表？"></a>❓  什么是临时表，什么时候会使用到临时表，什么时候删除临时表？</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>MySQL在执行SQL语句的时候会临时创建一些存储中间结果集的表，这种表被称为临时表，临时表只对当前连接可见，在连接关闭后，临时表会被删除并释放空间。</p>
<p>临时表主要分为内存临时表和磁盘临时表两种。内存临时表使用的是MEMORY存储引擎，磁盘临时表使用的是MyISAM存储引擎。</p>
<p>一般在以下几种情况中会使用到临时表：</p>
<p>FROM中的子查询<br>DISTINCT查询并加上ORDER BY<br>ORDER BY和GROUP BY的子句不一样时会产生临时表<br>使用UNION查询会产生临时表</p>
</div></div>
<h4 id="❓-了解慢日志查询吗？统计过慢查询吗？对慢查询如何优化？"><a href="#❓-了解慢日志查询吗？统计过慢查询吗？对慢查询如何优化？" class="headerlink" title="❓  了解慢日志查询吗？统计过慢查询吗？对慢查询如何优化？"></a>❓  了解慢日志查询吗？统计过慢查询吗？对慢查询如何优化？</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>慢查询一般用于记录执行时间超过某个临界值的SQL语句的日志。</p>
<p>相关参数：<br>slow_query_log：是否开启慢日志查询，1表示开启，0表示关闭。<br>slow_query_log_file：MySQL数据库慢查询日志存储路径。<br>long_query_time：慢查询阈值，当SQL语句查询时间大于阈值，会被记录在日志上。<br>log_queries_not_using_indexes：未使用索引的查询会被记录到慢查询日志中。<br>log_output：日志存储方式。“FILE”表示将日志存入文件。“TABLE”表示将日志存入数据库。<br>如何对慢查询进行优化？</p>
<p>分析语句的执行计划，查看SQL语句的索引是否命中<br>优化数据库的结构，将字段很多的表分解成多个表，或者考虑建立中间表。<br>优化LIMIT分页。</p>
</div></div>
<h4 id="❓-字段为什么要设置成not-null"><a href="#❓-字段为什么要设置成not-null" class="headerlink" title="❓  字段为什么要设置成not null?"></a>❓  字段为什么要设置成not null?</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>首先说一点，NULL和空值是不一样的，空值是不占用空间的，而NULL是占用空间的，所以字段设为NOT NULL后仍然可以插入空值。<br>字段设置成not null主要有以下几点原因：<br>NULL值会影响一些函数的统计，如count，遇到NULL值，这条记录不会统计在内。<br>B树不存储NULL，所以索引用不到NULL，会造成第一点中说的统计不到的问题。<br>NOT IN子查询在有NULL值的情况下返回的结果都是空值。<br>MySQL在进行比较的时候，NULL会参与字段的比较，因为NULL是一种比较特殊的数据类型，数据库在处理时需要进行特数处理，增加了数据库处理记录的复杂性。</p>
</div></div>

<h4 id="❓-如何优化LIMIT分页？"><a href="#❓-如何优化LIMIT分页？" class="headerlink" title="❓  如何优化LIMIT分页？"></a>❓  如何优化LIMIT分页？</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>在LIMIT偏移量较大的时候，查询效率会变低，可以记录每次取出的最大ID，下次查询时可以利用ID进行查询</p>
<p>建立复合索引</p>
</div></div>

<h4 id="❓-什么是垂直分表、垂直分库、水平分表、水平分库？"><a href="#❓-什么是垂直分表、垂直分库、水平分表、水平分库？" class="headerlink" title="❓  什么是垂直分表、垂直分库、水平分表、水平分库？"></a>❓  什么是垂直分表、垂直分库、水平分表、水平分库？</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>垂直分表：将一个表按照字段分成多个表，每个表存储其中一部分字段。一般会将常用的字段放到一个表中，将不常用的字段放到另一个表中。</p>
<p>垂直分表的优势：</p>
<p>避免IO竞争减少锁表的概率。因为大的字段效率更低，第一数据量大，需要的读取时间长。第二，大字段占用的空间更大，单页内存储的行数变少，会使得IO操作增多。<br>可以更好地提升热门数据的查询效率。<br>垂直分库：按照业务对表进行分类，部署到不同的数据库上面，不同的数据库可以放到不同的服务器上面。</p>
<p>垂直分库的优势：</p>
<p>降低业务中的耦合，方便对不同的业务进行分级管理。<br>可以提升IO、数据库连接数、解决单机硬件资源的瓶颈问题。<br>垂直拆分（分库、分表）的缺点：</p>
<p>主键出现冗余，需要管理冗余列<br>事务的处理变得复杂<br>仍然存在单表数据量过大的问题<br>水平分表：在同一个数据库内，把同一个表的数据按照一定规则拆分到多个表中。</p>
<p>水平分表的优势：</p>
<p>解决了单表数据量过大的问题<br>避免IO竞争并减少锁表的概率<br>水平分库：把同一个表的数据按照一定规则拆分到不同的数据库中，不同的数据库可以放到不同的服务器上。</p>
<p>水平分库的优势：</p>
<p>解决了单库大数据量的瓶颈问题<br>IO冲突减少，锁的竞争减少，某个数据库出现问题不影响其他数据库（可用性），提高了系统的稳定性和可用性<br>水平拆分（分表、分库）的缺点：</p>
<p>分片事务一致性难以解决<br>跨节点JOIN性能差，逻辑会变得复杂<br>数据扩展难度大，不易维护<br>在系统设计时应根据业务耦合来确定垂直分库和垂直分表的方案，在数据访问压力不是特别大时应考虑缓存、读写分离等方法，若数据量很大，或持续增长可考虑水平分库分表，水平拆分所涉及的逻辑比较复杂，常见的方案有客户端架构和恶代理架构。</p>
</div></div>]]></content>
      <categories>
        <category>资源</category>
        <category>面试题</category>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>ClickHouse入门</title>
    <url>/posts/0.html</url>
    <content><![CDATA[<h3 id="ClickHouse简介"><a href="#ClickHouse简介" class="headerlink" title="ClickHouse简介"></a>ClickHouse简介</h3><h4 id="什么是clickhouse"><a href="#什么是clickhouse" class="headerlink" title="什么是clickhouse"></a>什么是clickhouse</h4><p>ClickHouse是一种OLAP类型的列式数据库管理系统，ClickHouse完美的实现了OLAP和列式数据库的优势，因此在大数据量的分析处理应用中Clickhouse表现很优秀。</p>
<h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><p>志数据行为分析<br>标签画像的分析<br>数据集市分层<br>广告系统和实时竞价广告<br>电商和金融行业<br>实时监控和遥感测量<br>商业智能<br>在线游戏<br>信息安全<br>所有的互联网场景</p>
<h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><p>真正的列式数据库<br>数据压缩<br>数据的磁盘存储<br>多核并行处理<br>多服务器分布式处理（数据保存在不同的shard上，每一个shard都由一组用于容错的副本组成，可并行查询所有shard）<br>向量引擎（按列的一部分进行处理，高效实用CPU）<br>实时的数据更新（支持在表中定义主键,数据增量有序存储在mergeTree中）<br>索引（按照主键对数据进行排序，毫秒内完成对数据的查找）<br>适合在线查询<br>支持近似计算（允许牺牲精度的情况下低延迟查询）<br>支持数据复制和数据完整性（异步多主复制技术）</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>没有完整的事务支持<br>缺少高频率低延迟的修改或删除数据的能力<br>不适合通过其检索单行的点查询<br>联机事物处理<br>二进制数据或文件存储<br>键值对数据高效率访问请求</p>
<h3 id="ClickHouse数据类型"><a href="#ClickHouse数据类型" class="headerlink" title="ClickHouse数据类型"></a>ClickHouse数据类型</h3><ol>
<li>整型<br>有符号整型：Int8、Int16 …<br>无符号整型：UInt8、UInt16 …<br>注：<br>可以通过一些别名来代替整型<br>Int8 — TINYINT, BOOL, BOOLEAN, INT1<br>Int16 — SMALLINT, INT2<br>Int32 — INT, INT4, INTEGER<br>Int64 — BIGINT</li>
<li>字符串<br>字符串可以任意长度的。它可以包含任意的字节集，包含空字节，在定义时，通过关键字String定义类型为字符串。</li>
<li>浮点数<br>Float32和Float64两种，对应于C语言中的float和double。 ClickHouse在官网上建议尽可能以整数形式存储数据，对浮点数进行计算可能引起四舍五入的误差。</li>
<li>时间类型<br>Date32和DateTime64存储时间，Date32只存储年月日，支持1900-01-01到2299-12-31，插入数据时可传入’2100-01-01’的格式，也可传入单位为秒的时间戳。</li>
</ol>
<h3 id="ClickHouse增删改查"><a href="#ClickHouse增删改查" class="headerlink" title="ClickHouse增删改查"></a>ClickHouse增删改查</h3><h4 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h4><p>创建数据库：CREATE DATABASE [IF NOT EXISTS] db_name;<br>删除数据库：DROP DATABASE [IF EXISTS] db [ON CLUSTER cluster]<br>注:ON CLUSTER cluster表示是否删除所有集群下的数据库</p>
<h4 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h4><ol>
<li>创建表：</li>
</ol>
<ul>
<li>方式一：结构化方式建表<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] [db.]table_name [<span class="keyword">ON</span> CLUSTER cluster]</span><br><span class="line">(</span><br><span class="line">    name1 [type1] [<span class="keyword">NULL</span><span class="operator">|</span><span class="keyword">NOT</span> <span class="keyword">NULL</span>] [<span class="keyword">DEFAULT</span><span class="operator">|</span>MATERIALIZED<span class="operator">|</span>EPHEMERAL<span class="operator">|</span>ALIAS expr1] [compression_codec] [TTL expr1],</span><br><span class="line">    name2 [type2] [<span class="keyword">NULL</span><span class="operator">|</span><span class="keyword">NOT</span> <span class="keyword">NULL</span>] [<span class="keyword">DEFAULT</span><span class="operator">|</span>MATERIALIZED<span class="operator">|</span>EPHEMERAL<span class="operator">|</span>ALIAS expr2] [compression_codec] [TTL expr2],</span><br><span class="line">    ...</span><br><span class="line">) ENGINE <span class="operator">=</span> engine</span><br><span class="line">例子：</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span></span><br><span class="line">(</span><br><span class="line">    id UInt32,</span><br><span class="line">    name String,</span><br><span class="line">    grade UInt32,</span><br><span class="line">    address String</span><br><span class="line">)</span><br><span class="line">ENGINE <span class="operator">=</span> MergeTree </span><br><span class="line"><span class="keyword">PRIMARY</span> KEY(id)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> id</span><br></pre></td></tr></table></figure>
属性字段说明：<br>name表示属性的名称<br>[type]表示数据的类型<br>[NULL|NOT NULL]定义该字段允许或不允许为Nullable<br>[DEFAULT|MATERIALIZED|EPHEMERAL|ALIAS expr1]表示该字段的默认值表达式，如果该字段为空，默认值为零（数字）、空字符串（字符串）、空数组（数组）等。其中最常用的是DEFAULT expr，比如Hits UInt32 DEFAULT 0。<br> DEFAULT expr<br>普通的默认值，如果INSERT中不包含指定的列，那么将通过表达式计算它的默认值并填充它。<br> MATERIALIZED expr<br>物化表达式，被该表达式指定的列不能包含在INSERT的列表中，因为它总是被计算出来的。 对于INSERT而 言，不需要考虑这些列。 另外，在SELECT查询 中如果包含星号，此列不会被用来替换星号，这是因为考虑到数据转储，在使用SELECT *查询出的结果总能够被’INSERT’回表。<br> ALIAS expr<br>别名。这样的列不会存储在表中。 它的值不能够通过INSERT写入，同时使用SELECT查询星号时，这些列也不会被用来替换星号。 但是它们可以显示的用于 SELECT中，在这种情况下，在查询分析中别名将被替换。<br>[compression_codec]定义字段的压缩方法，默认采用lz4压缩方法，可以通过下面的方式dt Date CODEC(ZSTD)指定压缩方法。<br>[TTL expr1]代表值的存储时间，只能为 MergeTree 系列表指定。<br>通过ENGINE可以指定表所用到的引擎，比如最常用的MergeTree。 通过PRIMARY KEY(expr1[, expr2,…])]可以定义表的主键。 </li>
<li>方式二：从另一张表中创建表<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] [db.]table_name <span class="keyword">AS</span> [db2.]name2 [ENGINE <span class="operator">=</span> engine]</span><br><span class="line">例子：</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> user2 <span class="keyword">AS</span> <span class="keyword">user</span></span><br></pre></td></tr></table></figure></li>
<li>方式三：select语句建表<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] [db.]table_name[(name1 [type1], name2 [type2], ...)] ENGINE <span class="operator">=</span> engine <span class="keyword">AS</span> <span class="keyword">SELECT</span> ...</span><br><span class="line"></span><br><span class="line">例子：</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> user3 ENGINE <span class="operator">=</span> MergeTree <span class="keyword">PRIMARY</span> KEY(id)</span><br><span class="line"><span class="keyword">AS</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="2">
<li>修改表<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> [db].name [<span class="keyword">ON</span> CLUSTER cluster] <span class="keyword">ADD</span><span class="operator">|</span><span class="keyword">DROP</span><span class="operator">|</span>RENAME<span class="operator">|</span>CLEAR<span class="operator">|</span>COMMENT<span class="operator">|</span>&#123;MODIFY<span class="operator">|</span><span class="keyword">ALTER</span>&#125;<span class="operator">|</span>MATERIALIZE <span class="keyword">COLUMN</span> ...</span><br><span class="line"></span><br><span class="line">例子：</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">table</span> <span class="keyword">user</span> <span class="keyword">add</span> <span class="keyword">column</span> sex String;</span><br></pre></td></tr></table></figure></li>
<li>删除表<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> [TEMPORARY] <span class="keyword">TABLE</span> [IF <span class="keyword">EXISTS</span>] [db.]name [<span class="keyword">ON</span> CLUSTER cluster]</span><br><span class="line"></span><br><span class="line">例子：</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> user3</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><p>OLAP型数据库的一种特性是数据以相当大的批次(&gt; 1000行)更新，而不是单行更新;或者根本没有更新；绝大多数是读请求。因此查询操作是ck最主要的应用。<br>语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">WITH</span> expr_list<span class="operator">|</span>(subquery)]</span><br><span class="line"><span class="keyword">SELECT</span> [<span class="keyword">DISTINCT</span>] expr_list</span><br><span class="line">[<span class="keyword">FROM</span> [db.]<span class="keyword">table</span> <span class="operator">|</span> (subquery) <span class="operator">|</span> table_function] [<span class="keyword">FINAL</span>]</span><br><span class="line">[SAMPLE sample_coeff]</span><br><span class="line">[<span class="keyword">ARRAY</span> <span class="keyword">JOIN</span> ...]</span><br><span class="line">[<span class="keyword">GLOBAL</span>] [<span class="keyword">ANY</span><span class="operator">|</span><span class="keyword">ALL</span><span class="operator">|</span>ASOF] [<span class="keyword">INNER</span><span class="operator">|</span><span class="keyword">LEFT</span><span class="operator">|</span><span class="keyword">RIGHT</span><span class="operator">|</span><span class="keyword">FULL</span><span class="operator">|</span><span class="keyword">CROSS</span>] [<span class="keyword">OUTER</span><span class="operator">|</span>SEMI<span class="operator">|</span>ANTI] <span class="keyword">JOIN</span> (subquery)<span class="operator">|</span><span class="keyword">table</span> (<span class="keyword">ON</span> <span class="operator">&lt;</span>expr_list<span class="operator">&gt;</span>)<span class="operator">|</span>(<span class="keyword">USING</span> <span class="operator">&lt;</span>column_list<span class="operator">&gt;</span>)</span><br><span class="line">[PREWHERE expr]</span><br><span class="line">[<span class="keyword">WHERE</span> expr]</span><br><span class="line">[<span class="keyword">GROUP</span> <span class="keyword">BY</span> expr_list] [<span class="keyword">WITH</span> TOTALS]</span><br><span class="line">[<span class="keyword">HAVING</span> expr]</span><br><span class="line">[<span class="keyword">ORDER</span> <span class="keyword">BY</span> expr_list] [<span class="keyword">WITH</span> FILL] [<span class="keyword">FROM</span> expr] [<span class="keyword">TO</span> expr] [STEP expr]</span><br><span class="line">[LIMIT [offset_value, ]n <span class="keyword">BY</span> columns]</span><br><span class="line">[LIMIT [n, ]m] [<span class="keyword">WITH</span> TIES]</span><br><span class="line">[<span class="keyword">UNION</span> <span class="keyword">ALL</span> ...]</span><br><span class="line">[<span class="keyword">INTO</span> OUTFILE filename]</span><br><span class="line">[FORMAT format]</span><br><span class="line">例子：</span><br><span class="line">查询所有的数据</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span></span><br><span class="line">查询所有列名中带a的数据</span><br><span class="line"><span class="keyword">select</span> columns(<span class="string">&#x27;a&#x27;</span>) <span class="keyword">from</span> <span class="keyword">user</span></span><br><span class="line">按地区进行聚合，统计每个地区的平均分</span><br><span class="line"><span class="keyword">select</span> address,<span class="built_in">AVG</span>(grade) <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">group</span> <span class="keyword">by</span> address</span><br></pre></td></tr></table></figure>
<ol>
<li>ALL子句</li>
<li>ARRAY JOIN子句<br>对于包含数组列的表来说是一种常见的操作，用于生成一个新表，该表具有包含该初始列中的每个单独数组元素的列，而其他列的值将被重复显示。 </li>
<li>DISTINCT子句<br>如果 SELECT DISTINCT 被声明，则查询结果中只保留唯一行。 因此，在结果中所有完全匹配的行集合中，只有一行被保留。<br>DISTINCT 适用于 NULL 就好像 NULL 是一个特定的值，并且 NULL&#x3D;&#x3D;NULL. 换句话说，在 DISTINCT 结果，不同的组合 NULL 仅发生一次。 它不同于 NULL 在大多数其他情况中的处理方式。</li>
<li>格式化子句<br>格式化 SELECT 的输出</li>
</ol>
<h4 id="查询-1"><a href="#查询-1" class="headerlink" title="查询"></a>查询</h4><hr>
<p>END</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>ClickHouse</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker入门</title>
    <url>/posts/89826705.html</url>
    <content><![CDATA[<h3 id="什么是容器"><a href="#什么是容器" class="headerlink" title="什么是容器"></a>什么是容器</h3><p>容器一词的英文是container，容器是一种通用技术，docker只是其中的一种实现。<br>容器更加的轻量级且占用的资源更少，与操作系统动辄几G的内存占用相比，容器技术只需数M空间，因此我们可以在同样规格的硬件上大量部署容器，这是虚拟机所不能比拟的，而且不同于操作系统数分钟的启动时间容器几乎瞬时启动，容器技术为打包服务栈提供了一种更加高效的方式。</p>
<h3 id="什么是docker"><a href="#什么是docker" class="headerlink" title="什么是docker"></a>什么是docker</h3><p>docker是一个用Go语言实现的开源项目，可以让我们方便的创建和使用容器，docker将程序以及程序所有的依赖都打包到docker container，这样你的程序可以在任何环境都会有一致的表现，这里程序运行的依赖也就是容器就好比集装箱，容器所处的操作系统环境就好比货船或港口，程序的表现只和集装箱有关系(容器)，和集装箱放在哪个货船或者哪个港口(操作系统)没有关系。</p>
<h3 id="Docker优点"><a href="#Docker优点" class="headerlink" title="Docker优点"></a>Docker优点</h3><p>1、快速，一致地交付您的应用程序<br>2、响应式部署和扩展<br>3、在同一硬件上运行更多工作负载</p>
<h3 id="Docker架构"><a href="#Docker架构" class="headerlink" title="Docker架构"></a>Docker架构</h3><p>三个基本概念:<br>镜像（Image）：Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。<br>容器（Container）：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。<br>仓库（Repository）：仓库可看成一个代码控制中心，用来保存镜像。</p>
<p>Docker 使用客户端-服务器 (C&#x2F;S) 架构模式，使用远程API来管理和创建Docker容器。<br>Docker 容器通过 Docker 镜像来创建。<br>容器与镜像的关系类似于面向对象编程中的对象与类。</p>
<h3 id="Docker-安装"><a href="#Docker-安装" class="headerlink" title="Docker 安装"></a>Docker 安装</h3><p>1.官方安装脚本自动安装<br>curl -fsSL <a href="https://test.docker.com/">https://test.docker.com</a> -o test-docker.sh sudo sh test-docker.sh<br>2.手动安装</p>
<h3 id="容器使用"><a href="#容器使用" class="headerlink" title="容器使用"></a>容器使用</h3><ul>
<li><p>客户端<br>查看到 Docker 客户端的所有命令选项：docker<br>了解指定的 Docker 命令使用方法：docker command –help</p>
</li>
<li><p>容器使用<br>获取镜像：docker pull ubuntu</p>
</li>
</ul>
<p>启动容器：docker run -it ubuntu &#x2F;bin&#x2F;bash<br>注：要退出终端，直接输入 exit<br>参数说明：<br>-i: 交互式操作。<br>-t: 终端。<br>ubuntu: ubuntu 镜像。<br>&#x2F;bin&#x2F;bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 &#x2F;bin&#x2F;bash。</p>
<p>后台运行：docker run -itd –name ubuntu-test ubuntu &#x2F;bin&#x2F;bash<br>注：加了 -d 参数默认不会进入容器，想要进入容器需要使用指令 docker exec</p>
<p>查看所有的容器命令：docker ps -a<br>启动一个已停止的容器：docker start &lt;容器 ID&gt;<br>停止一个容器：docker stop &lt;容器 ID&gt;<br>重启停止的容器：docker restart &lt;容器 ID&gt;</p>
<p>进入后台。此时想要进入容器，可以通过以下指令进入：<br>docker attach &lt;容器 ID&gt;<br>docker exec -it &lt;容器 ID&gt; &#x2F;bin&#x2F;bash 推荐大家使用 docker exec 命令，因为此命令会退出容器终端，但不会导致容器的停止。</p>
<p>导出和导入容器：<br>导出本地某个容器：docker export &lt;容器 ID&gt; &gt; ubuntu.tar<br>导入容器快照：<br>将快照文件 ubuntu.tar 导入到镜像 test&#x2F;ubuntu:v1：<br>cat docker&#x2F;ubuntu.tar | docker import - test&#x2F;ubuntu:v1<br>通过指定 URL 或者某个目录来导入：<br>docker import <a href="http://example.com/exampleimage.tgz">http://example.com/exampleimage.tgz</a> example&#x2F;imagerepo</p>
<p>删除容器：docker rm -f &lt;容器 ID&gt;</p>
<h3 id="镜像使用"><a href="#镜像使用" class="headerlink" title="镜像使用"></a>镜像使用</h3><p>列出本地主机上的镜像：docker images<br>选项说明:<br>REPOSITORY：表示镜像的仓库源<br>TAG：镜像的标签<br>IMAGE ID：镜像ID<br>CREATED：镜像创建时间<br>SIZE：镜像大小</p>
<p>获取一个新的镜像：docker pull ubuntu:13.10<br>查找镜像：docker search httpd<br>选项说明:<br>NAME: 镜像仓库源的名称<br>DESCRIPTION: 镜像的描述<br>OFFICIAL: 是否 docker 官方发布<br>stars: 类似 Github 里面的 star，表示点赞、喜欢的意思。<br>AUTOMATED: 自动构建。<br>删除镜像：docker rmi hello-world<br>创建镜像：<br>1、从已经创建的容器中更新镜像，并且提交这个镜像<br>2、使用 Dockerfile 指令来创建一个新的镜像<br>更新镜像：<br>在运行的容器内使用 apt-get update 命令进行更新<br>构建镜像：docker build</p>
<h3 id="如何使用docker"><a href="#如何使用docker" class="headerlink" title="如何使用docker"></a>如何使用docker</h3><p>docker中有这样几个概念：<br>dockerfile<br>image<br>container</p>
<p>实际上你可以简单的把image理解为可执行程序，container就是运行起来的进程。<br>那么写程序需要源代码，那么“写”image就需要dockerfile，dockerfile就是image的源代码，docker就是”编译器”。<br>因此我们只需要在dockerfile中指定需要哪些程序、依赖什么样的配置，之后把dockerfile交给“编译器”docker进行“编译”，也就是docker build命令，生成的可执行程序就是image，之后就可以运行这个image了，这就是docker run命令，image运行起来后就是docker container。</p>
<h3 id="docker是如何工作的"><a href="#docker是如何工作的" class="headerlink" title="docker是如何工作的"></a>docker是如何工作的</h3><p>docker使用了常见的CS架构，也就是client-server模式，docker client负责处理用户输入的各种命令，比如docker build、docker run，真正工作的其实是server，也就是docker demon，值得注意的是，docker client和docker demon可以运行在同一台机器上。</p>
<h3 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h3><h4 id="docker-build"><a href="#docker-build" class="headerlink" title="docker build"></a>docker build</h4><p>当我们写完dockerfile交给docker“编译”时使用这个命令，那么client在接收到请求后转发给docker daemon，接着docker daemon根据dockerfile创建出“可执行程序”image</p>
<h4 id="docker-run"><a href="#docker-run" class="headerlink" title="docker run"></a>docker run</h4><p>有了“可执行程序”image后就可以运行程序了，接下来使用命令docker run，docker daemon接收到该命令后找到具体的image，然后加载到内存开始执行，image执行起来就是所谓的container</p>
<h4 id="docker-pull"><a href="#docker-pull" class="headerlink" title="docker pull"></a>docker pull</h4><p>Docker Hub，docker官方的“应用商店”，你可以在这里下载到别人编写好的image，这样你就不用自己编写dockerfile了。<br>docker registry 可以用来存放各种image，公共的可以供任何人下载image的仓库就是docker Hub。那么该怎么从Docker Hub中下载image呢，就是这里的docker pull命令了。<br>用户通过docker client发送命令，docker daemon接收到命令后向docker registry发送image下载请求，下载后存放在本地，这样我们就可以使用image了</p>
<h3 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h3><p>docker基于Linux内核提供这样几项功能实现的：<br>NameSpace<br>我们知道Linux中的PID、IPC、网络等资源是全局的，而NameSpace机制是一种资源隔离方案，在该机制下这些资源就不再是全局的了，而是属于某个特定的NameSpace，各个NameSpace下的资源互不干扰，这就使得每个NameSpace看上去就像一个独立的操作系统一样，但是只有NameSpace是不够。<br>Control groups<br>虽然有了NameSpace技术可以实现资源隔离，但进程还是可以不受控的访问系统资源，比如CPU、内存、磁盘、网络等，为了控制容器中进程对资源的访问，Docker采用control groups技术(也就是cgroup)，有了cgroup就可以控制容器中进程对系统资源的消耗了，比如你可以限制某个容器使用内存的上限、可以在哪些CPU上运行等等。</p>
<hr>
<p>👽END</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Dubbo入门</title>
    <url>/posts/85d72779.html</url>
    <content><![CDATA[<h3 id="网站开发架构发展"><a href="#网站开发架构发展" class="headerlink" title="网站开发架构发展"></a>网站开发架构发展</h3><p>单一应用架构<br>当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM)是关键。<br>垂直应用架构<br>当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的Web框架(MVC)是关键。<br>分布式服务架构<br>当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式服务框架(RPC)是关键。<br>流动计算架构<br>当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)是关键。</p>
<h3 id="Dubbo简介"><a href="#Dubbo简介" class="headerlink" title="Dubbo简介"></a>Dubbo简介</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>Apache Dubbo 是一款 RPC 服务开发框架，其前身是阿里巴巴公司开源的一个高性能、轻量级的开源Java RPC框架，可以和Spring框架无缝集成。用于解决微服务架构下的服务治理与通信问题，官方提供了 Java、Golang 等多语言 SDK 实现。使用 Dubbo 开发的微服务原生具备相互之间的远程地址发现与通信能力， 利用 Dubbo 提供的丰富服务治理特性，可以实现诸如服务发现、负载均衡、流量调度等服务治理诉求。Dubbo 被设计为高度可扩展，用户可以方便的实现流量拦截、选址的各种定制逻辑。</p>
<p>什么是RPC？<br>RPC全称为remote procedure call，即远程过程调用。比如两台服务器A和B，A服务器上部署一个应用，B服务器上部署一个应用，A服务器上的应用想调用B服务器上的应用提供的方法，由于两个应用不在一个内存空间，不能直接调用，所以需要通过网络来表达调用的语义和传达调用的数据。<br>需要注意的是RPC并不是一个具体的技术，而是指整个网络远程调用过程。<br>RPC是一个泛化的概念，严格来说一切远程过程调用手段都属于RPC范畴。各种开发语言都有自己的RPC框架。Java中的RPC框架比较多，广泛使用的有RMI、Hessian、Dubbo等。</p>
<h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><p>负载均衡——同一个服务部署在不同的机器时该调用那一台机器上的服务<br>服务调用链路生成——随着系统的发展，服务越来越多，服务间依赖关系变得错踪复杂，甚至分不清哪个应用要在哪个应用之前启动，架构师都不能完整的描述应用的架构关系。Dubbo 可以为我们解决服务之间互相是如何调用的。<br>服务访问压力以及时长统计、资源调度和治理——基于访问压力实时管理集群容量，提高集群利用率。<br>服务降级——某个服务挂掉之后调用备用服务 另外，Dubbo 除了能够应用在分布式系统中，也可以应用在现在比较火的微服务系统中。不过，由于 Spring Cloud 在微服务中应用更加广泛，所以，我觉得一般我们提 Dubbo 的话，大部分是分布式系统的情况。</p>
<h3 id="Dubbo架构"><a href="#Dubbo架构" class="headerlink" title="Dubbo架构"></a>Dubbo架构</h3><h4 id="架构节点简单说明："><a href="#架构节点简单说明：" class="headerlink" title="架构节点简单说明："></a>架构节点简单说明：</h4><p>Provider： 暴露服务的服务提供方<br>Consumer： 调用远程服务的服务消费方<br>Registry： 服务注册与发现的注册中心<br>Monitor： 统计服务的调用次数和调用时间的监控中心<br>Container： 服务运行容器</p>
<h4 id="调用关系说明："><a href="#调用关系说明：" class="headerlink" title="调用关系说明："></a>调用关系说明：</h4><p>服务容器负责启动，加载，运行服务提供者。<br>服务提供者在启动时，向注册中心注册自己提供的服务。<br>服务消费者在启动时，向注册中心订阅自己所需的服务。<br>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。<br>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。<br>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟8. 发送一次统计数据到监控中心。</p>
<h4 id="知识点："><a href="#知识点：" class="headerlink" title="知识点："></a>知识点：</h4><p>注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，压力较小<br>监控中心负责统计各服务调用次数，调用时间等，统计先在内存汇总后每分钟一次发送到监控中心服务器，并以报表展示<br>注册中心，服务提供者，服务消费者三者之间均为长连接，监控中心除外<br>注册中心通过长连接感知服务提供者的存在，服务提供者宕机，注册中心将立即推送事件通知消费者<br>注册中心和监控中心全部宕机，不影响已运行的提供者和消费者，消费者在本地缓存了提供者列表<br>注册中心和监控中心都是可选的，服务消费者可以直连服务提供者<br>服务提供者无状态，任意一台宕掉后，不影响使用<br>服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复</p>
<hr>
<p>😃END</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hibernate入门</title>
    <url>/posts/f89c868b.html</url>
    <content><![CDATA[<h3 id="Hibernate简介"><a href="#Hibernate简介" class="headerlink" title="Hibernate简介"></a>Hibernate简介</h3><h4 id="1-什么是Hibernate"><a href="#1-什么是Hibernate" class="headerlink" title="1.什么是Hibernate"></a>1.什么是Hibernate</h4><p>Hibernate是一个开放源代码的对象关系映射框架，它对JDBC进行了非常轻量级的对象封装，它将POJO与数据库表建立映射关系，是一个全自动的orm框架，hibernate可以自动生成SQL语句，自动执行，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。Hibernate可以应用在任何使用JDBC的场合，既可以在Java的客户端程序使用，也可以在Servlet&#x2F;JSP的Web应用中使用。</p>
<h4 id="2-什么是ORM"><a href="#2-什么是ORM" class="headerlink" title="2.什么是ORM"></a>2.什么是ORM</h4><p>对象关系映射（英语：Object Relation Mapping，简称ORM，或O&#x2F;RM，或O&#x2F;R mapping），是一种程序技术，用于实现面向对象编程语言里不同类型系统的数据之间的转换。<br>ORM模型的简单性简化了数据库查询过程。使用ORM查询工具，用户可以访问期望数据，而不必理解数据库的底层结构。<br>简单来说，我们使用ORM可以将我们的对象(或类)去进行映射，使得我们可以去操作对象就能完成对表的操作。</p>
<h4 id="3-Hibernate开发步骤"><a href="#3-Hibernate开发步骤" class="headerlink" title="3.Hibernate开发步骤"></a>3.Hibernate开发步骤</h4><p>创建持久化类<br>创建对象-关系映射文件<br>创建Hibernate配置文件<br>通过Hibernate API编写访问数据库的代码</p>
<h4 id="4-Hibernate的5个核心接口"><a href="#4-Hibernate的5个核心接口" class="headerlink" title="4.Hibernate的5个核心接口"></a>4.Hibernate的5个核心接口</h4><p>Configuration：负责管理hibernate配置信息<br>SessionFactory：负责创建session实例<br>Session：是hibernate持久化操作的基础，提供了众多的持久化方法<br>Transaction：是hibernate进行事务操作的接口，是对实际事务实现的一个抽象，这些实现包括JDBC的事务，JTA中的UserTransaction,甚至可以是CORBA事务。<br>Query和Criteria接口 :查询接口，用于向数据库查询对象，包装了HQL查询语言，采用了新的面向对象的查询方式。</p>
<h4 id="5-hibernate执行过程"><a href="#5-hibernate执行过程" class="headerlink" title="5.hibernate执行过程"></a>5.hibernate执行过程</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>通过<span class="type">Configuration</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Configuration</span>().configure();<span class="comment">//读取并解析hibernate.cfg.xml配置文件</span></span><br><span class="line"><span class="number">2.</span>由hibernate.cfg.xml中的&lt;mapping resource=<span class="string">&quot;com/xx/User.hbm.xml&quot;</span>/&gt;读取并解析映射信息</span><br><span class="line"><span class="number">3.</span>通过<span class="type">SessionFactory</span> <span class="variable">sf</span> <span class="operator">=</span> config.buildSessionFactory();<span class="comment">//创建SessionFactory</span></span><br><span class="line"><span class="number">4.</span><span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> sf.openSession();<span class="comment">//打开Sesssion</span></span><br><span class="line"><span class="number">5.</span><span class="type">Transaction</span> <span class="variable">tx</span> <span class="operator">=</span> session.beginTransaction();<span class="comment">//创建并启动事务Transation</span></span><br><span class="line"><span class="number">6.</span>persistent operate操作数据，持久化操作</span><br><span class="line"><span class="number">7.</span>tx.commit();<span class="comment">//提交事务</span></span><br><span class="line"><span class="number">8.</span>关闭Session</span><br><span class="line"><span class="number">9.</span>关闭SesstionFactory</span><br></pre></td></tr></table></figure>

<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><h4 id="1-hibernate-cfg-xml"><a href="#1-hibernate-cfg-xml" class="headerlink" title="1.hibernate.cfg.xml"></a>1.hibernate.cfg.xml</h4><p>注：<br>常用的配置信息都可以在hibernate-distribution-3.6.0.Final\project\etc\hibernate.properties目录下可以找到。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hibernate-configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 通常，一个session-factory节点代表一个数据库 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">session-factory</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 1. 数据库连接配置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.connection.driver_class&quot;</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.connection.url&quot;</span>&gt;</span>jdbc:mysql:///xxx<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.connection.username&quot;</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.connection.password&quot;</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--            数据库方法配置， hibernate在运行的时候，会根据不同的方言生成符合当前数据库语法的sql         --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.dialect&quot;</span>&gt;</span>org.hibernate.dialect.MySQL5Dialect<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 2. 其他相关配置 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 2.1 显示hibernate在运行时候执行的sql语句 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.show_sql&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 2.2 格式化sql --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.format_sql&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 2.3 自动建表  --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.hbm2ddl.auto&quot;</span>&gt;</span>create<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--3. 加载所有映射--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapping</span> <span class="attr">resource</span>=<span class="string">&quot;xxx/xxx/User.hbm.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">session-factory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在程序中加载映射文件：<br>在Configuration对象中提供了addClass()的方法。<br>一般地我们的映射配置文件和JavaBean对象是放在同一个包下的。并且映射文件的命名是有规范的。因此Hibernate是可以通过提供的JavaBean对象从而找到相对应的映射文件！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取加载配置管理类</span></span><br><span class="line"><span class="type">Configuration</span> <span class="variable">configuration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Configuration</span>();</span><br><span class="line"><span class="comment">//加载User的映射文件！</span></span><br><span class="line">configuration.configure().addClass(User.class);</span><br></pre></td></tr></table></figure>
<h4 id="2-映射配置文件"><a href="#2-映射配置文件" class="headerlink" title="2.映射配置文件"></a>2.映射配置文件</h4><p>映射文件: 映射一个实体类对象； 描述一个对象最终实现可以直接保存对象数据到数据库中<br>通常地，我们都是一个JavaBean对象对应一个映射配置文件，并且配置文件和JavaBean对象是放在同一个目录下的</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--在domain包下--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span> <span class="attr">package</span>=<span class="string">&quot;zhongfucheng.domain&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--类名为User，表名也为User--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">&quot;User&quot;</span>  <span class="attr">table</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--主键映射，属性名为id，列名也为id--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--根据底层数据库主键自动增长--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">&quot;native&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--非主键映射，属性和列名一一对应--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">column</span>=<span class="string">&quot;username&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;cellphone&quot;</span> <span class="attr">column</span>=<span class="string">&quot;cellphone&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">column</span>=<span class="string">&quot;password&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>节点说明：<br><strong>hibernate-mapping</strong><br>package【要映射的对象所在的包(可选,如果不指定,此文件所有的类都要指定全路径)】<br>auto-import<br>-默认为true， 在写hql的时候自动导入包名<br>-如果指定为false, 再写hql的时候必须要写上类的全名；<br><strong>class</strong><br>class 映射某一个对象的(一般情况，一个对象写一个映射文件，即一个class节点)<br>name【指定要映射的对象的类型】<br>table【指定对象对应的表】如果没有指定，默认与对象名称一样<br><strong>property</strong><br>property是普通属性的映射，即JavaBean普通的成员变量属性就使用property来描述！<br>name 指定对象的属性名称<br>column 指定对象属性对应的表的字段名称<br>-如果不写默认与对象属性一致。<br>length 指定字符的长度, 默认为255<br>type 指定映射表的字段的类型，如果不指定会匹配属性的类型<br>-java类型： 必须写全名【例：java.lang.String】<br>-hibernate类型： 直接写类型，都是小写<br>注意：如果列名称为数据库关键字，需要用反引号或改列名。当然啦，我们一般不使用关键字来作为列名<br><strong>id</strong><br>id是主键映射<br>name 指定对象的属性名<br>column 指定对象属性对应的表的字段名称<br><strong>generator</strong><br>主键的自动生成策略<br> identity 自增长(mysql,db2)<br> sequence 自增长(序列)， oracle中自增长是以序列方法实现<br> native 自增长【会根据底层数据库自增长的方式选择identity或sequence】<br>  -如果是mysql数据库, 采用的自增长方式是identity<br>  -如果是oracle数据库， 使用sequence序列的方式实现自增长<br> increment 自增长(会有并发访问的问题，一般在服务器集群环境使用会存在问题。)<br>  -指定主键生成策略为手动指定主键的值<br> assigned<br>  -指定主键生成策略为UUID生成的值<br> uuid<br> foreign(外键的方式)<br><strong>composite-id</strong><br>主键一般分为两种：单列主键、多列复合主键<br>单列主键使用上述generator的方式<br>多列复合主键就需要使用composite-id节点来配置了<br>步骤：<br>想要使用username和password作为复合主键？<br>-将username和password抽取成一个类—-&gt;CompositeKey….必须实现Serializable接口<br>-在User2中需要指定一个变量来维护这个主键对象</p>
<h4 id="2-configuration-配置对象"><a href="#2-configuration-配置对象" class="headerlink" title="2.configuration:配置对象"></a>2.configuration:配置对象</h4><h5 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h5><p>在使用hibernate的时候,首先要创建configuration的实例,Configuration实例主要用于启动,加载,管理hibernate的配置文件信息,在启动hibernate的过程中,configuration首先确定hibernate的配置文件的位置,然后读取相关配置,最后创建一个唯一的SessionFactory实例,configuration值存在于最初的系统初始化阶段,它将sessionFactory创建完成之后,就完成它的使命了.hibernate通常会使用new Configuration().configure(),来创建一个配置类对象,默认的是在resources下的hibernate.cfg.xml配置文件,如果不想创建和该文件名一样的xml配置文件,可以在cofigure()中添加一个参数,参数的内容是配置文件的名称。<br>注：<br>它拥有一个子类AnnotationConfiguration，也就是说：我们可以使用注解来代替XML配置文件来配置相对应的信息</p>
<h5 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h5><p>configure()方法用于加载配置文件<br> -如果指定参数，那么加载参数的路径配置文件<br> -如果不指定参数，默认加载src&#x2F;目录下的hibernate.cfg.xml<br>buildSessionFactory()用于创建Session工厂</p>
<h4 id="3-sessionFactory：session的工厂对象，也可以说代表了hibernate-cfg-xml这个文件"><a href="#3-sessionFactory：session的工厂对象，也可以说代表了hibernate-cfg-xml这个文件" class="headerlink" title="3.sessionFactory：session的工厂对象，也可以说代表了hibernate.cfg.xml这个文件"></a>3.sessionFactory：session的工厂对象，也可以说代表了hibernate.cfg.xml这个文件</h4><h5 id="作用：-1"><a href="#作用：-1" class="headerlink" title="作用："></a>作用：</h5><p>sessionFactory接口负责将Hibernate的初始化和建立session对象,它在hibernate中起到一个缓冲区的作用,hibernate可以将自动生成的sql语句,映射数据以及某些可重复利用的数据放在这个缓冲区中,同时它还保存了对数据库配置的所有映射关系,维护了当前的二级缓存。<br>特点：<br>线程安全，它的同一个实例能够提供多个线程共享<br>重量级的，不能随意的创建和销毁它的实例</p>
<h5 id="方法：-1"><a href="#方法：-1" class="headerlink" title="方法："></a>方法：</h5><p>openSession方法创建一个Session对象<br>getCurrentSession方法创建Session对象或取出Session对象<br>两种方式的区别：<br>openSession获取Session时，sessionFactory直接创建一个新的Session实例，并在使用完成后需要调用close()手动关闭<br>getCurrentSession创建的Session实例会被绑定到当前线程种，它在提交或回滚操作时会自动关闭。</p>
<h4 id="8-Session：Hibernate最重要的对象"><a href="#8-Session：Hibernate最重要的对象" class="headerlink" title="8.Session：Hibernate最重要的对象"></a>8.Session：Hibernate最重要的对象</h4><h5 id="作用：-2"><a href="#作用：-2" class="headerlink" title="作用："></a>作用：</h5><p>Session是应用程序与数据库之间交互操作的一个单线程对象，是Hibernate运作的中心，它的主要功能是为持久化对象提供创建、读取和删除的能力，所有持久化对象必须在session的管理下才可以进行持久化操作。<br>Session是线程不安全的，多个并发线程同时操作一个Session实例时，可能导致Session数据存取的混乱</p>
<h5 id="删除操作："><a href="#删除操作：" class="headerlink" title="删除操作："></a>删除操作：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">session.delete();  【删除一个对象】</span><br></pre></td></tr></table></figure>
<h5 id="更新操作："><a href="#更新操作：" class="headerlink" title="更新操作："></a>更新操作：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">session.save(obj); 【保存一个对象】</span><br><span class="line">session.update(obj); 【更新一个对象】</span><br><span class="line">session.saveOrUpdate(obj); 【保存或者更新的方法】</span><br><span class="line">-没有设置主键，执行保存；</span><br><span class="line">-有设置主键，执行更新操作;</span><br><span class="line">-如果设置主键不存在报错！</span><br></pre></td></tr></table></figure>
<h5 id="主键查询："><a href="#主键查询：" class="headerlink" title="主键查询："></a>主键查询：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">session.get(javaBean.class, <span class="type">int</span> id); 【传入对应的class和id就可以查询】</span><br><span class="line">session.load(javaBean.class, <span class="type">int</span> id); 【支持懒加载】</span><br></pre></td></tr></table></figure>
<h5 id="HQL查询："><a href="#HQL查询：" class="headerlink" title="HQL查询："></a>HQL查询：</h5><p><strong>HQL vs SQL</strong><br>HQL:hibernate query language 即hibernate提供的面向对象的查询语言<br>注：<br>查询的是对象以及对象的属性【因此是区分大小写的！】。<br>HQL是面向对象的查询语言，可以用来查询全部的数据！<br>SQL：Struct query language 结构化查询语言<br>注：<br>查询的是表以及列【不区分大小写】<br>实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Query</span> <span class="variable">query</span> <span class="operator">=</span> session.createQuery(<span class="string">&quot;FROM User&quot;</span>);</span><br><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> query.list();</span><br><span class="line">System.out.println(list);</span><br><span class="line"><span class="type">Query</span> <span class="variable">query</span> <span class="operator">=</span> session.createQuery(<span class="string">&quot;FROM User WHERE id=?&quot;</span>);</span><br><span class="line"><span class="comment">//这里的？号是从0开始的，并不像JDBC从1开始的！</span></span><br><span class="line">query.setParameter(<span class="number">0</span>, user.getId());</span><br><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> query.list();</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure>
<h5 id="QBC查询"><a href="#QBC查询" class="headerlink" title="QBC查询"></a>QBC查询</h5><p>QBC查询: query by criteria 完全面向对象的查询<br>HQL查询是需要SQL的基础的，因为还是要写少部分的SQL代码….QBC查询就是完全的面向对象查询…但是用得比较少</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建关于user对象的criteria对象</span></span><br><span class="line"><span class="type">Criteria</span> <span class="variable">criteria</span> <span class="operator">=</span> session.createCriteria(User.class);</span><br><span class="line"><span class="comment">//添加条件</span></span><br><span class="line">criteria.add(Restrictions.eq(<span class="string">&quot;id&quot;</span>, <span class="number">1</span>));</span><br><span class="line"><span class="comment">//查询全部数据</span></span><br><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> criteria.list();</span><br><span class="line"> System.out.println(list);</span><br></pre></td></tr></table></figure>
<h5 id="本地SQL查询"><a href="#本地SQL查询" class="headerlink" title="本地SQL查询"></a>本地SQL查询</h5><p>有的时候，如果SQL是非常复杂的，我们不能靠HQL查询来实现功能的话，我们就需要使用原生的SQL来进行复杂查询了！<br>但是呢，它有一个缺陷：它是不能跨平台的…因此我们在主配置文件中已经配置了数据库的“方言“了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将所有的记录封装成User对象存进List集合中</span></span><br><span class="line"><span class="type">SQLQuery</span> <span class="variable">sqlQuery</span> <span class="operator">=</span> session.createSQLQuery(<span class="string">&quot;SELECT * FROM user&quot;</span>).addEntity(User.class);</span><br><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> sqlQuery.list();</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure>
<h5 id="beginTransaction方法"><a href="#beginTransaction方法" class="headerlink" title="beginTransaction方法"></a>beginTransaction方法</h5><p>开启事务，返回的是一个事务对象….Hibernate规定所有的数据库操作都必须在事务环境下进行，否则报错！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Transaction transaction=session.beginTransaction();</span><br></pre></td></tr></table></figure>
<h4 id="9-transaction事务"><a href="#9-transaction事务" class="headerlink" title="9.transaction事务"></a>9.transaction事务</h4><p>Transaction接口主要用于管理事务，它是Hibernate的数据库事务接口，Transaction接口的事务对象是通过Session对象开启的<br>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">transaction.commit();  提交相关联的session实例</span><br><span class="line">transaction.rollback();  撤销事务操作</span><br></pre></td></tr></table></figure>

<h3 id="Hibernate的一级缓存"><a href="#Hibernate的一级缓存" class="headerlink" title="Hibernate的一级缓存"></a>Hibernate的一级缓存</h3><p>Hibernate的缓存分为一级缓存和二级缓存，Hibernate的混村都位于持久化层，存储的是数据库数据的备份，其中一级缓存为Hibernate的内置缓存，不能被卸载。<br>一级缓存：<br>就是指Session缓存，Session缓存是一块内存空间，用来存放相互管理的java对象，在使用Hibernate查询对象的时候，首先会使用对象属性的OID值在Hibernate的一级缓存种进行查找，如果找到，就将对应的对象从一级缓存中去除使用，不会再去查询数据库；如果没有找到，才会去数据库中查找相应数据，当从数据库中查询到所需数据时，该数据信息会被放置到一级缓存中。<br>一级缓存的作用：<br>减少对数据库的访问次数。<br>一级缓存的特点;<br>调用save()、update()、saveOrUpdate()时，如果一级缓存中没有相应对象，就会自动将信息加入一级缓存<br>调用load()、get()、Query接口的list()、iterator()时，会先去一级缓存查看是否存在该对象，没有再去数据库，并添加进一级缓存<br>调用close()时，一级缓存会被清空。</p>
<hr>
<p>😄END</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaEE</title>
    <url>/posts/9daba997.html</url>
    <content><![CDATA[<h3 id="类："><a href="#类：" class="headerlink" title="类："></a>类：</h3><p>​	类中有且仅有五大成分：成员变量、成员方法、构造器、代码块、内部类<br>​	创建对象时：new的是构造器</p>
<h3 id="this"><a href="#this" class="headerlink" title="this:"></a>this:</h3><p>​	作用：<br>​			this代表当前对象的引用<br>​			this可以用在实例方法和构造器中</p>
<h3 id="封装："><a href="#封装：" class="headerlink" title="封装："></a>封装：</h3><p>​	作用：为了安全，可以实现代码的组件化<br>​	核心思想：合理隐藏，合理暴露</p>
<h3 id="static"><a href="#static" class="headerlink" title="static:"></a>static:</h3><p>​	注意：在同一个类中访问静态成员可以省略类名不写<br>​		静态方法不可以直接访问实例变量&#x2F;方法</p>
<h3 id="继承："><a href="#继承：" class="headerlink" title="继承："></a>继承：</h3><p>​	作用：可以提高代码的复用<br>​	特点：<br>​			单继承：一个类只能继承一个直接父类，可以多层继承<br>​					为什么？因为会出现二义性。当被继承的两个父类有同名方法时，无法确定调用的是哪一个<br>​	继承后的构造器：<br>​			子类的构造器的第一行默认有一个 super() 调用了父类的无参数构造器，用于初始化父类信息<br>​			可以在子类构造器长通过super(形参)指定调用父类的某个构造器（必须在第一行）<br>​	注意：<br>​			子类不能继承父类的构造器<br>​			子类能继承父类的私有成员（但是不能直接访问）<br>​			子类不能继承父类的静态成员（但是可以访问）<br>​			this(参数)与super(参数)必须放在构造器的第一行，否则报错</p>
<h3 id="重写："><a href="#重写：" class="headerlink" title="重写："></a>重写：</h3><p>​	方法重写的校验注解：@Override   加上这个注解就必须是重写父类的方法，否则报错<br>​	注意：<br>​			子类不能重写父类的私有成员<br>​			子类不能重写父类的静态成员</p>
<h3 id="抽象类：abstract"><a href="#抽象类：abstract" class="headerlink" title="抽象类：abstract"></a>抽象类：abstract</h3><p>​	特征：<br>​			抽象类虽然有构造器但是不能创建对象<br>​	存在的意义：<br>​			抽象类就是为了被子类继承<br>​			抽象类体现的是模板思想：部分实现，部分抽象<br>​	注意：<br>​			拥有抽象方法必须定义成抽象类<br>​			抽象方法没有方法体，只有方法签名<br>​			抽象类除了抽象方法，也可以具备其他类能具有的成分<br>​			抽象类一定有构造器，以供子类创建对象时，初始化父类成员使用<br>​			抽象类不一定包含抽象方法<br>​			抽象类的子类必须重写父抽象类的所有抽象方法</p>
<h3 id="接口："><a href="#接口：" class="headerlink" title="接口："></a>接口：</h3><p>​		常量的标准定义：public static final 类型 名称&#x3D;值<br>​		注意：<br>​			接口中的抽象方法可以省略public abstract，默认会加上<br>​			接口中的抽象方法可以省略public static final，默认会加上<br>​			java1.8之前接口中只能是抽象方法和常量。1.8之后新增了默认方法(用default修饰)，静态方法，私有方法<br>​			默认方法相当于实例方法，只能用接口的实现类的对象来调用<br>​			接口的静态方法只能用接口名来调用<br>​			接口的私有方法其实是JDK1.9开始支持<br>​			接口可以多实现（逗号隔开）<br>​			接口与接口可以多继承<br>​			一个类既继承一个父类，又实现若干个接口时，父类的成员方法与接口的默认方法崇明，子类会执行父类的成员方法。<br>​			接口没有构造器，不能创建对象</p>
<h3 id="代码块："><a href="#代码块：" class="headerlink" title="代码块："></a>代码块：</h3><p>​		静态代码块：</p>
<p>​			触发一次，与类一起优先加载</p>
<p>​			可以用于执行静态资源的初始化操作</p>
<p>​		实例代码块：（很少用）</p>
<p>​			创建对象时执行一次</p>
<h3 id="final"><a href="#final" class="headerlink" title="final:"></a>final:</h3><p>​		final修饰类：类不能被继承了</p>
<p>​		final修饰方法：方法不能被重写了</p>
<p>​		final修饰变量：变量只能被赋值一次（起保护作用，防止值被修改）</p>
<p>​				final修饰静态变量：变量就变成常量了</p>
<p>​		注意：</p>
<p>​			abstract与final是互斥关系，不能同时出现修饰成员</p>
<h3 id="枚举类："><a href="#枚举类：" class="headerlink" title="枚举类："></a>枚举类：</h3><p>​		作用：枚举类用于做信息标志和信息分类</p>
<p>​		注意：枚举类是多例设计模式</p>
<h3 id="多态："><a href="#多态：" class="headerlink" title="多态："></a>多态：</h3><p>​		形式：</p>
<p>​				父类类型 对象名称&#x3D;new 子类构造器;</p>
<p>​				接口 对象名称&#x3D;new 实现类构造器;</p>
<p>​		概念：同一类型的对象，执行同一行为，在不同的状态下会表现出不同的行为特征</p>
<p>​		多态的识别：</p>
<p>​				对方法的调用：编译看左边，运行看右边</p>
<p>​				对变量的调用：编译看左边，运行看左边</p>
<p>​		使用前提：</p>
<p>​				必须存在继承或实现关系</p>
<p>​				必须存在父类类型的变量引用子类类型的对象</p>
<p>​				需要存在方法的重写</p>
<p>​		优势：</p>
<p>​				右边对象可以实现组件化切换，以便于扩展和维护，可以实现类与类之间的解耦</p>
<p>​				父类类型作为方法形式参数，传递子类对象给方法</p>
<p>​		劣势：</p>
<p>​				多态形式下，不能直接调用子类特有的功能</p>
<p>​		类型判断： 变量 instanceof 类型     判断前面的变量是否是后面的类型，是则返回true</p>
<h3 id="内部类："><a href="#内部类：" class="headerlink" title="内部类："></a>内部类：</h3><p>​		作用：可以提供更好的封装性，内部类有更多权限修饰符，封装性有更多的控制</p>
<p>​		分类：</p>
<p>​				静态内部类：创建对象：外部类.内部类 对象名称&#x3D;new 外部类.内部类构造器</p>
<p>​				实例内部类：创建对象：外部类.内部类 对象名称&#x3D;new 外部类构造器.new 内部类构造器</p>
<p>​						注意：不能在实例内部类中定义静态成员，但可以定义常量</p>
<p>​				局部内部类</p>
<p>​				匿名内部类：</p>
<p>​						格式：new 类名|抽象类|接口(形参){方法重写}</p>
<h3 id="权限修饰符："><a href="#权限修饰符：" class="headerlink" title="权限修饰符："></a>权限修饰符：</h3><p>​		private只能在本类中访问</p>
<p>​		缺省只能在本包或本类中访问</p>
<p>​		protected只能在本类，本包以及其他包的子类中访问</p>
<p>​		public可以在任何地方访问</p>
<h3 id="Objects类："><a href="#Objects类：" class="headerlink" title="Objects类："></a>Objects类：</h3><p>​		Object类的子类，JDK1.7开始之后才有</p>
<p>​		两个方法：equals()  比较两个对象（不会出现空指针异常）</p>
<p>​							isNull() 判断是否为null</p>
<h3 id="Date类："><a href="#Date类：" class="headerlink" title="Date类："></a>Date类：</h3><p>​		构造器：Date()       Date(long time)</p>
<p>​		方法：getTime() 获取当前时间戳</p>
<p>​	SimpleDateFormat类：</p>
<p>​			.format() 用来格式化日期对象&#x2F;时间戳</p>
<p>​			.parse() 格式化字符串</p>
<p>​	Calender抽象类：可以快速的计算多少天后的日期</p>
<h3 id="Math类："><a href="#Math类：" class="headerlink" title="Math类："></a>Math类：</h3><p>​		绝对值：Math.abs()   向上取整：Math.ceil()   向下取整：Math.floor()</p>
<p>​		求指数次方：Math.pow()   四舍五入：Math.round()</p>
<h3 id="System系统类："><a href="#System系统类：" class="headerlink" title="System系统类："></a>System系统类：</h3><p>​		终止当前虚拟机：System.exit(0)</p>
<h3 id="BigDicimal类：解决浮点型精度问题"><a href="#BigDicimal类：解决浮点型精度问题" class="headerlink" title="BigDicimal类：解决浮点型精度问题"></a>BigDicimal类：解决浮点型精度问题</h3><p>​		BigDicimal.valueOf()  包装浮点数为大数据对象</p>
<p>​		.doubleValue()  把BigDicimal转换成double类型</p>
<h3 id="包装类："><a href="#包装类：" class="headerlink" title="包装类："></a>包装类：</h3><p>​		自动装箱：基本类型的值或变量赋值给包装类</p>
<p>​		自动拆箱：包装类的值或变量赋值基本类型</p>
<p>​		注意：也可以手动装箱，手动拆箱</p>
<p>​		特殊功能：把字符串类型的数值转换成对应的基本数据类型</p>
<p>​				Integer.parseInt()       Integer.valueOf()</p>
<h3 id="正则表达式：Regex"><a href="#正则表达式：Regex" class="headerlink" title="正则表达式：Regex"></a>正则表达式：Regex</h3><p>​		用于校验：”str”.matches(“校验规则”)</p>
<p>​		用于分割：”str”.split(“校验规则”)   按校验规则进行分割</p>
<p>​		用于替换：”str”.replaceAll(“校验规则”,”替换内容”)   将校验规则所对应的字符替换掉</p>
<p>​		用于爬取内容信息：</p>
<p>​				String rs&#x3D;”爬取内容”</p>
<p>​				1.定义爬取规则：String regex&#x3D;””</p>
<p>​				2.编译正则表达式成为匹配对象 Pattern pattern &#x3D;Pattern.compile(regex)</p>
<p>​				3.通过匹配规则对象得到一个匹配数据内容的匹配器对象：</p>
<p>​						Matcher matcher&#x3D;pattern.matcher(rs)</p>
<p>​				4.通过匹配器取出信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">​						<span class="keyword">while</span>(matcher.find())&#123;</span><br><span class="line"></span><br><span class="line">​							System.out.println(matcher.group())</span><br><span class="line"></span><br><span class="line">​						&#125;</span><br></pre></td></tr></table></figure>

<h3 id="泛型："><a href="#泛型：" class="headerlink" title="泛型："></a>泛型：</h3><p>​		作用：在编译阶段约束只能操作指定数据类型</p>
<p>​		自定义：自定义泛型类，自定义泛型方法，自定义泛型接口</p>
<p>​		泛型通配符：</p>
<p>​					？在使用泛型时代表一切类型</p>
<p>​					E,T,K,V是在定义泛型时代表一切类型</p>
<p>​		泛型的上下限：</p>
<p>​					？extends 类 ：说明？必须是此类或者其子类</p>
<p>​					？supper 类 ：说明？必须是此类或者其父类</p>
<p>​		注意：</p>
<p>​				泛型和集合都只支持引用数据类型，不支持基本数据类型</p>
<p>​				泛型没有继承关系</p>
<h3 id="Collection集合："><a href="#Collection集合：" class="headerlink" title="Collection集合："></a>Collection集合：</h3><p>​		体系：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">				   Collection&lt;E&gt;</span><br><span class="line">			/	      		        \</span><br><span class="line">		Set&lt;E&gt;				        List&lt;E&gt;</span><br><span class="line">	/	  \			/             \             \</span><br><span class="line">HashSet&lt;E&gt;	TreeSet&lt;E&gt;		ArrayList&lt;E&gt;  LinkedList&lt;E&gt;  Vector</span><br><span class="line">	/</span><br><span class="line">LinkedHashSet&lt;&gt;</span><br></pre></td></tr></table></figure>

<p>​		Set集合：无序，不重复，无索引</p>
<p>​				– HashSet：无序，不重复，无索引</p>
<p>​						– LinkedHashSet：有序，不重复，无索引</p>
<p>​				– TreeSet：升序排序，不重复，无索引</p>
<p>​		List集合：有序，可重复，有索引</p>
<p>​				– ArrayList：有序，可重复，有索引</p>
<p>​				– LinkedList：有序，可重复，有索引  （可以实现队列与栈）</p>
<p>​				– Vector：线程安全，速度慢</p>
<h3 id="Set："><a href="#Set：" class="headerlink" title="Set："></a>Set：</h3><p>​		怎么判断是否重复？<br>​				让两个对象调用自己的hashCode()方法得到彼此的哈希值进行比较，若不同则不重复，若相同，则继续<br>​				让两个对象进行equals比较内容是否相同，相同则重复<br>​		无序的根本原因：<br>​				因为底层采用了哈希表存储元素</p>
<h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet:"></a>TreeSet:</h3><p>​		对于自定义的引用数据类型：TreeSet默认无法排序</p>
<p>​				解决方案1：实现Comparable类，并重写比较方法compareTo</p>
<p>​				解决方案2：直接为集合设置比较器Comparator对象，重写比较方法</p>
<h3 id="Collections工具类："><a href="#Collections工具类：" class="headerlink" title="Collections工具类："></a>Collections工具类：</h3><p>​		方法：</p>
<p>​				.addAll(被添加元素的集合,可变参数)   </p>
<p>​				.shuffle(要打乱顺序的集合)</p>
<p>​				.sort(要排序的集合)</p>
<h3 id="可变参数："><a href="#可变参数：" class="headerlink" title="可变参数："></a>可变参数：</h3><p>​		作用：可以在形参中接受任意个，可变参数在方法内部本质上就是一个数组</p>
<p>​		格式：类型… name</p>
<p>​		注意：</p>
<p>​				一个形参列表中可变参数只能有一个</p>
<p>​				可变参数必须在形参列表的最后面</p>
<h3 id="遍历："><a href="#遍历：" class="headerlink" title="遍历："></a>遍历：</h3><h4 id="for循环：只适用于有索引的集合"><a href="#for循环：只适用于有索引的集合" class="headerlink" title="for循环：只适用于有索引的集合"></a>for循环：只适用于有索引的集合</h4><h4 id="迭代器："><a href="#迭代器：" class="headerlink" title="迭代器："></a>迭代器：</h4><p>​		创建迭代器对象：集合名称.Iterator()</p>
<p>​		方法：.next()     .hasNext()</p>
<h4 id="foreach"><a href="#foreach" class="headerlink" title="foreach:"></a>foreach:</h4><p>​		格式：for(元素类型 name：集合名称){}</p>
<h4 id="Lamda表达式：（JDK1-8）"><a href="#Lamda表达式：（JDK1-8）" class="headerlink" title="Lamda表达式：（JDK1.8）"></a>Lamda表达式：（JDK1.8）</h4><p>​		格式：集合名称.forEach(s-&gt;{  System.out.println(s);}  )</p>
<p>​				简化：集合名称.forEach(  s-&gt;System.out.println(s)  )</p>
<p>​				再简化：集合名称.forEach(  System.out :: println  )</p>
<h3 id="Map集合："><a href="#Map集合：" class="headerlink" title="Map集合："></a>Map集合：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">		Map&lt;K,V&gt;</span><br><span class="line">	/             \</span><br><span class="line">TreeMap&lt;K,V&gt;      HashMap&lt;K,V&gt;</span><br><span class="line">			\</span><br><span class="line">					LinkedHashMap&lt;K,V&gt;</span><br></pre></td></tr></table></figure>

<p>​		Map：键是无序，不重复，无索引</p>
<p>​				–TreeMap：升序排序，不重复，无索引</p>
<p>​				–HashMap：无序，不重复，无索引</p>
<p>​				–LinkedHashMap：有序，不重复，无索引</p>
<p>​		注意：</p>
<p>​				HashSet集合底层是基于HashMap的</p>
<p>​				TreeSet集合底层是基于TreeMap的</p>
<p>​				浮点型的大小比较：Double.compare(one,two);</p>
<p>​		遍历：</p>
<p>​					“键找值遍历”：先获取Map集合全部的键，再根据键找值</p>
<p>​					“键值对遍历”：.entrySet()将Map集合转Set集合，再遍历</p>
<p>​						获取map集合的元素实体类型：Set&lt;Map.Entry&lt;K,V&gt;&gt; entries&#x3D;maps.entrySet();</p>
<p>​					lamada：</p>
<p>​							maps.foreach({  (k,v) -&gt; {}  })</p>
<h3 id="异常："><a href="#异常：" class="headerlink" title="异常："></a>异常：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	Throwable</span><br><span class="line">	/		\</span><br><span class="line">Error			Exception</span><br><span class="line">				/        \</span><br><span class="line">			编译时异常	 RuntimeException</span><br></pre></td></tr></table></figure>

<p>​		Error：无法处理的错误，系统级错误</p>
<p>​		常见运行时异常：</p>
<p>​				数组索引越界异常</p>
<p>​				空指针异常</p>
<p>​				类型转换异常</p>
<p>​				数学操作异常</p>
<p>​				数字转换异常</p>
<p>​		异常的产生默认的处理过程：</p>
<p>​				1.在出现异常的代码那里自动创建一个异常对象</p>
<p>​				2.异常会从方法，抛给调用者，最终再抛给JVM</p>
<p>​				3.JVM接受到异常对象后，在控制台输出异常栈信息，并结束程序</p>
<p>​		异常处理：最佳处理方案：将异常抛出到最外层，再在最外层用try进行异常处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">​				<span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">​				&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line"></span><br><span class="line">​					e.printStackTrace()</span><br><span class="line"></span><br><span class="line">​				&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"></span><br><span class="line">​				&#125;</span><br></pre></td></tr></table></figure>
<p>​				注意：不建议在finally中写return，因为会覆盖前面所有的return值；</p>
<p>​		抛出异常：</p>
<p>​				throws：用在方法上</p>
<p>​				throw：用在方法体，创建异常类并抛出</p>
<h3 id="多线程："><a href="#多线程：" class="headerlink" title="多线程："></a>多线程：</h3><p>​		进程：</p>
<p>​			特征：动态性，独立性，开发性</p>
<p>​		线程：线程属于进程，一个进程可以有多个线程</p>
<p>​			Thread类的API：</p>
<p>​					设置线程名称：引用.setName()     </p>
<p>​							可以通过创建有参构造器为线程起名字，调用Thread类里的有参构造器</p>
<p>​					获取线程名称：引用.getName()     </p>
<p>​							获取当前所在线程的名称：Thread.currentThread()</p>
<p>​					让当前线程休眠：Thread.sleep()</p>
<p>​					等待线程执行完：引用.join()</p>
<p>​			创建线程：</p>
<p>​					1.定义线程类，继承Thread类，并重写run()    启动：引用.start()</p>
<p>​					2.定义线程任务类，实现Runnable接口，并重写run()，再把线程任务对象包装成线程对象</p>
<p>​							优点：可以继承其他类，用一个线程任务对象可以被包装成多个线程对象</p>
<p>​										适合多个线程去共享同一个资源</p>
<p>​					3.定义线程任务类，实现Callable接口，并重写call()，再把线程任务对象包装成未来任务对象，再把未</p>
<p>​					   来任务对象包装为线程对象</p>
<p>​							优点：具有实现Runnable接口的所有优点，此外，还能直接得到线程执行的结果  .get()</p>
<p>​			线程安全问题：多个线程同时操作同一个共享资源时可能会存在线程安全</p>
<p>​			线程同步：为了解决线程安全</p>
<p>​					三种方式：</p>
<p>​						同步代码块：synchronized(唯一锁对象){共享资源代码}</p>
<p>​								实例方法可以用this作为锁对象，静态方法可以用类名.class作为锁对象</p>
<p>​						同步方法：在方法上加上synchronized关键字</p>
<p>​						lock显示锁(同步锁)：java.util.concurrent.locks.Lock</p>
<p>​								创建同步锁：private final Lock lock&#x3D;new ReentrantLock();</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">lock.lock();<span class="comment">//加锁</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">       共享资源代码</span><br><span class="line">   &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">   &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">       lock.unlock();<span class="comment">//解锁</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>​				线程通信： </p>
<p>​						锁对象.wait() 让当前线程进入等待</p>
<p>​						锁对象.notify() 唤醒当前锁对象上等待状态的某个线程</p>
<p>​						锁对象.wait() 唤醒当前锁对象上等待状态的所有线程</p>
<p>​				线程状态：</p>
<p>​						new、runnable(就绪状态，运行状态)、blocked、timed_waiting、terminated </p>
<p>​			线程池：ExecutorService</p>
<p>​					作用：降低资源消耗、提高响应速度、提高线程的可管理性</p>
<p>​					创建线程池：ExecutorService pools&#x3D;Executors.newFixedThreadPool(线程数量)</p>
<p>​					提交任务：pools.submit(线程任务类的引用)</p>
<p>​					关闭线程池：pools.shutdown()</p>
<p>​			死锁：</p>
<p>​					产生的四个必要条件：</p>
<p>​							1.互斥使用：当资源被占用时，其他线程不能使用</p>
<p>​							2.不可抢占：资源请求者不能强制从资源占有者手中夺取资源</p>
<p>​							3.请求和保持：当资源请求者在请求其他资源的同时保持对原有资源的占有</p>
<p>​							4.循环等待：存在一个等待循环队列</p>
<h3 id="volatile："><a href="#volatile：" class="headerlink" title="volatile："></a>volatile：</h3><p>​		问题：并发编程下，多线程修改共享变量会出现变量修改值后的不可见性</p>
<p>​				原因：每个线程都有自己的工作内存，线程都是从主内存拷贝共享变量的副本值</p>
<p>​							每个线程是在自己的工作内存操作共享变量的</p>
<p>​				解决方案：</p>
<p>​							加锁（加锁会清空工作内存，读取主内存中最新的共享变量）</p>
<p>​							给共享变量加上volatile关键字（一旦有一个线程修改了voaltile修饰的变量，其他线程会更新）</p>
<p>​		java内存模型JMM：JVM规范中定义的一种内存模型，描述了java程序中各种变量的访问规则</p>
<p>​		原子性：指一批操作是一个整体，要么同时成功，要么同时失败，不能被干扰</p>
<p>​						volatile只能保证线程间变量的可见性，但是不能保证变量操作的原子性</p>
<p>​				保证原子性方案：</p>
<p>​							加锁</p>
<p>​							使用原子类</p>
<h3 id="原子类：Atomic"><a href="#原子类：Atomic" class="headerlink" title="原子类：Atomic"></a>原子类：Atomic</h3><p>​			原子类：java.util.concurrent.atomic，性能高效，线程安全，可以保证原子性			</p>
<p>​			原理：CAS机制（先比较再交换）</p>
<p>​			乐观锁与悲观锁： CAS，总是假设最好的情况被称为乐观锁</p>
<p>​											Synchronized，总是假设最坏情况被称为悲观锁</p>
<h3 id="并发包："><a href="#并发包：" class="headerlink" title="并发包："></a>并发包：</h3><p>​			ConcurrentHashMap：线程安全，效率高，性能好，最新最好用的线程安全的Map集合</p>
<p>​					对比：</p>
<p>​							HashMap：线程不安全，性能好</p>
<p>​							HashTable：线程安全，性能较差，被淘汰</p>
<p>​					高效的原因：CAS机制+局部锁定(分段式锁)</p>
<p>​			CountDownLatch：可以控制一个或多个线程等待其他线程执行完，再执行自己</p>
<p>​						构造器：CountDownLatch(int count)  初始化唤醒需要countDown几步</p>
<p>​						方法：await() 让当前线程等待</p>
<p>​									countDown()   计数器减一</p>
<p>​			CyclicBarrier循环屏障：某个线程任务必须等待其他线程执行完毕以后才能最终触发自己执行</p>
<p>​						作用：可以实现多线程中，某个任务在等待其他线程执行完后触发</p>
<p>​						构造器：CyclicBarrier(int parties,Runnable barrierAction)  在线程到达屏障时，优先执行任务</p>
<p>​						方法：await() 回收当前线程</p>
<p>​			Semaphore信号量：控制访问特定资源的线程数目</p>
<p>​						作用：控制线程并发占锁的数量</p>
<p>​						构造器：Semaphore(int permits)  permits表示许可线程的数量</p>
<p>​								Semaphore(int permits,boolean fair)  fair表示公平性，若为true,下次执行的线程会等待最久</p>
<p>​						方法：acquire() 获取许可</p>
<p>​									release() 释放许可</p>
<p>​			Exchanger交换者：进行线程间的数据交换,一个线程如果等不到对方的数据交换就会一致等待</p>
<p>​						构造器：Exchanger()  </p>
<p>​						方法：exchang() 交换 ，可以设置等待时间</p>
<h3 id="Lambda表达式："><a href="#Lambda表达式：" class="headerlink" title="Lambda表达式："></a>Lambda表达式：</h3><p>​			使用前提：</p>
<p>​						lambda表达式只能简化接口中只有一个抽象方法的匿名内部类形式</p>
<p>​						一旦某个接口加上了@FunctionalInterface注解，则可以使用lambda简化</p>
<p>​			省略写法：方法体只有一行时，可省略大括号以及分号（return语句，还需要省略return）</p>
<p>​							   参数类型可以省略，若只有一个参数，还可以省略()</p>
<h3 id="方法引用："><a href="#方法引用：" class="headerlink" title="方法引用："></a>方法引用：</h3><p>​			作用：可以进一步简化lambda表达式</p>
<p>​			格式：</p>
<p>​						类型或者对象::引用的方法</p>
<p>​						类::静态方法   (o1,o2)-&gt;类.静态方法(o1,o2);  简化为：类::静态方法</p>
<p>​						特定类型::方法  </p>
<p>​						类型::new    String[]::new 转换为数组类型</p>
<p>​			例子1：lists.forEach(s-&gt;System.out.println(s));</p>
<p>​						简化为：lists.forEach(System.out::println);</p>
<h3 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流:"></a>Stream流:</h3><p>​			作用：用来简化集合类库或者数组API的弊端</p>
<p>​			格式：lists.stream().filter(s-&gt;{}).forEach()…</p>
<p>​			获取流：</p>
<p>​					Collection集合：集合.stream()</p>
<p>​					Map集合：集合.keySet().stream()  或  集合.values().stream() 或 集合.entrySet().stream()</p>
<p>​					数组：Arrays.stream(数组名)  或  Stream.of(数组名)</p>
<p>​			常用API：</p>
<p>​					forEach() 遍历      count()计数  </p>
<p>​					filter()过滤             limit() 取前几个元素</p>
<p>​					skip()跳过前几个    map()加工方法</p>
<p>​					concat()  合并两个流</p>
<p>​			终结方法与非终结方法：</p>
<p>​					终结方法有：forEach()  count()</p>
<p>​					非终结方法：除上面之外的其他方法</p>
<p>​			收集流：把流的数据转回到集合中</p>
<p>​					转换为Set集合：流.collect(Collectors.toSet())</p>
<p>​					转换为List集合：流.collect(Collectors.toList())</p>
<p>​					转换为数组：流.toArray()</p>
<h3 id="File类："><a href="#File类：" class="headerlink" title="File类："></a>File类：</h3><p>​		创建文件对象：</p>
<p>​				使用绝对路径：</p>
<p>​					File f1&#x3D;new File(“D:&#x2F;a.jpg”)</p>
<p>​					路径分隔符： &#x2F;  或者 \ \ 或者  File.separator</p>
<p>​				使用相对路径：从当前工程寻找</p>
<p>​					File f2&#x3D;new File(“文件对象&#x2F;文件夹对象”)</p>
<p>​		常见API：</p>
<p>​				.getAbsolutePath()    获取相对路径</p>
<p>​				.getPath()   获取定义时的路径</p>
<p>​				.getName()  获取文件的名称</p>
<p>​				.length()  获取文件大小(字节数)</p>
<p>​				.exists()  判断文件路径是否存在</p>
<p>​				.isFile()  判断文件对象是否是文件</p>
<p>​				.isDirectory()  判断文件对象是否是文件夹</p>
<p>​				.delete()  删除文件或空文件夹</p>
<p>​				.mkdirs()  创建多级文件夹</p>
<p>​			目录遍历</p>
<p>​					dir1.list()</p>
<p>​					dir1.listFiles()  获取当前目录对象的全部一级文件对象</p>
<p>​					f1.lastModified()  最后修改时间</p>
<p>​			递归搜索文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">searchFiles</span><span class="params">(File dir,String fileName)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dir.exists()&amp;&amp;dir.isDirectory())&#123;</span><br><span class="line">        File[] files=dir.listFiles();</span><br><span class="line">        <span class="keyword">if</span>(files!=<span class="literal">null</span>&amp;&amp;files.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(File f:files)&#123;</span><br><span class="line">                <span class="keyword">if</span>(f.isFile())&#123;</span><br><span class="line">                    <span class="keyword">if</span>(f.getName().contains(fileName))&#123;</span><br><span class="line">                        System.out.println(f.getAbsolutePath());</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        searchFiles(f,fileName);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="I-x2F-O流："><a href="#I-x2F-O流：" class="headerlink" title="I&#x2F;O流："></a>I&#x2F;O流：</h3><p>​		分类：输入流，输出流（以内存为基准，读到内存是输入流，从内存写入磁盘是输出流）</p>
<p>​		字节输入流：InputStream</p>
<p>​		字节输出流：OutputStream</p>
<p>​		字符输入流：Reader	</p>
<p>​		字符输出流：Writer</p>
<h3 id="文件流："><a href="#文件流：" class="headerlink" title="文件流："></a>文件流：</h3><p>​		FileInputStream：</p>
<p>​					创建字节输入流：new FileInputStream(“文件路径”)</p>
<p>​					.read() 读一个字节，若读不到就返回-1   注意：读中文时必会乱码，因为会截断中文字节</p>
<p>​					.read(byte[] buffer)读一个字节数组，若读不到就返回-1  注意：读中文时可能会乱码		</p>
<p>​		FileOutputStream：	</p>
<p>​					创建字节输出流：new FileOutputStream(“文件路径”)  每次创建都会清空文件</p>
<p>​					.write() 输出一个字节</p>
<p>​					.write(byte[] buffer)读一个字节数组</p>
<p>​						换行：os.write(“\r\n”.getBytes())</p>
<p>​		文件复制：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStream is=<span class="literal">null</span>;</span><br><span class="line">OutputStream os=<span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    is=<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line">    os=<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line">    <span class="type">byte</span>[] buffer=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="keyword">while</span>((len=is.read(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">        os.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;复制成功&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(is!=<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            is.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    		e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(os!=<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">           os.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    		e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		FileReader：</p>
<p>​					创建文件字符输入流：new FileReader(“path”);</p>
<p>​					.read() 读一个字符，返回该字符的编码，若读不到就返回-1</p>
<p>​					.read(char[] buffer)读一个字节数组</p>
<p>​		FileWriter：</p>
<p>​					创建文件字符输出流：new FileWriter(“path”);</p>
<p>​					.write() 输出一个字符</p>
<p>​					.write(char[] buffer) 输出一个字节数组</p>
<h3 id="缓冲流："><a href="#缓冲流：" class="headerlink" title="缓冲流："></a>缓冲流：</h3><p>​		BudderedInputStream：</p>
<p>​				将一个文件字节输入流包装成缓冲字节输入流：new BudderedInputStream(文件字节输入流);</p>
<p>​				原理：缓冲字节输入流自带8KB的缓冲池</p>
<p>​		BudderedOutputStream：</p>
<p>​				将一个文件字节输出流包装成缓冲字节输入流：new BudderedOutputStream(文件字节输出流)  </p>
<p>​		BudderedReader：</p>
<p>​					创建缓冲字符输入流：new BudderedReader(Reader reader);</p>
<p>​					.read() 读一个字符，返回该字符的机器码，若读不到就返回-1</p>
<p>​					.read(char[] buffer)读一个字节数组</p>
<p>​					.readLine() 读一行，返回字符串</p>
<p>​			读文本文件标准代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Reader fr=<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line">BudderedReader br=<span class="keyword">new</span> <span class="title class_">BudderedReader</span>(fr);</span><br><span class="line">String line;</span><br><span class="line"><span class="keyword">while</span>((line=br.readLine())!=<span class="literal">null</span>)&#123;</span><br><span class="line">    System.out.println(line);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		BudderedWriter：</p>
<p>​					创建缓冲字符输出流：new FileWriter(“path”);</p>
<p>​					.write() 输出一个字符</p>
<p>​					.write(char[] buffer) 输出一个字节数组</p>
<p>​					.newLine() 换行</p>
<p>​		字符输入转换流：InputStreamReader</p>
<p>​			作用：解决字符流读取不同编码乱码的问题，将字节流转换为字符流</p>
<p>​			new InputStreamReader(文件字节输入流,”编码格式”);</p>
<p>​		字符输出转换流：OutputStreamwriter</p>
<p>​			作用：指定编码将字节输出流转换成字符输出流</p>
<p>​			new OutputStreamwriter(字节输出流,”编码格式”);</p>
<h3 id="序列化：ObjectOutputStream-x2F-ObjectInputStream"><a href="#序列化：ObjectOutputStream-x2F-ObjectInputStream" class="headerlink" title="序列化：ObjectOutputStream&#x2F;ObjectInputStream"></a>序列化：ObjectOutputStream&#x2F;ObjectInputStream</h3><p>​		序列化：	   对象字节输出流：ObjectOutputStream</p>
<p>​				将一个文件字节输出流包装成对象字节输出流：new ObjectOutputStream(文件字节输出流);</p>
<p>​				将对象序列化：.writeObject(对象)</p>
<p>​				注意：对象如果想参与序列化，对象必须实现序列化接口Serializable</p>
<p>​							成员变量前使用treanient修饰，将不参与序列化</p>
<p>​		反序列化：	对象字节输入流：ObjectInputStream</p>
<p>​				将一个文件字节输入流包装成对象字节输入流：new ObjectInputStream(文件字节输出流);</p>
<p>​				将对象序列化：.readObject(对象)</p>
<p>​		序列化版本号：</p>
<p>​				加入序列版本号：private static final long serialVersionUID&#x3D;1L</p>
<h3 id="打印流：PrintStream-x2F-PrintWriter"><a href="#打印流：PrintStream-x2F-PrintWriter" class="headerlink" title="打印流：PrintStream&#x2F;PrintWriter"></a>打印流：PrintStream&#x2F;PrintWriter</h3><p>​		作用：方便高效的打印各种数据</p>
<p>​		创建打印流：new PrintStream(“path”);</p>
<p>​		改变输出流向：System.setOut(打印流对象)</p>
<h3 id="网络编程："><a href="#网络编程：" class="headerlink" title="网络编程："></a>网络编程：</h3><h4 id="InetAddress类"><a href="#InetAddress类" class="headerlink" title="InetAddress类"></a>InetAddress类</h4><p>​				方法：.getHostHame()域名    .getHostAddress()地址</p>
<h4 id="UDP通信："><a href="#UDP通信：" class="headerlink" title="UDP通信："></a>UDP通信：</h4><p>​				DatagramPacket数据包对象：用来封装要发送或接收的数据包</p>
<p>​						构造器：</p>
<p>​									发送端：DatagramPacket(byte[] buf,int length,InetAddress address,int port)</p>
<p>​									接收端：DatagramPacket(byte[] buf,int length)</p>
<p>​						方法：</p>
<p>​									.getLength()</p>
<p>​				DatagramSocket发送对象：用来发送或接收数据包</p>
<p>​						构造器：</p>
<p>​									DatagramSocket()</p>
<p>​									DatagramPacket(int port)</p>
<p>​						方法：</p>
<p>​									.send()发送数据包  .receive()接收数据包</p>
<h4 id="TCP通信："><a href="#TCP通信：" class="headerlink" title="TCP通信："></a>TCP通信：</h4><p>​				模拟通信：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">服务端：</span><br><span class="line">    ServerSocket ss=<span class="keyword">new</span> <span class="title class_">ServerSocket</span>(端口);</span><br><span class="line">	Socket socket=ss.accept();</span><br><span class="line">	InputStream is=socket.getInputStream();</span><br><span class="line">	Reader isr=<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(is);</span><br><span class="line">	BufferedReader br=<span class="keyword">new</span> <span class="title class_">BufferedReader</span>(isr);</span><br><span class="line">	String msg;</span><br><span class="line">	<span class="keyword">if</span>((msg=br.readLine())!=<span class="literal">null</span>)&#123;</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">    &#125;</span><br><span class="line">客户端：</span><br><span class="line">    Socket socket=<span class="keyword">new</span> <span class="title class_">Socket</span>(ip，端口);</span><br><span class="line">    OutputStream os=socket.getOutputStream();</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        Scanner sc=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.print(<span class="string">&quot;请说：&quot;</span>);</span><br><span class="line">        ps.println(sc.nextLine());</span><br><span class="line">        ps.flush();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​				图片上传：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">服务端：</span><br><span class="line">   	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEDT_File=<span class="string">&quot;服务器文件路径&quot;</span>;</span><br><span class="line">    ServerSocket ss=<span class="keyword">new</span> <span class="title class_">ServerSocket</span>(端口);</span><br><span class="line">	Socket socket=ss.accept();</span><br><span class="line">	InputStream is=socket.getInputStream();</span><br><span class="line">	BufferedInputStream bis=<span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(DEDT_File+UUID.randomUUID().toString()+<span class="string">&quot;.jpg&quot;</span>));</span><br><span class="line">	<span class="type">byte</span>[] buffer=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="keyword">while</span>((len=bis.rea(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">        bos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">    &#125;</span><br><span class="line">	bos.flush();</span><br><span class="line">    bis.close();</span><br><span class="line">	PrintStream ps=<span class="keyword">new</span> <span class="title class_">PrintStream</span>(socket.getOutputStream());</span><br><span class="line">	ps.println(<span class="string">&quot;收到&quot;</span>);</span><br><span class="line">	ps.flush();</span><br><span class="line">客户端：</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SRC_IMAGE=<span class="string">&quot;本地图片路径&quot;</span>;</span><br><span class="line">    Socket socket=<span class="keyword">new</span> <span class="title class_">Socket</span>(ip，端口);</span><br><span class="line">    OutputStream os=socket.getOutputStream();</span><br><span class="line">    BufferedOutputStream bos=<span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(os);</span><br><span class="line">    BufferedInputStream bis=<span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(SRC_IMAGE));</span><br><span class="line">    <span class="type">byte</span>[] buffer=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="keyword">while</span>((len=bis.rea(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">        bos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">    &#125;</span><br><span class="line">    bos.flush();</span><br><span class="line">    bis.close();</span><br><span class="line">	socket.shutdownOutput();</span><br><span class="line">    BufferedReader br=<span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(socket.getInputStream()));</span><br><span class="line">    System.out.println(br.readLine());</span><br></pre></td></tr></table></figure>

<h4 id="通信模型："><a href="#通信模型：" class="headerlink" title="通信模型："></a>通信模型：</h4><p>​					BIO通信模式：同步阻塞式通信，性能极差，大量线程，大量阻塞</p>
<p>​					伪异步通信：引入线程池</p>
<p>​					NIO通信模式：同步非阻塞，轮询所有客户端，有数据才开启线程来处理</p>
<p>​					AIO通信模式：异步非阻塞，io通信交给操作系统</p>
<h3 id="单元测试："><a href="#单元测试：" class="headerlink" title="单元测试："></a>单元测试：</h3><p>​		测试方法的要求：</p>
<p>​			1.必须public修饰  2.没有返回值没有参数  3.必须使用@Test注解</p>
<p>​			@Test</p>
<p>​			public void XXXTest(){}</p>
<h3 id="反射："><a href="#反射：" class="headerlink" title="反射："></a>反射：</h3><p>​		作用：做高级框架，能设计一些通用技术功能</p>
<p>​		关键：编译以后的class文件对象，反射是工作在运行时的技术，反射工作在运行阶段</p>
<p>​		获取类对象：1.类名.class：Class&lt;?&gt; c1&#x3D;Student.class;</p>
<p>​								2.对象.getClass()</p>
<p>​								3.Class.forName(“类的全限定名”)</p>
<p>​		获取构造器：1.类对象.getDeclaredConstructors();全部构造器</p>
<p>​								2.类对象.getConstructor();某个构造器，只能是public的</p>
<p>​								3.类对象.getDeclaredConstructor();某个构造器</p>
<p>​				API： 创建实例：.newInstance();</p>
<p>​							暴力打开私有构造器的访问：.setAccessible(true)</p>
<p>​		获取成员变量：1.类对象.getDeclaredFields();全部成员变量</p>
<p>​									2.类对象.getDeclaredField();某个成员变量</p>
<p>​				API：.set(被赋值的对象,value) 给对象注入某个成员变量数据</p>
<p>​						  .get(对象)获取对象的值</p>
<p>​		获取方法：1.类对象.getDeclaredMethods()所有方法</p>
<p>​							2.类对象.getDeclaredMethod(String name)某个方法</p>
<p>​				API：.invoke(方法对象)触发方法对象</p>
<h3 id="注解："><a href="#注解：" class="headerlink" title="注解："></a>注解：</h3><p>​		自定义注解： </p>
<p>​				修饰符 @interface 注解名{</p>
<p>​						类型 属性名();</p>
<p>​				}</p>
<p>​		元注解：</p>
<p>​				@Target()注解可以使用的位置</p>
<p>​				@Retention注解的生命周期</p>
<p>​		</p>
<h3 id="动态代理："><a href="#动态代理：" class="headerlink" title="动态代理："></a>动态代理：</h3><h3 id="算法："><a href="#算法：" class="headerlink" title="算法："></a>算法：</h3><p>​		冒泡排序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] bubbleSort(<span class="type">int</span>[] arr)&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;arr.length-i-<span class="number">1</span>;j++)&#123;</span><br><span class="line">               <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                   <span class="type">int</span> temp=arr[j+<span class="number">1</span>];</span><br><span class="line">                   arr[j+<span class="number">1</span>]=arr[j];</span><br><span class="line">                   arr[j]=temp;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; </span><br><span class="line">       <span class="keyword">return</span> arr;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>​		选择排序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] selectSort(<span class="type">int</span>[] arr)&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;arr.length-<span class="number">1</span>;j++)&#123;</span><br><span class="line">               <span class="keyword">if</span>(arr[j]&lt;arr[i])&#123;</span><br><span class="line">                   <span class="type">int</span> temp=arr[i];</span><br><span class="line">                   arr[i]=arr[j];</span><br><span class="line">                   arr[j]=temp;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; </span><br><span class="line">       <span class="keyword">return</span> arr;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>​		二分查找：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySerach</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> num)</span>&#123;</span><br><span class="line">       <span class="type">int</span> left=<span class="number">0</span>;</span><br><span class="line">       <span class="type">int</span> right=arr.length-<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span>(left&lt;=end)&#123;</span><br><span class="line">           <span class="type">int</span> index=(left+right)/<span class="number">2</span>;</span><br><span class="line">       	<span class="keyword">if</span>(num&lt;arr[index])&#123;</span><br><span class="line">           	right=index-<span class="number">1</span>;</span><br><span class="line">       	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(num&gt;arr[index])&#123;</span><br><span class="line">           	left=index+<span class="number">1</span>;</span><br><span class="line">       	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(num=arr[index])&#123;</span><br><span class="line">               <span class="keyword">return</span> index;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="数据结构："><a href="#数据结构：" class="headerlink" title="数据结构："></a>数据结构：</h3><p>​		二叉排序树：</p>
<p>​				优点：查找和增删都很优秀</p>
<p>​				缺点：“瘸子现象” 只有左节点或右节点</p>
<p>​		平衡二叉树：</p>
<p>​				规定：左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一颗平衡二叉树</p>
<p>​				调整平衡：左高往右提，右高往左提，不行就换方向提</p>
<p>​		红黑树：另一种算法规则的平衡二叉树</p>
<h3 id="设计模式："><a href="#设计模式：" class="headerlink" title="设计模式："></a>设计模式：</h3><p>​		1.模板设计模式：</p>
<p>​					作用：优化代码架构，提高代码的复用性，可以做到部分实现，部分抽象，抽象的东西交给使用</p>
<p>​								模板的子类重写实现</p>
<p>​		2.单例设计模式：</p>
<p>​					单例：指一个类只存在一个对象</p>
<p>​					单例的实现方式：（8种）</p>
<p>​							(1) 饿汉单例设计模式：通过类获取单例对象时，对象已经准备好了</p>
<p>​									实现步骤：</p>
<p>​											1.将构造器私有</p>
<p>​											2.定义静态成员变量存储一个对象</p>
<p>​											3.定义一个方法返回单例对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingleIntance</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingleIntance ins=<span class="keyword">new</span> <span class="title class_">SingleIntance</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingleIntance</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingleIntance <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ins</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​							(2) 懒汉单例设计模式：通过类获取单例对象时，才去创建对象</p>
<p>​									实现步骤：</p>
<p>​											1.将构造器私有</p>
<p>​											2.定义静态成员变量</p>
<p>​											3.定义一个方法返回单例对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingleIntance</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingleIntance ins;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingleIntance</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingleIntance <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ins==<span class="literal">null</span>)&#123;ins = <span class="keyword">new</span> <span class="title class_">SingleIntance</span>();&#125;</span><br><span class="line">        <span class="keyword">return</span> ins</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​				3.工厂模式：可以实现类与类之间的解耦	</p>
<p>​				4.装饰模式：不改变原类，不使用继承，动态扩展一个类的功能</p>
<hr>
<p>😆END</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>语言</category>
      </categories>
      <tags>
        <tag>java笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB入门</title>
    <url>/posts/661780e7.html</url>
    <content><![CDATA[<h3 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h3><h4 id="1-分布式计算的优点："><a href="#1-分布式计算的优点：" class="headerlink" title="1.分布式计算的优点："></a>1.分布式计算的优点：</h4><p>可靠性（容错） ：<br>分布式计算系统中的一个重要的优点是可靠性。一台服务器的系统崩溃并不影响到其余的服务器。<br>可扩展性：<br>在分布式计算系统可以根据需要增加更多的机器。<br>资源共享：<br>共享数据是必不可少的应用，如银行，预订系统。<br>灵活性：<br>由于该系统是非常灵活的，它很容易安装，实施和调试新的服务。<br>更快的速度：<br>分布式计算系统可以有多台计算机的计算能力，使得它比其他系统有更快的处理速度。<br>开放系统：<br>由于它是开放的系统，本地或者远程都可以访问到该服务。<br>更高的性能：<br>相较于集中式计算机网络集群可以提供更高的性能（及更好的性价比）。</p>
<h4 id="2-分布式计算的缺点："><a href="#2-分布式计算的缺点：" class="headerlink" title="2.分布式计算的缺点："></a>2.分布式计算的缺点：</h4><p>故障排除：<br>故障排除和诊断问题。<br>软件：<br>更少的软件支持是分布式计算系统的主要缺点。<br>网络：<br>网络基础设施的问题，包括：传输问题，高负载，信息丢失等。<br>安全性：<br>开放系统的特性让分布式计算系统存在着数据的安全性和共享的风险等问题。</p>
<h3 id="NoSQL简介"><a href="#NoSQL简介" class="headerlink" title="NoSQL简介"></a>NoSQL简介</h3><h4 id="1-定义："><a href="#1-定义：" class="headerlink" title="1.定义："></a>1.定义：</h4><p>NoSQL(NoSQL &#x3D; Not Only SQL )，意即”不仅仅是SQL”。</p>
<h4 id="2-什么是NoSQL"><a href="#2-什么是NoSQL" class="headerlink" title="2.什么是NoSQL?"></a>2.什么是NoSQL?</h4><p>NoSQL，指的是非关系型的数据库。NoSQL有时也称作Not Only SQL的缩写，是对不同于传统的关系型数据库的数据库管理系统的统称。<br>NoSQL用于超大规模数据的存储。（例如谷歌或Facebook每天为他们的用户收集万亿比特的数据）。这些类型的数据存储不需要固定的模式，无需多余操作就可以横向扩展。</p>
<h4 id="3-为什么使用NoSQL"><a href="#3-为什么使用NoSQL" class="headerlink" title="3.为什么使用NoSQL ?"></a>3.为什么使用NoSQL ?</h4><p>今天我们可以通过第三方平台（如：Google,Facebook等）可以很容易的访问和抓取数据。用户的个人信息，社交网络，地理位置，用户生成的数据和用户操作日志已经成倍的增加。我们如果要对这些用户数据进行挖掘，那SQL数据库已经不适合这些应用了, NoSQL 数据库的发展却能很好的处理这些大的数据。</p>
<h4 id="4-RDBMS-vs-NoSQL"><a href="#4-RDBMS-vs-NoSQL" class="headerlink" title="4.RDBMS vs NoSQL"></a>4.RDBMS vs NoSQL</h4><p>RDBMS<br>-高度组织化结构化数据<br>-结构化查询语言（SQL） (SQL)<br>-数据和关系都存储在单独的表中。<br>-数据操纵语言，数据定义语言<br>-严格的一致性<br>-基础事务<br>NoSQL<br>-代表着不仅仅是SQL<br>-没有声明性查询语言<br>-没有预定义的模式<br>-键-值对存储，列存储，文档存储，图形数据库<br>-最终一致性，而非ACID属性<br>-非结构化和不可预知的数据<br>-CAP定理<br>-高性能，高可用性和可伸缩性</p>
<h4 id="5-NoSQL的优点-x2F-缺点"><a href="#5-NoSQL的优点-x2F-缺点" class="headerlink" title="5.NoSQL的优点&#x2F;缺点"></a>5.NoSQL的优点&#x2F;缺点</h4><p>优点:<br>-高可扩展性<br>-分布式计算<br>-低成本<br>-架构的灵活性，半结构化数据<br>-没有复杂的关系<br>缺点:<br>-没有标准化<br>-有限的查询功能（到目前为止）<br>-最终一致是不直观的程序</p>
<h4 id="6-BASE"><a href="#6-BASE" class="headerlink" title="6.BASE"></a>6.BASE</h4><p>BASE：Basically Available, Soft-state, Eventually Consistent。 由 Eric Brewer 定义。<br>CAP理论的核心是：一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求，最多只能同时较好的满足两个。<br>BASE是NoSQL数据库通常对可用性及一致性的弱要求原则:<br>Basically Available –基本可用<br>Soft-state –软状态&#x2F;柔性事务。 “Soft state” 可以理解为”无连接”的, 而 “Hard state” 是”面向连接”的<br>Eventually Consistency – 最终一致性， 也是 ACID 的最终目的。</p>
<h3 id="MongoDB简介"><a href="#MongoDB简介" class="headerlink" title="MongoDB简介"></a>MongoDB简介</h3><h4 id="1-概念："><a href="#1-概念：" class="headerlink" title="1.概念："></a>1.概念：</h4><p>MongoDB 是由C++语言编写的，是一个基于分布式文件存储的开源数据库系统。<br>在高负载的情况下，添加更多的节点，可以保证服务器性能。<br>MongoDB 旨在为WEB应用提供可扩展的高性能数据存储解决方案。<br>MongoDB 将数据存储为一个文档，数据结构由键值(key&#x3D;&gt;value)对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。</p>
<h4 id="2-主要特点"><a href="#2-主要特点" class="headerlink" title="2.主要特点"></a>2.主要特点</h4><p>MongoDB 是一个面向文档存储的数据库，操作起来比较简单和容易。<br>你可以在MongoDB记录中设置任何属性的索引 (如：FirstName&#x3D;”Sameer”,Address&#x3D;”8 Gandhi Road”)来实现更快的排序。<br>你可以通过本地或者网络创建数据镜像，这使得MongoDB有更强的扩展性。<br>如果负载的增加（需要更多的存储空间和更强的处理能力） ，它可以分布在计算机网络中的其他节点上这就是所谓的分片。<br>Mongo支持丰富的查询表达式。查询指令使用JSON形式的标记，可轻易查询文档中内嵌的对象及数组。<br>MongoDb 使用update()命令可以实现替换完成的文档（数据）或者一些指定的数据字段 。<br>Mongodb中的Map&#x2F;reduce主要是用来对数据进行批量处理和聚合操作。<br>Map和Reduce。Map函数调用emit(key,value)遍历集合中所有的记录，将key与value传给Reduce函数进行处理。<br>Map函数和Reduce函数是使用Javascript编写的，并可以通过db.runCommand或mapreduce命令来执行MapReduce操作。<br>GridFS是MongoDB中的一个内置功能，可以用于存放大量小文件。<br>MongoDB允许在服务端执行脚本，可以用Javascript编写某个函数，直接在服务端执行，也可以把函数的定义存储在服务端，下次直接调用即可。<br>MongoDB支持各种编程语言:RUBY，PYTHON，JAVA，C++，PHP，C#等多种语言。<br>MongoDB安装简单。</p>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p>显示所有数据的列表：show dbs<br>显示当前数据库对象或集合：db<br>连接到一个指定的数据库：use 库名 </p>
<h3 id="常见概念"><a href="#常见概念" class="headerlink" title="常见概念"></a>常见概念</h3><h4 id="1-数据库命名规则"><a href="#1-数据库命名规则" class="headerlink" title="1.数据库命名规则"></a>1.数据库命名规则</h4><p>不能是空字符串（””)。<br>不得含有’ ‘（空格)、.、$、&#x2F;、\和\0 (空字符)。<br>应全部小写。<br>最多64字节。</p>
<h4 id="2-RDBMS-与-MongoDB-对应的术语"><a href="#2-RDBMS-与-MongoDB-对应的术语" class="headerlink" title="2.RDBMS 与 MongoDB 对应的术语"></a>2.RDBMS 与 MongoDB 对应的术语</h4><p>数据库	数据库<br>表格	集合<br>行	文档<br>列	字段<br>表联合	嵌入文档<br>主键	主键 (MongoDB 提供了 key 为 _id )</p>
<h4 id="3-文档键命名规则"><a href="#3-文档键命名规则" class="headerlink" title="3.文档键命名规则"></a>3.文档键命名规则</h4><p>键不能含有\0 (空字符)。这个字符用来表示键的结尾。<br>.和$有特别的意义，只有在特定环境下才能使用。<br>以下划线”_”开头的键是保留的(不是严格要求的)。<br>注：<br>文档中的键&#x2F;值对是有序的。<br>文档中的值不仅可以是在双引号里面的字符串，还可以是其他几种数据类型（甚至可以是整个嵌入的文档)。<br>MongoDB区分类型和大小写。<br>MongoDB的文档不能有重复的键。<br>文档的键是字符串。除了少数例外情况，键可以使用任意UTF-8字符。</p>
<h4 id="4-集合命名规则"><a href="#4-集合命名规则" class="headerlink" title="4.集合命名规则"></a>4.集合命名规则</h4><p>集合名不能是空字符串””。<br>集合名不能含有\0字符（空字符)，这个字符表示集合名的结尾。<br>集合名不能以”system.”开头，这是为系统集合保留的前缀。<br>用户创建的集合名字不能含有保留字符。有些驱动程序的确支持在集合名里面包含，这是因为某些系统生成的集合中包含该字符。除非你要访问这种系统创建的集合，否则千万不要在名字里出现$。　</p>
<h4 id="5-MongoDB-数据类型"><a href="#5-MongoDB-数据类型" class="headerlink" title="5.MongoDB 数据类型"></a>5.MongoDB 数据类型</h4><p>String	字符串。存储数据常用的数据类型。在 MongoDB 中，UTF-8 编码的字符串才是合法的。<br>Integer	整型数值。用于存储数值。根据你所采用的服务器，可分为 32 位或 64 位。<br>Boolean	布尔值。用于存储布尔值（真&#x2F;假）。<br>Double	双精度浮点值。用于存储浮点值。<br>Min&#x2F;Max keys	将一个值与 BSON（二进制的 JSON）元素的最低值和最高值相对比。<br>Array	用于将数组或列表或多个值存储为一个键。<br>Timestamp	时间戳。记录文档修改或添加的具体时间。<br>Object	用于内嵌文档。<br>Null	用于创建空值。<br>Symbol	符号。该数据类型基本上等同于字符串类型，但不同的是，它一般用于采用特殊符号类型的语言。<br>Date	日期时间。用 UNIX 时间格式来存储当前日期或时间。你可以指定自己的日期时间：创建 Date 对象，传入年月日信息。<br>Object ID	对象 ID。用于创建文档的 ID。<br>Binary Data	二进制数据。用于存储二进制数据。<br>Code	代码类型。用于在文档中存储 JavaScript 代码。<br>Regular expression	正则表达式类型。用于存储正则表达式。</p>
<h4 id="6-元数据"><a href="#6-元数据" class="headerlink" title="6.元数据"></a>6.元数据</h4><p>数据库的信息是存储在集合中，它们使用了系统的命名空间：dbname.system.*</p>
<h3 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h3><blockquote>
<p>创建数据库：use DATABASE_NAME</p>
<blockquote>
<p>注：在 MongoDB 中，集合只有在内容插入后才会创建! 就是说，创建集合(数据表)后要再插入一个文档(记录)，集合才会真正创建。</p>
</blockquote>
</blockquote>
<blockquote>
<p>查看所有数据库：show dbs<br>删除数据库：db.dropDatabase()</p>
</blockquote>
<h3 id="集合操作"><a href="#集合操作" class="headerlink" title="集合操作"></a>集合操作</h3><blockquote>
<p>创建集合：db.createCollection(“name”, {options}) </p>
<blockquote>
<p>options: capped	autoIndexId	 size	max	</p>
</blockquote>
</blockquote>
<blockquote>
<p>查看当前集合：show collections 或  show tables<br>删除集合：db.collection.drop()</p>
</blockquote>
<p>注：在 MongoDB 中，你不需要创建集合。当你插入一些文档时，MongoDB 会自动创建集合。</p>
<h3 id="文档操作"><a href="#文档操作" class="headerlink" title="文档操作"></a>文档操作</h3><h4 id="1-插入文档："><a href="#1-插入文档：" class="headerlink" title="1.插入文档："></a>1.插入文档：</h4><blockquote>
<p>方式一：db.COLLECTION_NAME.insert(document)<br>方式二：db.COLLECTION_NAME.save(document)</p>
</blockquote>
<p>save()：如果 _id 主键存在则更新数据，如果不存在就插入数据。该方法新版本中已废弃，可以使用 db.collection.insertOne() 或 db.collection.replaceOne() 来代替。<br>insert(): 若插入的数据主键已经存在，则会抛 org.springframework.dao.DuplicateKeyException 异常，提示主键重复，不保存当前数据。<br>3.2 版本之后：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方式三：</span><br><span class="line">db.collection.insertOne(</span><br><span class="line">   &lt;document&gt;,</span><br><span class="line">   &#123;</span><br><span class="line">      writeConcern: &lt;document&gt;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br><span class="line">方式四：</span><br><span class="line">db.collection.insertMany(</span><br><span class="line">   [ &lt;document 1&gt; , &lt;document 2&gt;, ... ],</span><br><span class="line">   &#123;</span><br><span class="line">      writeConcern: &lt;document&gt;,</span><br><span class="line">      ordered: &lt;boolean&gt;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h4 id="2-更新文档"><a href="#2-更新文档" class="headerlink" title="2.更新文档"></a>2.更新文档</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方式一：</span><br><span class="line">db.collection.update(</span><br><span class="line">   &lt;query&gt;,</span><br><span class="line">   &lt;update&gt;,</span><br><span class="line">   &#123;</span><br><span class="line">     upsert: &lt;boolean&gt;,</span><br><span class="line">     multi: &lt;boolean&gt;,</span><br><span class="line">     writeConcern: &lt;document&gt;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>参数说明：<br>query : update的查询条件，类似sql update查询内where后面的。<br>update : update的对象和一些更新的操作符（如$,$inc…）等，也可以理解为sql update查询内set后面的<br>upsert : 可选，这个参数的意思是，如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入。<br>multi : 可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。<br>writeConcern :可选，抛出异常的级别。</p>
<blockquote>
<p>方式二：使用save()方法，并指定要替换的文档主键_id</p>
</blockquote>
<h4 id="3-删除文档"><a href="#3-删除文档" class="headerlink" title="3.删除文档"></a>3.删除文档</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方式一：</span><br><span class="line">db.collection.remove(</span><br><span class="line">   &lt;query&gt;,</span><br><span class="line">   &lt;justOne&gt;</span><br><span class="line">)</span><br><span class="line">MongoDB 是 2.6 版本以后：</span><br><span class="line">db.collection.remove(</span><br><span class="line">   &lt;query&gt;,</span><br><span class="line">   &#123;</span><br><span class="line">     justOne: &lt;boolean&gt;,</span><br><span class="line">     writeConcern: &lt;document&gt;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>参数说明：<br>query :（可选）删除的文档的条件。<br>justOne : （可选）如果设为 true 或 1，则只删除一个文档，如果不设置该参数，或使用默认值 false，则删除所有匹配条件的文档。<br>writeConcern :（可选）抛出异常的级别。</p>
<p>删除所有数据: db.collection.remove({}) （类似常规 SQL 的 truncate 命令）</p>
<h4 id="4-查看文档"><a href="#4-查看文档" class="headerlink" title="4.查看文档"></a>4.查看文档</h4><p>查询文档: db.collection.find(query, projection)<br>查询一个文档：db.collection.findOne()<br>以格式化的方式来显示所有文档: db.collection.find().pretty()</p>
<h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><h4 id="1-MongoDB-与-RDBMS-Where-语句比较"><a href="#1-MongoDB-与-RDBMS-Where-语句比较" class="headerlink" title="1.MongoDB 与 RDBMS Where 语句比较"></a>1.MongoDB 与 RDBMS Where 语句比较</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">等于	&#123;&lt;key&gt;:&lt;value&gt;&#125;	db.col.find(&#123;&quot;by&quot;:&quot;菜鸟教程&quot;&#125;).pretty()	where by = &#x27;菜鸟教程&#x27;</span><br><span class="line">小于	&#123;&lt;key&gt;:&#123;$lt:&lt;value&gt;&#125;&#125;	db.col.find(&#123;&quot;likes&quot;:&#123;$lt:50&#125;&#125;).pretty()	where likes &lt; 50</span><br><span class="line">小于或等于	&#123;&lt;key&gt;:&#123;$lte:&lt;value&gt;&#125;&#125;	db.col.find(&#123;&quot;likes&quot;:&#123;$lte:50&#125;&#125;).pretty()	where likes &lt;= 50</span><br><span class="line">大于	&#123;&lt;key&gt;:&#123;$gt:&lt;value&gt;&#125;&#125;	db.col.find(&#123;&quot;likes&quot;:&#123;$gt:50&#125;&#125;).pretty()	where likes &gt; 50</span><br><span class="line">大于或等于	&#123;&lt;key&gt;:&#123;$gte:&lt;value&gt;&#125;&#125;	db.col.find(&#123;&quot;likes&quot;:&#123;$gte:50&#125;&#125;).pretty()	where likes &gt;= 50</span><br><span class="line">不等于	&#123;&lt;key&gt;:&#123;$ne:&lt;value&gt;&#125;&#125;	db.col.find(&#123;&quot;likes&quot;:&#123;$ne:50&#125;&#125;).pretty()	where likes != 50</span><br></pre></td></tr></table></figure>
<h4 id="2-MongoDB-AND-条件"><a href="#2-MongoDB-AND-条件" class="headerlink" title="2.MongoDB AND 条件"></a>2.MongoDB AND 条件</h4><p>MongoDB 的 find() 方法可以传入多个键(key)，每个键(key)以逗号隔开，即常规 SQL 的 AND 条件</p>
<blockquote>
<p>db.col.find({key1:value1, key2:value2}).pretty()</p>
</blockquote>
<h4 id="3-MongoDB-OR-条件"><a href="#3-MongoDB-OR-条件" class="headerlink" title="3.MongoDB OR 条件"></a>3.MongoDB OR 条件</h4><p>MongoDB OR 条件语句使用了关键字 $or</p>
<blockquote>
<p>db.col.find({$or: [{key1: value1}, {key2:value2}]}).pretty()</p>
</blockquote>
<h3 id="type-操作符"><a href="#type-操作符" class="headerlink" title="$type 操作符"></a>$type 操作符</h3><blockquote>
<p>Double	1	<br>String	2	<br>Object	3	<br>Array	4	<br>Binary data	5	<br>Undefined	6	已废弃。<br>Object id	7	<br>Boolean	8	<br>Date	9	<br>Null	10	<br>Regular Expression	11	<br>JavaScript	13	<br>Symbol	14	<br>JavaScript (with scope)	15	<br>32-bit integer	16	<br>Timestamp	17	<br>64-bit integer	18	<br>Min key	255	Query with -1.<br>Max key	127</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">想获取 &quot;col&quot; 集合中 title 为 String 的数据:</span><br><span class="line">db.col.find(&#123;&quot;title&quot; : &#123;$type : 2&#125;&#125;)</span><br><span class="line">或</span><br><span class="line">db.col.find(&#123;&quot;title&quot; : &#123;$type : &#x27;string&#x27;&#125;&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="Limit与Skip方法"><a href="#Limit与Skip方法" class="headerlink" title="Limit与Skip方法"></a>Limit与Skip方法</h3><h4 id="1-Limit-：读取指定数量的数据记录"><a href="#1-Limit-：读取指定数量的数据记录" class="headerlink" title="1.Limit()：读取指定数量的数据记录"></a>1.Limit()：读取指定数量的数据记录</h4><blockquote>
<p>db.COLLECTION_NAME.find().limit(NUMBER)</p>
</blockquote>
<h4 id="2-Skip-方法：跳过指定数量的数据"><a href="#2-Skip-方法：跳过指定数量的数据" class="headerlink" title="2.Skip() 方法：跳过指定数量的数据"></a>2.Skip() 方法：跳过指定数量的数据</h4><blockquote>
<p>db.COLLECTION_NAME.find().limit(NUMBER).skip(NUMBER)</p>
</blockquote>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>使用 sort() 方法对数据进行排序，sort() 方法可以通过参数指定排序的字段，并使用 1 和 -1 来指定排序的方式，其中 1 为升序排列，而 -1 是用于降序排列。</p>
<blockquote>
<p>db.COLLECTION_NAME.find().sort({KEY:1})</p>
</blockquote>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><blockquote>
<p>创建索引：db.collection.createIndex(keys, options)<br>查看集合索引：db.col.getIndexes()<br>查看集合索引大小：db.col.totalIndexSize()<br>删除集合所有索引：db.col.dropIndexes()<br>删除集合指定索引：db.col.dropIndex(“索引名称”)</p>
</blockquote>
<p>Key 值为你要创建的索引字段，1 为指定按升序创建索引，如果你想按降序来创建索引指定为 -1<br>注：<br>在 3.0.0 版本前创建索引方法为 db.collection.ensureIndex()，之后的版本使用了 db.collection.createIndex() 方法，ensureIndex() 还能用，但只是 createIndex() 的别名。</p>
<p>参数说明：<br>background	Boolean	建索引过程会阻塞其它数据库操作，background可指定以后台方式创建索引，即增加 “background” 可选参数。 “background” 默认值为false。<br>unique	Boolean	建立的索引是否唯一。指定为true创建唯一索引。默认值为false.<br>name	string	索引的名称。如果未指定，MongoDB的通过连接索引的字段名和排序顺序生成一个索引名称。<br>dropDups	Boolean	3.0+版本已废弃。在建立唯一索引时是否删除重复记录,指定 true 创建唯一索引。默认值为 false.<br>sparse	Boolean	对文档中不存在的字段数据不启用索引；这个参数需要特别注意，如果设置为true的话，在索引字段中不会查询出不包含对应字段的文档.。默认值为 false.<br>expireAfterSeconds	integer	指定一个以秒为单位的数值，完成 TTL设定，设定集合的生存时间。<br>v	index version	索引的版本号。默认的索引版本取决于mongod创建索引时运行的版本。<br>weights	document	索引权重值，数值在 1 到 99,999 之间，表示该索引相对于其他索引字段的得分权重。<br>default_language	string	对于文本索引，该参数决定了停用词及词干和词器的规则的列表。 默认为英语<br>language_override	string	对于文本索引，该参数指定了包含在文档中的字段名，语言覆盖默认的language，默认值为 language.</p>
<h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><p>MongoDB中聚合的方法使用aggregate()，类似 SQL 语句中的 count(*)</p>
<blockquote>
<p>db.COLLECTION_NAME.aggregate(AGGREGATE_OPERATION)</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$sum	计算总和。	db.mycol.aggregate([&#123;$group : &#123;_id : &quot;$by_user&quot;, num_tutorial : &#123;$sum : &quot;$likes&quot;&#125;&#125;&#125;])</span><br><span class="line">$avg	计算平均值	db.mycol.aggregate([&#123;$group : &#123;_id : &quot;$by_user&quot;, num_tutorial : &#123;$avg : &quot;$likes&quot;&#125;&#125;&#125;])</span><br><span class="line">$min	获取集合中所有文档对应值得最小值。	db.mycol.aggregate([&#123;$group : &#123;_id : &quot;$by_user&quot;, num_tutorial : &#123;$min : &quot;$likes&quot;&#125;&#125;&#125;])</span><br><span class="line">$max	获取集合中所有文档对应值得最大值。	db.mycol.aggregate([&#123;$group : &#123;_id : &quot;$by_user&quot;, num_tutorial : &#123;$max : &quot;$likes&quot;&#125;&#125;&#125;])</span><br><span class="line">$push	将值加入一个数组中，不会判断是否有重复的值。	db.mycol.aggregate([&#123;$group : &#123;_id : &quot;$by_user&quot;, url : &#123;$push: &quot;$url&quot;&#125;&#125;&#125;])</span><br><span class="line">$addToSet	将值加入一个数组中，会判断是否有重复的值，若相同的值在数组中已经存在了，则不加入。	db.mycol.aggregate([&#123;$group : &#123;_id : &quot;$by_user&quot;, url : &#123;$addToSet : &quot;$url&quot;&#125;&#125;&#125;])</span><br><span class="line">$first	根据资源文档的排序获取第一个文档数据。	db.mycol.aggregate([&#123;$group : &#123;_id : &quot;$by_user&quot;, first_url : &#123;$first : &quot;$url&quot;&#125;&#125;&#125;])</span><br><span class="line">$last	根据资源文档的排序获取最后一个文档数据</span><br></pre></td></tr></table></figure>

<h3 id="复制-副本集"><a href="#复制-副本集" class="headerlink" title="复制(副本集)"></a>复制(副本集)</h3><h4 id="1-复制原理："><a href="#1-复制原理：" class="headerlink" title="1.复制原理："></a>1.复制原理：</h4><p>mongodb的复制至少需要两个节点。其中一个是主节点，负责处理客户端请求，其余的都是从节点，负责复制主节点上的数据。<br>mongodb各个节点常见的搭配方式为：一主一从、一主多从。<br>主节点记录在其上的所有操作oplog，从节点定期轮询主节点获取这些操作，然后对自己的数据副本执行这些操作，从而保证从节点的数据与主节点一致。</p>
<h4 id="2-副本集设置"><a href="#2-副本集设置" class="headerlink" title="2.副本集设置"></a>2.副本集设置</h4><p>关闭正在运行的MongoDB服务器：mongod –port “PORT” –dbpath “YOUR_DB_DATA_PATH” –replSet “REPLICA_SET_INSTANCE_NAME”</p>
<blockquote>
<p>启动一个新的副本集：rs.initiate()<br>查看副本集的配置：rs.conf()<br>查看副本集状态： rs.status()<br>添加成员：rs.add(HOST_NAME:PORT)<br>判断当前运行的Mongo服务是否为主节点：db.isMaster() </p>
</blockquote>
<p>注：MongoDB的副本集与我们常见的主从有所不同，主从在主机宕机后所有服务将停止，而副本集在主机宕机后，副本会接管主节点成为主节点，不会出现宕机的情况。</p>
<h3 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h3><h4 id="1-为什么使用分片？"><a href="#1-为什么使用分片？" class="headerlink" title="1.为什么使用分片？"></a>1.为什么使用分片？</h4><p>复制所有的写入操作到主节点<br>延迟的敏感数据会在主节点查询<br>单个副本集限制在12个节点<br>当请求量巨大时会出现内存不足。<br>本地磁盘不足<br>垂直扩展价格昂贵</p>
<h4 id="2-分片的主要组件"><a href="#2-分片的主要组件" class="headerlink" title="2.分片的主要组件"></a>2.分片的主要组件</h4><p>Shard:<br>用于存储实际的数据块，实际生产环境中一个shard server角色可由几台机器组个一个replica set承担，防止主机单点故障<br>Config Server:<br>mongod实例，存储了整个 ClusterMetadata，其中包括 chunk信息。<br>Query Routers:<br>前端路由，客户端由此接入，且让整个集群看上去像单一数据库，前端应用可以透明使用。</p>
<h3 id="备份-mongodump-与恢复-mongorestore"><a href="#备份-mongodump-与恢复-mongorestore" class="headerlink" title="备份(mongodump)与恢复(mongorestore)"></a>备份(mongodump)与恢复(mongorestore)</h3><h4 id="1-数据备份"><a href="#1-数据备份" class="headerlink" title="1.数据备份"></a>1.数据备份</h4><p>使用mongodump命令来备份MongoDB数据。该命令可以导出所有数据到指定目录中。<br>mongodump命令可以通过参数指定导出的数据量级转存的服务器。</p>
<blockquote>
<p>mongodump -h dbhost -d dbname -o dbdirectory</p>
</blockquote>
<p>参数说明：<br>-h：<br>MongoDB 所在服务器地址，例如：127.0.0.1，当然也可以指定端口号：127.0.0.1:27017<br>-d：<br>需要备份的数据库实例，例如：test<br>-o：<br>备份的数据存放位置，例如：c:\data\dump，当然该目录需要提前建立，在备份完成后，系统自动在dump目录下建立一个test目录，这个目录里面存放该数据库实例的备份数据。</p>
<h4 id="2-数据恢复"><a href="#2-数据恢复" class="headerlink" title="2.数据恢复"></a>2.数据恢复</h4><p>使用 mongorestore 命令来恢复备份的数据。</p>
<blockquote>
<p>mongorestore -h &lt;hostname&gt;&lt;:port&gt; -d dbname &lt;path&gt;</p>
</blockquote>
<p>参数说明：<br>-host &lt;:port&gt;, -h &lt;:port&gt;：<br>MongoDB所在服务器地址，默认为： localhost:27017<br>–db , -d ：<br>需要恢复的数据库实例，例如：test，当然这个名称也可以和备份时候的不一样，比如test2<br>–drop：<br>恢复的时候，先删除当前数据，然后恢复备份的数据。就是说，恢复后，备份后添加修改的数据都会被删除，慎用哦！<br>&lt;path&gt;：<br>mongorestore 最后的一个参数，设置备份数据所在位置，例如：c:\data\dump\test。<br>你不能同时指定 &lt;path&gt; 和 –dir 选项，–dir也可以设置备份目录。<br>–dir：<br>指定备份的目录<br>你不能同时指定 &lt;path&gt; 和 –dir 选项。</p>
<h3 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h3><p>MongoDB中提供了mongostat 和 mongotop 两个命令来监控MongoDB的运行情况。</p>
<p>mongostat是mongodb自带的状态检测工具，在命令行下使用。它会间隔固定时间获取mongodb的当前运行状态，并输出。如果你发现数据库突然变慢或者有其他问题的话，你第一手的操作就考虑采用mongostat来查看mongo的状态。<br>启动你的Mongod服务，进入到你安装的MongoDB目录下的bin目录， 然后输入mongostat命令，如下所示：</p>
<blockquote>
<p>$ D:\set up\mongodb\bin&gt;mongostat</p>
</blockquote>
<p>mongotop也是mongodb下的一个内置工具，mongotop提供了一个方法，用来跟踪一个MongoDB的实例，查看哪些大量的时间花费在读取和写入数据。 mongotop提供每个集合的水平的统计数据。默认情况下，mongotop返回值的每一秒。<br>启动你的Mongod服务，进入到你安装的MongoDB目录下的bin目录， 然后输入mongotop命令，如下所示：</p>
<blockquote>
<p>$ D:\set up\mongodb\bin&gt;mongotop</p>
</blockquote>
<hr>
<p>😊END</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux入门</title>
    <url>/posts/30b5ce3c.html</url>
    <content><![CDATA[<h3 id="Linux简介"><a href="#Linux简介" class="headerlink" title="Linux简介"></a>Linux简介</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>Linux 是一套免费使用和自由传播的类 Unix 操作系统，是一个基于 POSIX 和 UNIX 的多用户、多任务、支持多线程和多 CPU 的操作系统。<br>Linux 能运行主要的 UNIX 工具软件、应用程序和网络协议。它支持 32 位和 64 位硬件。Linux 继承了 Unix 以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。</p>
<h4 id="发行版"><a href="#发行版" class="headerlink" title="发行版"></a>发行版</h4><p>Linux 的发行版说简单点就是将 Linux 内核与应用软件做一个打包。<br>目前市面上较知名的发行版有：Ubuntu、RedHat、CentOS、Debian、Fedora、SuSE、OpenSUSE、Arch Linux、SolusOS 等。</p>
<h4 id="Linux-vs-Windows"><a href="#Linux-vs-Windows" class="headerlink" title="Linux vs Windows"></a>Linux vs Windows</h4><ol>
<li>软件与支持<br>Windows 平台:数量和质量的优势，不过大部分为收费软件；由微软官方提供重要支持和服务；<br>Linux 平台：大都为开源自由软件，用户可以修改定制和再发布，由于基本免费没有资金支持，部分软件质量和体验欠缺；有全球所有的 Linux 开发者和自由软件社区提供支持。</li>
<li>安全性<br>Windows 平台：三天两头打补丁安装系统安全更新，还是会中病毒木马；<br>Linux 平台：要说 Linux 没有安全问题，那当然是不可能的，这一点仁者见仁智者见智，相对来说肯定比 Windows 平台要更加安全，使用 Linux 你也不用装某杀毒，某毒霸。</li>
<li>使用习惯<br>Windows：普通用户基本都是纯图形界面下操作使用，依靠鼠标和键盘完成一切操作，用户上手容易入门简单；<br>Linux：兼具图形界面操作（需要使用带有桌面环境的发行版）和完全的命令行操作，可以只用键盘完成一切操作，新手入门较困难，需要一些学习和指导（这正是我们要做的事情），一旦熟练之后效率极高。</li>
<li>可定制性<br>Windows：操作范围大多已经受到微软的限制，所以基本上是系统怎样设置，用户就只能规矩操作。<br>Linux：提供了更高的定制性，它支持开发者通过编码来定义适合自己的操作系统。</li>
<li>应用范畴<br>Windows：无特定的应用范畴，一般就是常规的电脑使用场景。<br>Linux： 主要作为服务器主机，进行忙碌的数据处理和运算</li>
<li>是否开源<br>Linux：免费开源</li>
</ol>
<h3 id="Linux启动过程"><a href="#Linux启动过程" class="headerlink" title="Linux启动过程"></a>Linux启动过程</h3><ol>
<li>内核的引导。<br>当计算机打开电源后，首先是BIOS开机自检，按照BIOS中设置的启动设备（通常是硬盘）来启动。<br>操作系统接管硬件以后，首先读入 &#x2F;boot 目录下的内核文件。</li>
<li>运行 init。<br>init 进程是系统所有进程的起点，你可以把它比拟成系统所有进程的老祖宗，没有这个进程，系统中任何进程都不会启动。<br>init 程序首先是需要读取配置文件 &#x2F;etc&#x2F;inittab。<br>运行级别：<br>许多程序需要开机启动。它们在Windows叫做”服务”（service），在Linux就叫做”守护进程”（daemon）。<br>init进程的一大任务，就是去运行这些开机启动的程序。<br>但是，不同的场合需要启动不同的程序，比如用作服务器时，需要启动Apache，用作桌面就不需要。<br>Linux允许为不同的场合，分配不同的开机启动程序，这就叫做”运行级别”（runlevel）。也就是说，启动时根据”运行级别”，确定要运行哪些程序。<br>Linux系统有7个运行级别(runlevel)：<br>运行级别0：系统停机状态，系统默认运行级别不能设为0，否则不能正常启动<br>运行级别1：单用户工作状态，root权限，用于系统维护，禁止远程登录<br>运行级别2：多用户状态(没有NFS)<br>运行级别3：完全的多用户状态(有NFS)，登录后进入控制台命令行模式<br>运行级别4：系统未使用，保留<br>运行级别5：X11控制台，登录后进入图形GUI模式<br>运行级别6：系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动</li>
<li>系统初始化。<br>在init的配置文件中有这么一行： si::sysinit:&#x2F;etc&#x2F;rc.d&#x2F;rc.sysinit　它调用执行了&#x2F;etc&#x2F;rc.d&#x2F;rc.sysinit，而rc.sysinit是一个bash shell的脚本，它主要是完成一些系统初始化的工作，rc.sysinit是每一个运行级别都要首先运行的重要脚本。<br>它主要完成的工作有：激活交换分区，检查磁盘，加载硬件模块以及其它一些需要优先执行任务。</li>
<li>建立终端 。<br>rc执行完毕后，返回init。这时基本系统环境已经设置好了，各种守护进程也已经启动了。<br>init接下来会打开6个终端，以便用户登录系统。</li>
<li>用户登录系统。<br>一般来说，用户的登录方式有三种：<br>（1）命令行登录<br>（2）ssh登录<br>（3）图形界面登录<br>注：<br>Linux 关机：<blockquote>
<p>sync 将数据由内存同步到硬盘中。</p>
<blockquote>
<p>不管是重启系统还是关闭系统，首先要运行 sync 命令，把内存中的数据写到磁盘中。</p>
</blockquote>
</blockquote>
</li>
</ol>
<blockquote>
<p>shutdown 关机指令，你可以man shutdown 来看一下帮助文档。例如你可以运行如下命令关机：<br>shutdown –h 10 ‘This server will shutdown after 10 mins’ 这个命令告诉大家，计算机将在10分钟后关机，并且会显示在登陆用户的当前屏幕中。<br>shutdown –h now 立马关机<br>shutdown –h 20:25 系统会在今天20:25关机<br>shutdown –h +10 十分钟后关机<br>shutdown –r now 系统立马重启<br>shutdown –r +10 系统十分钟后重启<br>reboot 就是重启，等同于 shutdown –r now<br>halt 关闭系统，等同于shutdown –h now 和 poweroff</p>
</blockquote>
<h3 id="Linux目录结构"><a href="#Linux目录结构" class="headerlink" title="Linux目录结构"></a>Linux目录结构</h3><p><strong>系统启动必须：</strong></p>
<ul>
<li><p><strong>&#x2F;boot：</strong>存放的启动Linux 时使用的内核文件，包括连接文件以及镜像文件。</p>
</li>
<li><p><strong>&#x2F;etc：</strong>存放<strong>所有</strong>的系统需要的<strong>配置文件</strong>和<strong>子目录列表，</strong>更改目录下的文件可能会导致系统不能启动。</p>
</li>
<li><p><strong>&#x2F;lib</strong>：存放基本代码库（比如c++库），其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。</p>
</li>
<li><p><strong>&#x2F;sys</strong>： 这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。sysfs文件系统集成了下面3种文件系统的信息：针对进程信息的proc文件系统、针对设备的devfs文件系统以及针对伪终端的devpts文件系统。该文件系统是内核设备树的一个直观反映。当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中</p>
</li>
</ul>
<p><strong>指令集合：</strong></p>
<ul>
<li><p><strong>&#x2F;bin：</strong>存放着最常用的程序和指令</p>
</li>
<li><p><strong>&#x2F;sbin：</strong>只有系统管理员能使用的程序和指令。</p>
</li>
</ul>
<p><strong>外部文件管理：</strong></p>
<ul>
<li><p><strong>&#x2F;dev ：</strong>Device(设备)的缩写, 存放的是Linux的外部设备。<strong>注意：</strong>在Linux中访问设备和访问文件的方式是相同的。</p>
</li>
<li><p><strong>&#x2F;media</strong>：类windows的<strong>其他设备，</strong>例如U盘、光驱等等，识别后linux会把设备放到这个目录下。</p>
</li>
<li><p><strong>&#x2F;mnt</strong>：临时挂载别的文件系统的，我们可以将光驱挂载在&#x2F;mnt&#x2F;上，然后进入该目录就可以查看光驱里的内容了。</p>
</li>
</ul>
<p><strong>临时文件：</strong></p>
<ul>
<li><p><strong>&#x2F;run</strong>：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 &#x2F;var&#x2F;run 目录，应该让它指向 run。</p>
</li>
<li><p><strong>&#x2F;lost+found</strong>：一般情况下为空的，系统非法关机后，这里就存放一些文件。</p>
</li>
<li><p><strong>&#x2F;tmp</strong>：这个目录是用来存放一些临时文件的。</p>
</li>
</ul>
<p><strong>账户：</strong></p>
<ul>
<li><p><strong>&#x2F;root</strong>：系统管理员的用户主目录。</p>
</li>
<li><p><strong>&#x2F;home</strong>：用户的主目录，以用户的账号命名的。</p>
</li>
<li><p><strong>&#x2F;usr</strong>：用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。</p>
</li>
<li><p><strong>&#x2F;usr&#x2F;bin：</strong>系统用户使用的应用程序与指令。</p>
</li>
<li><p><strong>&#x2F;usr&#x2F;sbin：</strong>超级用户使用的比较高级的管理程序和系统守护程序。</p>
</li>
<li><p><strong>&#x2F;usr&#x2F;src：</strong>内核源代码默认的放置目录。</p>
</li>
</ul>
<p><strong>运行过程中要用：</strong></p>
<ul>
<li><p><strong>&#x2F;var</strong>：存放经常修改的数据，比如程序运行的日志文件（&#x2F;var&#x2F;log 目录下）。</p>
</li>
<li><p><strong>&#x2F;proc</strong>：管理<strong>内存空间！</strong>虚拟的目录，是系统内存的映射，我们可以直接访问这个目录来，获取系统信息。这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件来做修改。</p>
</li>
</ul>
<p><strong>扩展用的：</strong></p>
<ul>
<li><p><strong>&#x2F;opt</strong>：默认是空的，我们安装额外软件可以放在这个里面。</p>
</li>
<li><p><strong>&#x2F;srv</strong>：存放服务启动后需要提取的数据<strong>（不用服务器就是空）</strong><br>注：<br>在Linux文件系统中有两个特殊的目录，一个用户所在的工作目录，也叫当前目录，可以使用一个点 . 来表示；另一个是当前目录的上一级目录，也叫父目录，可以使用两个点 .. 来表示。<br> . ：代表当前的目录，也可以使用 .&#x2F; 来表示；<br> .. ：代表上一层目录，也可以 ..&#x2F; 来代表。<br>如果一个目录或文件名以一个点 . 开始，表示这个目录或文件是一个隐藏目录或文件(如：.bashrc)。即以默认方式查找时，不显示该目录或文件。</p>
</li>
</ul>
<h3 id="Linux用户"><a href="#Linux用户" class="headerlink" title="Linux用户"></a>Linux用户</h3><h4 id="文件基本属性"><a href="#文件基本属性" class="headerlink" title="文件基本属性"></a>文件基本属性</h4><p>Linux 系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。<br>为了保护系统的安全性，Linux 系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。<br>在 Linux 中我们通常使用以下两个命令来修改文件或目录的所属用户与权限：<br>chown (change owner) ： 修改所属用户与组。<br>chmod (change mode) ： 修改用户的权限。</p>
<p>显示一个文件的属性以及文件所属的用户和组：ll 或者 ls –l </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">ls</span> -l</span></span><br><span class="line">total 64</span><br><span class="line">drwxr-xr-x 2 root  root  4096 Feb 15 14:46 cron</span><br></pre></td></tr></table></figure>
<p>从左到右的字符含义：<br>filetype|user permissions|group permissions|other permissions|number of hard links|user name|group name|size|date&#x2F;time last modified|filename<br>含义说明：<br>第 0 位确定文件类型，第 1-3 位确定属主（该文件的所有者）拥有该文件的权限。<br>第4-6位确定属组（所有者的同组用户）拥有该文件的权限，<br>第7-9位确定其他用户拥有该文件的权限。<br>其中，<br>第 1、4、7 位表示读权限，如果用 r 字符表示，则有读权限，如果用 - 字符表示，则没有读权限；<br>第 2、5、8 位表示写权限，如果用 w 字符表示，则有写权限，如果用 - 字符表示没有写权限；<br>第 3、6、9 位表示可执行权限，如果用 x 字符表示，则有执行权限，如果用 - 字符表示，则没有执行权限。<br>说明：<br>在 Linux 中第一个字符代表这个文件是目录、文件或链接文件等等。<br>当为 d 则是目录<br>当为 - 则是文件；<br>若是 l 则表示为链接文档(link file)；<br>若是 b 则表示为装置文件里面的可供储存的接口设备(可随机存取装置)；<br>若是 c 则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)。</p>
<h4 id="用户和用户组管理"><a href="#用户和用户组管理" class="headerlink" title="用户和用户组管理"></a>用户和用户组管理</h4><p>Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。</p>
<p>用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。</p>
<p>每个用户账号都拥有一个唯一的用户名和各自的口令。</p>
<p>用户在登录时键入正确的用户名和口令后，就能够进入系统和自己的主目录。</p>
<p>实现用户账号的管理，要完成的工作主要有如下几个方面：</p>
<p>用户账号的添加、删除与修改。<br>用户口令的管理。<br>用户组的管理。</p>
<h3 id="🍋Linux命令"><a href="#🍋Linux命令" class="headerlink" title="🍋Linux命令"></a>🍋Linux命令</h3><h4 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h4><h5 id="用户账号的管理"><a href="#用户账号的管理" class="headerlink" title="用户账号的管理"></a>用户账号的管理</h5><ul>
<li>useradd 选项 用户名 ：添加新的用户账号<br>useradd –d  &#x2F;home&#x2F;sam -m sam ：创建了一个用户sam，其中-d和-m选项用来为登录名sam产生一个主目录 &#x2F;home&#x2F;sam（&#x2F;home为默认的用户主目录所在的父目录）。</li>
<li>userdel 选项 用户名 ：删除帐号<br>userdel -r sam ：删除用户sam在系统文件中（主要是&#x2F;etc&#x2F;passwd, &#x2F;etc&#x2F;shadow, &#x2F;etc&#x2F;group等）的记录，同时删除用户的主目录</li>
<li>usermod 选项 用户名 : 修改帐号<br>usermod -s &#x2F;bin&#x2F;ksh -d &#x2F;home&#x2F;z –g developer sam : 将用户sam的登录Shell修改为ksh，主目录改为&#x2F;home&#x2F;z，用户组改为developer</li>
<li>passwd 选项 用户名 : 用户口令的管理<br>当前用户是sam，则下面的命令修改该用户自己的口令：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">passwd</span> </span><br><span class="line">Old password:****** </span><br><span class="line">New password:******* </span><br><span class="line">Re-enter new password:*******</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="用户组的管理"><a href="#用户组的管理" class="headerlink" title="用户组的管理"></a>用户组的管理</h5><ul>
<li>groupadd 选项 用户组 ： 增加一个新的用户组<br> groupadd group1 ： 向系统中增加了一个新组group1，新组的组标识号是在当前已有的最大组标识号的基础上加1</li>
<li>groupdel 用户组 ： 删除一个已有的用户组<br>groupdel group1 ： 从系统中删除组group1</li>
<li>groupmod 选项 用户组 ：修改用户组<br>groupmod -g 102 group2 ： 将组group2的组标识号修改为102</li>
<li>newgrp root ：将当前用户切换到root用户组，前提条件是root用户组确实是该用户的主组或附加组</li>
</ul>
<h4 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h4><ul>
<li>df：检查文件系统的磁盘空间占用情况<br>df -h ：将容量结果以易读的容量格式显示出来<br>df -aT ： 将系统内的所有特殊文件格式及名称都列出来<br>df -h &#x2F;etc ： 将 &#x2F;etc 底下的可用的磁盘容量以易读的容量格式显示</li>
<li>du: 列出当前目录下的所有文件夹容量（包括隐藏文件夹）<br>du -a : 将文件的容量也列出来<br>du -sm &#x2F;* ： 检查根目录底下每个目录所占用的容量</li>
<li>fdisk：磁盘分区表操作工具<br>fdisk -l ： 列出所有分区信息</li>
<li>mkfs：进行文件系统的格式化<br>mkfs[tab][tab] ：按下两个[tab]，查看 mkfs 支持的文件格式<br>mkfs -t ext3 &#x2F;dev&#x2F;hdc6 : 将分区 &#x2F;dev&#x2F;hdc6（可指定你自己的分区） 格式化为 ext3 文件系统</li>
<li>fsck ：检查和维护不一致的文件系统<br>fsck -C -f -t ext3 &#x2F;dev&#x2F;hdc6  ：强制检测 &#x2F;dev&#x2F;hdc6 分区</li>
<li>mount：磁盘挂载<br>mount &#x2F;dev&#x2F;hdc6 &#x2F;mnt&#x2F;hdc6 ：，将 &#x2F;dev&#x2F;hdc6 挂载到 &#x2F;mnt&#x2F;hdc6 上面</li>
<li>umount：磁盘卸载<br>umount &#x2F;dev&#x2F;hdc6  ： 卸载&#x2F;dev&#x2F;hdc6</li>
</ul>
<h4 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h4><h5 id="处理目录的常用命令"><a href="#处理目录的常用命令" class="headerlink" title="处理目录的常用命令"></a>处理目录的常用命令</h5><ul>
<li>ls: 列出目录及文件名<br>ls -a ：全部的文件，连同隐藏文件( 开头为 . 的文件) 一起列出来(常用)<br>ls -d ：仅列出目录本身，而不是列出目录内的文件数据(常用)<br>ls -l ：长数据串列出，包含文件的属性与权限等等数据；(常用)</li>
<li>cd：切换目录<br>  cd &#x2F;父目录&#x2F;子目录&#x2F; ：使用绝对路径切换到 runoob 目录<br>  cd .&#x2F;目录名&#x2F; ：使用相对路径切换到 runoob 目录<br>  cd ~ ：回到自己的根目录<br>  cd .. ：回到目前的上一级目录</li>
<li>pwd：显示目前的目录<br>  pwd ：显示出目前所在的目录<br>  pwd -P ：会不以连结档的数据显示，而是显示正确的完整路径</li>
<li>mkdir：创建一个新的目录<br>  mkdir 目录名称 ：创建新的目录<br>  mkdir -p  目录&#x2F;目录&#x2F;目录 ：自动创建了多层目录<br>  mkdir -m 711 目录 ：配置文件的权限</li>
<li>rmdir：删除一个空的目录<br>  rmdir 目录名称 ：删除空的目录</li>
<li>rmdir  -p 目录&#x2F;目录 ：连同上一级『空的』目录也一起删除</li>
<li>cp: 复制文件或目录<br>  cp [-a -d -f -I -l -p -r -s -u] 来源档(source) 目标档(destination)<br>  cp [options] source1 source2 source3 …. directory</li>
<li>rm: 移除文件或目录<br>rm -i 目录&#x2F;文件 ：互动模式，在删除前会询问使用者是否动作<br>rm -f 文件或目录 ：忽略不存在的文件，不会出现警告信息<br>rm -r 文件或目录 ：递归删除，最常用在目录的删除，这是非常危险的选项</li>
<li>mv: 移动目录，或修改文件与目录的名称<br>mv 目录1 目录2 ：将目录1移动到目录2中<br>mv -f 文件 目录 ：将文件移动到目录中，如果目标文件已经存在，不会询问而直接覆盖<br>mv -i 文件 目录 ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！<br>mv -u 文件 目录 ：若目标文件已经存在，且 source 比较新，才会升级 (update)<br>可以使用 man [命令] 来查看各个命令的使用文档，如 ：man cp</li>
</ul>
<h5 id="文件操作的常用命令"><a href="#文件操作的常用命令" class="headerlink" title="文件操作的常用命令"></a>文件操作的常用命令</h5><ul>
<li>touch: 创建文件<br>  touch 文件名：在当前目录下创建文件<br>  touch 目录&#x2F;文件名：在指定目录下创建文件</li>
<li>mv: 移动文件<br>  mv 文件 目录 ：将文件移动到目录中<br>  mv 文件名1 文件名2: 将文件名1重命名为文件名2，注意当前目录不存在文件名2</li>
</ul>
<h5 id="文件内容查看"><a href="#文件内容查看" class="headerlink" title="文件内容查看"></a>文件内容查看</h5><ul>
<li>cat 由第一行开始显示文件内容<br>语法：cat [-AbEnTv] 文件</li>
<li>tac 从最后一行开始显示，可以看出 tac 是 cat 的倒着写！<br>语法：tac 文件</li>
<li>nl 显示的时候，顺道输出行号！<br>语法：nl [-bnw] 文件</li>
<li>more 一页一页的显示文件内容<br>语法：more 文件</li>
<li>less 与 more 类似，但是比 more 更好的是，可以往前翻页！<br>语法：less 文件</li>
<li>head 只看头几行<br>语法：head [-n number] 文件 </li>
<li>tail 只看尾巴几行<br>语法：tail [-n number] 文件</li>
</ul>
<h4 id="系统命令"><a href="#系统命令" class="headerlink" title="系统命令"></a>系统命令</h4><h5 id="系统管理命令"><a href="#系统管理命令" class="headerlink" title="系统管理命令"></a>系统管理命令</h5><p>ps 列出系统当前运行的进程<br>        语法：ps [参数]<br>            ps -ef  :查看所有进程<br>kill 中止执行中的程序<br>            语法：kill [参数] [进程号]<br>        kill -9 9437 ：强制终止PID为9437的进程</p>
<h5 id="网络管理命令"><a href="#网络管理命令" class="headerlink" title="网络管理命令"></a>网络管理命令</h5><p>hostname 查看主机名<br>        语法：hostname<br>ifconfig 查看ip地址<br>        语法：ifconfig<br>netstat 显示与网络协议吸纳骨干的统计数据<br>        语法：netstat [参数]<br>            netstat -nltup</p>
<h5 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h5><p>清屏	语法：clear  或者ctrl+l<br>重启  语法：reboot<br>立刻断电关机   语法：shutdown -h now	<br>停止ping命令：ctrl+c  或 ctrl+z</p>
<h3 id="Linux-vim"><a href="#Linux-vim" class="headerlink" title="Linux vim"></a>Linux vim</h3><p>Vim 是从 vi 发展出来的一个文本编辑器。代码补全、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用</p>
<h4 id="vi-x2F-vim-的使用"><a href="#vi-x2F-vim-的使用" class="headerlink" title="vi&#x2F;vim 的使用"></a>vi&#x2F;vim 的使用</h4><h5 id="三种模式"><a href="#三种模式" class="headerlink" title="三种模式"></a>三种模式</h5><ul>
<li>命令模式：<br>此状态下敲击键盘动作会被Vim识别为命令，而非输入字符</li>
<li>输入模式:<br>可以使用以下按键：<br>字符按键以及Shift组合，输入字符<br>ENTER，回车键，换行<br>BACK SPACE，退格键，删除光标前一个字符<br>DEL，删除键，删除光标后一个字符<br>方向键，在文本中移动光标<br>HOME&#x2F;END，移动光标到行首&#x2F;行尾<br>Page Up&#x2F;Page Down，上&#x2F;下翻页<br>Insert，切换光标为输入&#x2F;替换模式，光标将变成竖线&#x2F;下划线<br>ESC，退出输入模式，切换到命令模式</li>
<li>底线命令模式：<br>底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。<br>基本的命令有（已经省略了冒号）：<br>q 退出程序<br>w 保存文件</li>
<li>三种命令的切换：<br>从命令模式转换到编辑模式，可以输入命令a(追加)或i(插入)或o(下方另起一行)或O(上方另起一行)。<br>从编辑模式返回命令模式，则按下Esc键即可。<br>在命令模式下输入:即可切换到底行模式，然后输入命令<br>退出vi&#x2F;vim：命令模式下 ：wq</li>
</ul>
<h5 id="按键说明"><a href="#按键说明" class="headerlink" title="按键说明"></a>按键说明</h5><p>命令模式下：<br>G	移动到这个档案的最后一行(常用)<br>gg	移动到这个档案的第一行，相当于 1G 啊！ (常用)<br>&#x2F;word	向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 &#x2F;vbird 即可！ (常用)<br>n	这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 &#x2F;vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！<br>dd	剪切游标所在的那一整行(常用)，用 p&#x2F;P 可以粘贴。<br>yy	复制游标所在的那一行(常用)<br>u 撤销上一次命令<br>底线命令模式模式下：<br>:w	将编辑的数据写入硬盘档案中(常用)<br>:w filename 另存为<br>:w!	若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入， 还是跟你对该档案的档案权限有关啊！<br>:q	离开 vi (常用)<br>:q!	若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。<br>:wq	储存后离开，若为 :wq! 则为强制储存后离开 (常用)<br>:set nu	显示行号，设定之后，会在每一行的前缀显示该行的行号<br>:set nonu	与 set nu 相反，为取消行号！</p>
<h3 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。Shell 既是一种命令语言，又是一种程序设计语言。<br>业界所说的 shell 通常都是指 shell 脚本，但要知道，shell 和 shell script 是两个不同的概念。<br>Linux 的 Shell 种类众多，常见的有：<br>Bourne Shell（&#x2F;usr&#x2F;bin&#x2F;sh或&#x2F;bin&#x2F;sh）<br>Bourne Again Shell（&#x2F;bin&#x2F;bash）<br>C Shell（&#x2F;usr&#x2F;bin&#x2F;csh）<br>K Shell（&#x2F;usr&#x2F;bin&#x2F;ksh）<br>Shell for Root（&#x2F;sbin&#x2F;sh）</p>
<h4 id="shell脚本"><a href="#shell脚本" class="headerlink" title="shell脚本"></a>shell脚本</h4><p>实例：<br>1.创建shell脚本文件：vim test.sh<br>注：扩展名并不影响脚本执行，见名知意就好</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello World !&quot;</span></span><br></pre></td></tr></table></figure>
<p>注：<br>第一行是必须的！<br>#! 是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种 Shell。<br>echo 命令用于向窗口输出文本。</p>
<p>2.运行 Shell 脚本<br>方法一：作为可执行程序<br>chmod +x .&#x2F;test.sh  #使脚本具有执行权限<br>.&#x2F;test.sh  #执行脚本<br>注：<br>一定要写成 .&#x2F;test.sh，而不是 test.sh，运行其它二进制的程序也一样，直接写 test.sh，linux 系统会去 PATH 里寻找有没有叫 test.sh 的，而只有 &#x2F;bin, &#x2F;sbin, &#x2F;usr&#x2F;bin，&#x2F;usr&#x2F;sbin 等在 PATH 里，你的当前目录通常不在 PATH 里，所以写成 test.sh 是会找不到命令的，要用 .&#x2F;test.sh 告诉系统说，就在当前目录找。<br>方法二：作为解释器参数<br>&#x2F;bin&#x2F;sh test.sh<br>注:<br>这种方式运行的脚本，不需要在第一行指定解释器信息，写了也没用</p>
<h4 id="shell变量"><a href="#shell变量" class="headerlink" title="shell变量"></a>shell变量</h4><h5 id="命名规则："><a href="#命名规则：" class="headerlink" title="命名规则："></a>命名规则：</h5><p>命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。<br>中间不能有空格，可以使用下划线 _。<br>不能使用标点符号。<br>不能使用bash里的关键字（可用help命令查看保留关键字）。<br>变量名和等号之间不能有空格</p>
<h5 id="变量操作："><a href="#变量操作：" class="headerlink" title="变量操作："></a>变量操作：</h5><p>1.定义变量：name&#x3D;”value”<br>只读变量(常量)：readonly name<br>2.使用变量：echo $your_name  或echo ${your_name} echo ${your_name}<br>注：<br>在变量名前面加美元符号即可<br>花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界（推荐给所有变量加上花括号，这是个好的编程习惯）<br>3.删除变量：unset name<br>注：unset 命令不能删除只读变量</p>
<h5 id="变量类型："><a href="#变量类型：" class="headerlink" title="变量类型："></a>变量类型：</h5><ol>
<li>局部变量 局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。</li>
<li>环境变量 所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。</li>
<li>shell变量 shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行</li>
</ol>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>字符串可以用单引号，也可以用双引号，也可以不用引号。<br>单引号字符串的限制：<br>单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；<br>单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。<br>双引号的优点：<br>双引号里可以有变量<br>双引号里可以出现转义字符<br>字符串操作：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">拼接字符串的方式：</span><br><span class="line">your_name=<span class="string">&quot;runoob&quot;</span></span><br><span class="line"><span class="comment"># 使用双引号拼接</span></span><br><span class="line">greeting=<span class="string">&quot;hello, &quot;</span><span class="variable">$your_name</span><span class="string">&quot; !&quot;</span></span><br><span class="line">greeting_1=<span class="string">&quot;hello, <span class="variable">$&#123;your_name&#125;</span> !&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$greeting</span>  <span class="variable">$greeting_1</span></span><br><span class="line"><span class="comment"># 使用单引号拼接，不用使用+号拼接</span></span><br><span class="line">greeting_2=<span class="string">&#x27;hello, &#x27;</span><span class="variable">$your_name</span><span class="string">&#x27; !&#x27;</span></span><br><span class="line">greeting_3=<span class="string">&#x27;hello, $&#123;your_name&#125; !&#x27;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$greeting_2</span>  <span class="variable">$greeting_3</span></span><br><span class="line"></span><br><span class="line">获取字符串长度：</span><br><span class="line"><span class="variable">$&#123;#name&#125;</span></span><br><span class="line">注：变量为数组时，<span class="variable">$&#123;#string&#125;</span> 等价于 <span class="variable">$&#123;#string[0]&#125;</span></span><br><span class="line"></span><br><span class="line">提取子字符串：</span><br><span class="line"><span class="variable">$&#123;name:0:4&#125;</span></span><br><span class="line">注：第一个字符的索引值为 0。</span><br><span class="line"></span><br><span class="line">查找子字符串：</span><br><span class="line">查找字符 i 或 o 的位置：`<span class="built_in">expr</span> index <span class="string">&quot;<span class="variable">$name</span>&quot;</span> io`</span><br></pre></td></tr></table></figure>

<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>bash支持一维数组（不支持多维数组），并且没有限定数组的大小。<br>类似于 C 语言，数组元素的下标由 0 开始编号。获取数组中的元素要利用下标，下标可以是整数或算术表达式，其值应大于或等于 0。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">定义数组：数组名=(值1 值2 ... 值n)</span><br><span class="line"></span><br><span class="line">读取数组：<span class="variable">$&#123;数组名[下标]&#125;</span></span><br><span class="line">注:使用 @ 符号可以获取数组中的所有元素 <span class="built_in">echo</span> <span class="variable">$&#123;array_name[@]&#125;</span></span><br><span class="line"></span><br><span class="line">获取数组的长度：</span><br><span class="line">取得数组元素的个数：</span><br><span class="line"><span class="variable">$&#123;#array_name[@]&#125;</span> 或者</span><br><span class="line"><span class="variable">$&#123;#array_name[*]&#125;</span></span><br><span class="line"></span><br><span class="line">取得数组单个元素的长度</span><br><span class="line">lengthn=<span class="variable">$&#123;#array_name[n]&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><p># 这是一个注释</p>
<p>:&lt;&lt;EOF<br>注释内容…<br>注释内容…<br>注释内容…<br>EOF</p>
<p>注：EOF可以是！等</p>
<h4 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h4><p>可以在执行 Shell 脚本时，向脚本传递参数，脚本内获取参数的格式为：$n<br>注：n 代表一个数字，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数，以此类推……</p>
<blockquote>
<p>$0 为执行的文件名（包含文件路径）<br>几个特殊字符用来处理参数：<br>$#	传递到脚本的参数个数<br>$*	以一个单字符串显示所有向脚本传递的参数。<br>  如”$*”用「”」括起来的情况、以”$1 $2 … $n”的形式输出所有参数。<br>$$	脚本运行的当前进程ID号<br>$!	后台运行的最后一个进程的ID号<br>$@	与$*相同，但是使用时加引号，并在引号中返回每个参数。<br>  如”$@”用「”」括起来的情况、以”$1” “$2” … “$n” 的形式输出所有参数。<br>$-	显示Shell使用的当前选项，与set命令功能相同。<br>$?	显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</p>
</blockquote>
<blockquote>
<p>$* 与 $@ 区别：<br>相同点：都是引用所有参数。<br>不同点：只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，，则 “ * “ 等价于 “1 2 3”（传递了一个参数），而 “@” 等价于 “1” “2” “3”（传递了三个参数）。</p>
</blockquote>
<h4 id="基本运算符"><a href="#基本运算符" class="headerlink" title="基本运算符"></a>基本运算符</h4><p>Shell 和其他编程语言一样，支持多种运算符，包括：<br>算数运算符<br>关系运算符<br>布尔运算符<br>字符串运算符<br>文件测试运算符<br>原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。</p>
<blockquote>
<p>val&#x3D;`expr 2 + 2&#96;<br>echo “两数之和为 : $val”</p>
</blockquote>
<p>注：<br>表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2，这与我们熟悉的大多数编程语言不一样。<br>完整的表达式要被 ` &#96; 包含，注意这个字符不是常用的单引号，在 Esc 键下边。</p>
<ul>
<li>算术运算符：<blockquote>
<p>+	加法	`expr $a + $b` 结果为 30。<br>-	减法	`expr $a - $b` 结果为 -10。<br>*	乘法	`expr $a * $b` 结果为  200。<br>&#x2F;	除法	`expr $b &#x2F; $a` 结果为 2。<br>%	取余	`expr $b % $a` 结果为 0。<br>&#x3D;	赋值	a&#x3D;$b 把变量 b 的值赋给 a。<br>&#x3D;&#x3D;	相等。用于比较两个数字，相同则返回 true。	[ $a &#x3D;&#x3D; $b ] 返回 false。<br>!&#x3D;	不相等。用于比较两个数字，不相同则返回 true。	[ $a !&#x3D; $b ] 返回 true。</p>
</blockquote>
</li>
</ul>
<p>注意：<br>乘号(<em>)前边必须加反斜杠()才能实现乘法运算；<br>在 MAC 中 shell 的 expr 语法是：$((表达式))，此处表达式中的 “</em>“ 不需要转义符号 “&quot; 。</p>
<ul>
<li><p>关系运算符:<br>关系运算符只支持数字，不支持字符串，除非字符串的值是数字</p>
<blockquote>
<p>-eq	检测两个数是否相等，相等返回 true。	[ $a -eq $b ] 返回 false。<br>-ne	检测两个数是否不相等，不相等返回 true。	[ $a -ne $b ] 返回 true。<br>-gt	检测左边的数是否大于右边的，如果是，则返回 true。	[ $a -gt $b ] 返回 false。<br>-lt	检测左边的数是否小于右边的，如果是，则返回 true。	[ $a -lt $b ] 返回 true。<br>-ge	检测左边的数是否大于等于右边的，如果是，则返回 true。	[ $a -ge $b ] 返回 false。<br>-le	检测左边的数是否小于等于右边的，如果是，则返回 true。	[ $a -le $b ] 返回 true。</p>
</blockquote>
</li>
<li><p>布尔运算符</p>
<blockquote>
<p>!	非运算，表达式为 true 则返回 false，否则返回 true。	[ ! false ] 返回 true。<br>-o	或运算，有一个表达式为 true 则返回 true。	[ $a -lt 20 -o $b -gt 100 ] 返回 true。<br>-a	与运算，两个表达式都为 true 才返回 true。	[ $a -lt 20 -a $b -gt 100 ] 返回 false。</p>
</blockquote>
</li>
<li><p>逻辑运算符:</p>
<blockquote>
<p>&amp;&amp;	逻辑的 AND	[[ $a -lt 100 &amp;&amp; $b -gt 100 ]] 返回 false<br>||	逻辑的 OR	[[ $a -lt 100 || $b -gt 100 ]] 返回 true</p>
</blockquote>
</li>
<li><p>字符串运算符:</p>
<blockquote>
<p>&#x3D;	检测两个字符串是否相等，相等返回 true。	[ $a &#x3D; $b ] 返回 false。<br>!&#x3D;	检测两个字符串是否不相等，不相等返回 true。	[ $a !&#x3D; $b ] 返回 true。<br>-z	检测字符串长度是否为0，为0返回 true。	[ -z $a ] 返回 false。<br>-n	检测字符串长度是否不为 0，不为 0 返回 true。	[ -n “$a” ] 返回 true。<br>$	检测字符串是否不为空，不为空返回 true。	[ $a ] 返回 true。</p>
</blockquote>
</li>
<li><p>文件测试运算符:</p>
<blockquote>
<p>-b file	检测文件是否是块设备文件，如果是，则返回 true。	[ -b $file ] 返回 false。<br>-c file	检测文件是否是字符设备文件，如果是，则返回 true。	[ -c $file ] 返回 false。<br>-d file	检测文件是否是目录，如果是，则返回 true。	[ -d $file ] 返回 false。<br>-f file	检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。	[ -f $file ] 返回 true。<br>-g file	检测文件是否设置了 SGID 位，如果是，则返回 true。	[ -g $file ] 返回 false。<br>-k file	检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。	[ -k $file ] 返回 false。<br>-p file	检测文件是否是有名管道，如果是，则返回 true。	[ -p $file ] 返回 false。<br>-u file	检测文件是否设置了 SUID 位，如果是，则返回 true。	[ -u $file ] 返回 false。<br>-r file	检测文件是否可读，如果是，则返回 true。	[ -r $file ] 返回 true。<br>-w file	检测文件是否可写，如果是，则返回 true。	[ -w $file ] 返回 true。<br>-x file	检测文件是否可执行，如果是，则返回 true。	[ -x $file ] 返回 true。<br>-s file	检测文件是否为空（文件大小是否大于0），不为空返回 true。	[ -s $file ] 返回 true。<br>-e file	检测文件（包括目录）是否存在，如果是，则返回 true。	[ -e $file ] 返回 true。</p>
</blockquote>
</li>
</ul>
<h4 id="echo命令"><a href="#echo命令" class="headerlink" title="echo命令"></a>echo命令</h4><p>显示普通字符串:<br>echo “It is a test”<br>显示转义字符<br>echo “&quot;It is a test&quot;“<br>显示变量(标准输入)<br>read 命令从标准输入中读取一行,并把输入行的每个字段的值指定给 shell 变量<br>显示换行:<br>echo -e “OK! \n”  # -e 开启转义<br>显示不换行:<br>echo -e “OK! \c”  # -e 开启转义 \c 不换行<br>显示结果定向至文件:<br>echo “It is a test” &gt; myfile<br>原样输出字符串，不进行转义或取变量(用单引号)：<br>echo ‘$name&quot;‘<br>显示命令执行结果：<br>echo `date&#96;</p>
<h4 id="printf-命令"><a href="#printf-命令" class="headerlink" title="printf 命令"></a>printf 命令</h4><p>printf 使用引用文本或空格分隔的参数，外面可以在 printf 中使用格式化字符串，还可以制定字符串的宽度、左右对齐方式等。默认的 printf 不会像 echo 自动添加换行符，我们可以手动添加 \n。<br>例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span> <span class="string">&quot;%-10s %-8s %-4s\n&quot;</span> 姓名 性别 体重kg  </span><br><span class="line"><span class="built_in">printf</span> <span class="string">&quot;%-10s %-8s %-4.2f\n&quot;</span> 郭靖 男 66.1234</span><br><span class="line"><span class="built_in">printf</span> <span class="string">&quot;%-10s %-8s %-4.2f\n&quot;</span> 杨过 男 48.6543</span><br><span class="line"><span class="built_in">printf</span> <span class="string">&quot;%-10s %-8s %-4.2f\n&quot;</span> 郭芙 女 47.9876</span><br><span class="line">注:</span><br><span class="line">%s %c %d %f 都是格式替代符，％s 输出一个字符串，％d 整型输出，％c 输出一个字符，％f 输出实数，以小数形式输出。</span><br><span class="line">%-10s 指一个宽度为 10 个字符（- 表示左对齐，没有则表示右对齐），任何字符都会被显示在 10 个字符宽的字符内，如果不足则自动以空格填充，超过也会将内容全部显示出来。</span><br><span class="line">%-4.2f 指格式化为小数，其中 .2 指保留2位小数。</span><br></pre></td></tr></table></figure>
<h4 id="test-命令"><a href="#test-命令" class="headerlink" title="test 命令"></a>test 命令</h4><p>数值测试</p>
<blockquote>
<p>-eq	等于则为真<br>-ne	不等于则为真<br>-gt	大于则为真<br>-ge	大于等于则为真<br>-lt	小于则为真<br>-le	小于等于则为真</p>
</blockquote>
<p>字符串测试</p>
<blockquote>
<p>&#x3D;	等于则为真<br>!&#x3D;	不相等则为真<br>-z 字符串	字符串的长度为零则为真<br>-n 字符串	字符串的长度不为零则为真</p>
</blockquote>
<p>文件测试</p>
<blockquote>
<p>-e 文件名	如果文件存在则为真<br>-r 文件名	如果文件存在且可读则为真<br>-w 文件名	如果文件存在且可写则为真<br>-x 文件名	如果文件存在且可执行则为真<br>-s 文件名	如果文件存在且至少有一个字符则为真<br>-d 文件名	如果文件存在且为目录则为真<br>-f 文件名	如果文件存在且为普通文件则为真<br>-c 文件名	如果文件存在且为字符型特殊文件则为真<br>-b 文件名	如果文件存在且为块特殊文件则为真</p>
</blockquote>
<h4 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h4><ul>
<li><p>分支：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> condition</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    command1 </span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN </span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> condition</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    command1 </span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">command</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> condition1</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    command1</span><br><span class="line"><span class="keyword">elif</span> condition2 </span><br><span class="line"><span class="keyword">then</span> </span><br><span class="line">    command2</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    commandN</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>注:<br>if else 的 […] 判断语句中大于使用 -gt，小于使用 -lt。<br>如果使用 ((…)) 作为判断语句，大于和小于可以直接使用 &gt; 和 &lt;。</p>
</li>
<li><p>循环<br>for 循环：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> item1 item2 ... itemN</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>while 语句:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> condition</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">command</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>until 循环:<br>until 循环执行一系列命令直至条件为 true 时停止。<br>until 循环与 while 循环在处理方式上刚好相反。<br>一般 while 循环优于 until 循环，但在某些时候—也只是极少数情况下，until 循环更加有用。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">until</span> condition</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">command</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>跳出循环：break 或 continue</p>
</li>
<li><p>选择</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> 值 <span class="keyword">in</span></span><br><span class="line">模式1)</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">    ;;</span><br><span class="line">模式2)</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">    ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">function</span>] funname [()]</span><br><span class="line">&#123;</span><br><span class="line">    action;</span><br><span class="line">    [<span class="built_in">return</span> int;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数参数：<br>传递：funname 1 2 3 4 5 6 7 8 9 34 73<br>获取参数的值：$n<br>几个特殊字符用来处理参数：</p>
<blockquote>
<p>$#	传递到脚本或函数的参数个数<br>$*	以一个单字符串显示所有向脚本传递的参数<br>$$	脚本运行的当前进程ID号<br>$!	后台运行的最后一个进程的ID号<br>$@	与$*相同，但是使用时加引号，并在引号中返回每个参数。<br>$-	显示Shell使用的当前选项，与set命令功能相同。<br>$?	显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</p>
</blockquote>
<h4 id="输入-x2F-输出重定向"><a href="#输入-x2F-输出重定向" class="headerlink" title="输入&#x2F;输出重定向"></a>输入&#x2F;输出重定向</h4><blockquote>
<p>command &gt; file	将输出重定向到 file。<br>command &lt; file	将输入重定向到 file。<br>command &gt;&gt; file	将输出以追加的方式重定向到 file。<br>n &gt; file	将文件描述符为 n 的文件重定向到 file。<br>n &gt;&gt; file	将文件描述符为 n 的文件以追加的方式重定向到 file。<br>n &gt;&amp; m	将输出文件 m 和 n 合并。<br>n &lt;&amp; m	将输入文件 m 和 n 合并。<br>&lt;&lt; tag	将开始标记 tag 和结束标记 tag 之间的内容作为输入。</p>
</blockquote>
<h4 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h4><p>Shell 也可以包含外部脚本。这样可以很方便的封装一些公用的代码作为一个独立的文件<br>语法：<br>. filename   # 注意点号(.)和文件名中间有一空格<br>或<br>source filename</p>
<hr>
<p>🤡END</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Java入门</title>
    <url>/posts/f7ede91d.html</url>
    <content><![CDATA[<h3 id="基础语法："><a href="#基础语法：" class="headerlink" title="基础语法："></a>基础语法：</h3><h5 id="1、Java源文件与字节码文件："><a href="#1、Java源文件与字节码文件：" class="headerlink" title="1、	Java源文件与字节码文件："></a>1、	Java源文件与字节码文件：</h5><p>源文件.java<br>字节码文件.class<br>注：Java源文件中包含N个类则编译生成N个class文件。</p>
<h5 id="2、java、javac命令、环境变量："><a href="#2、java、javac命令、环境变量：" class="headerlink" title="2、	java、javac命令、环境变量："></a>2、	java、javac命令、环境变量：</h5><p>Cd：下一级文件夹<br>cd…:上一级文件夹<br>编译：javac java的文件<br>运行：java 文件<br>执行：文件名<br>基本命令：javac：Java编译器   java:Java解释器  jdb:java调试器  javap:反编译   javadoc:文档生成器   appletviwer:applet解释器</p>
<h5 id="3、关键字："><a href="#3、关键字：" class="headerlink" title="3、关键字："></a>3、关键字：</h5><p>class、abstract表明是抽象的、package、import导入、extends继承、implements实现接口、static静态的、void无返回值、<br>final最终不可改、interface定义接口、super调用父类、this、return、new、private 私有的、instanceof 判断对象</p>
<h5 id="4、main方法："><a href="#4、main方法：" class="headerlink" title="4、main方法："></a>4、main方法：</h5><p>定义、作用：程序运行的入口</p>
<h5 id="5、标识符命名规则："><a href="#5、标识符命名规则：" class="headerlink" title="5、标识符命名规则："></a>5、标识符命名规则：</h5><p>约定：字母小写、类与接口单词首字母大写、常量大写单词用_隔开、变量与方法第一个单词首字母小写，后面的单词首字母大写<br>规则：第一个字母以字母、下划线、$开头</p>
<h5 id="6、数据类型：基本数据类型与引用数据类型"><a href="#6、数据类型：基本数据类型与引用数据类型" class="headerlink" title="6、数据类型：基本数据类型与引用数据类型"></a>6、数据类型：基本数据类型与引用数据类型</h5><p>（1）基本数据类型对应的封装类型：Byte Short Interger….<br>（2）byte类型的范围[-128,127]   byte b&#x3D;127;  b++为多少？-128<br>（3）boolean（true与false）<br>（4）分类：<br>自动类型转换(小转大）：byte&lt;short、char&lt;int&lt;long&lt;float&lt;double<br>强制类型转换(大转小)：目标类型 变量名&#x3D;(目标类型)值<br>（5）String与数值型的转换</p>
<h5 id="7、运算符："><a href="#7、运算符：" class="headerlink" title="7、	运算符："></a>7、	运算符：</h5><p>（1）	&#x2F; 与 %    1&#x2F;2 、 1.0&#x2F;2、  1%2<br>（2）	a++（先其他后自增）与++a（先自增后其他）a- -（先其他后自减）与- -a（先自减后其他）<br>（3）	&amp;&amp;与&amp;、||与|<br>（4）	优先级别：括号 &gt; 算术 &gt; 关系(&lt;&lt; &gt;&gt; &gt;&gt;&gt; &lt; &gt; &lt;&#x3D; &gt;&#x3D; &#x3D;&#x3D; ¡&#x3D;) &gt; 逻辑(&amp; ^ | &amp;&amp; || ?: ) &gt; 赋值</p>
<h5 id="8、流程控制："><a href="#8、流程控制：" class="headerlink" title="8、	流程控制："></a>8、	流程控制：</h5><p>（1）顺序结构<br>（2）选择结构（分支）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(控制表达式（不能为Boolean类型）)&#123;</span><br><span class="line"><span class="keyword">case</span> 目标值：</span><br><span class="line">    执行语句</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">…</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（3）循环结构</p>
<blockquote>
<p>1.while(条件){执行语句}<br>2.Do {执行语句}while(条件)<br>3.For(初始表达式;循环条件;操作表达式){执行语句}<br>4.For(元素类型 变量名:数组名或集合名)<br>jdk5.0之后的新特性，叫做增强for循环或foreach</p>
</blockquote>
<p>注：if…else…:配对就近原则<br>循环结构中，break与continue的作用：<br>Break:跳出当前循环结构；<br>continue:终止本次循环，执行下一次循环；</p>
<h5 id="9、数组："><a href="#9、数组：" class="headerlink" title="9、	数组："></a>9、	数组：</h5><p>数组是引用数据类型，数组的父类是object<br>Main方法的string[] args数组的作用：接收用户输入的参数，形成数组中元素<br>Object[ ] ：可装任何数据类型的元素<br>常见算法：（面试时可能会用到）：冒泡排序法、选择排序法、二分法查找<br>（1）一维数组的定义与引用、下标从0到length-1（数组下标越界异常）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">类型[] 名=<span class="keyword">new</span> 类型[长度]（动态初始化数组）Int[] arr=<span class="keyword">new</span> <span class="title class_">Int</span>[<span class="number">10</span>]</span><br><span class="line">类型[] 名=<span class="keyword">new</span> 类型[]&#123;元素<span class="number">1</span>,元素<span class="number">2</span>&#125;（静态初始化数组）Int[] arr=<span class="keyword">new</span> <span class="title class_">Int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">类型[] 名=&#123;元素<span class="number">1</span>，元素<span class="number">2</span>&#125;   Int[] arr=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>
<p>（2）数组操作的常用方法：<br>Arrays.方法(数组名)：使用前需导入Arrays类<br>数组的遍历toString()<br>比较相等equals()<br>排序sort()<br>二分查找binarySearch()<br>填充fill()<br>（3）二维数组的定义和引用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">类型[][] 名=<span class="keyword">new</span> 类型[行数][列数]  Int[][] arr=<span class="keyword">new</span> <span class="title class_">Int</span>[<span class="number">2</span>][<span class="number">3</span>]</span><br><span class="line">类型[][] 名=&#123;&#123;数组<span class="number">1</span>&#125;,&#123;数组<span class="number">2</span>&#125;,&#123;数组<span class="number">3</span>&#125;&#125;  Int[][]  arr=&#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5.6</span>&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>（4）数组的优点：<br>检索效率高：内存地址连续、元素类型相同、通过数学表达式计算某个下标上元素的内存地址，从而定位元素。<br>缺点：随机增删元素效率比较低。数组无法存储大数据量</p>
<h5 id="10、字符串"><a href="#10、字符串" class="headerlink" title="10、字符串"></a>10、字符串</h5><p>（1）字符串比较：&#x3D;&#x3D;    equals<br>（2）常用方法：length()、substring(m,n)、split()</p>
<h5 id="11、生成随机数的方法："><a href="#11、生成随机数的方法：" class="headerlink" title="11、生成随机数的方法："></a>11、生成随机数的方法：</h5><p>Math.random()     [0，1)  </p>
<h3 id="二、类与对象"><a href="#二、类与对象" class="headerlink" title="二、类与对象"></a>二、类与对象</h3><h5 id="1、面向对象的三大特征："><a href="#1、面向对象的三大特征：" class="headerlink" title="1、	面向对象的三大特征："></a>1、	面向对象的三大特征：</h5><p>封装、继承、多态</p>
<h5 id="2、类与对象的关系："><a href="#2、类与对象的关系：" class="headerlink" title="2、	类与对象的关系："></a>2、	类与对象的关系：</h5><p>类是对象的抽象,对象是类的具体化。</p>
<h5 id="3、类的基本构成："><a href="#3、类的基本构成：" class="headerlink" title="3、	类的基本构成："></a>3、	类的基本构成：</h5><p>成员方法和成员变量，局部变量（方法体之内）与成员变量（方法体之外，类之内）的区别</p>
<h5 id="4、访问修饰符："><a href="#4、访问修饰符：" class="headerlink" title="4、	访问修饰符："></a>4、	访问修饰符：</h5><p>public(同类同包子类全局)、proctected保护的(同类同包子类)、private私有的(同类)、default缺省(同类同包)<br>访问级别：private  &lt;  default  &lt;  protected  &lt;  public<br>注：类只能用public与default修饰（内部类除外）</p>
<h5 id="5、方法："><a href="#5、方法：" class="headerlink" title="5、	方法："></a>5、	方法：</h5><p>（1）	方法的定义：修饰符 返回值类型 方法名(参数类型){方法体；return 返回值；}<br>（2）构造方法（构造函数、构造器）：<br>作用：创建对象的同时，初始化实例变量（即赋值）<br>特点：方法名与类名相同、没有返回值类型、不能用return返回值，可以return结束方法<br>何时被调用：new构造方法名()<br>（3）方法的重载与重写（覆盖）：与方法的返回值类型和修饰符列表无关 重载的方法与原方法参数列表与方法体不同，其他相同<br>（4）方法的调用：<br>没有static的，叫实例方法，先创建new引用，再引用.方法名(实参)调用<br>静态方法的调用：类名.方法名(实参)</p>
<h5 id="6、final、static、super、this关键字的作用："><a href="#6、final、static、super、this关键字的作用：" class="headerlink" title="6、	final、static、super、this关键字的作用："></a>6、	final、static、super、this关键字的作用：</h5><p>this：<br>代表此时正在实行的对象<br>只能在构造方法使用this调用其他构造方法，不能在成员方法或带有static的方法中使用。<br>This调用语句需要在第一条<br>Static：<br>所有对象都有的属性，可以定义为静态变量。<br>Static只能用来修饰成员变量，不能修饰局部变量<br>使用类名.变量名&#x2F;方法名来调用<br>静态代码块：static{…}<br>在类加载时执行，只执行一次，自上而下依次执行<br>Super：<br>调用父类的成员变量与成员方法<br>调用父类方法：Super.父类方法()<br>调用父类的构造方法：super(参数1,参数2)<br>Final：<br>final修饰的类不能被继承。<br>final修饰的方法不能被子类重写。<br>final修饰的成员变量（声明的同时必须赋值）与局部变量（声明并赋值，声明后赋值）是常量，只能赋值一次</p>
<h5 id="7、继承："><a href="#7、继承：" class="headerlink" title="7、	继承："></a>7、	继承：</h5><p>特点：<br>类只支持单继承，不支持多继承。接口可以多继承。<br>注意：<br>重写的方法只有方法体、访问修饰符与被重写的方法不同<br>重写后，子类无法访问被重写的父类方法<br>重写的方法不能使用比被重写的方法低的访问修饰符等级<br>注：Object类：所有类的父类，当定义一个类时，没有使用extends时，默认继承object类</p>
<h5 id="8、抽象类与接口"><a href="#8、抽象类与接口" class="headerlink" title="8、	抽象类与接口"></a>8、	抽象类与接口</h5><p>（1）均不能使用new实例化<br>（2）接口是特殊的抽象类，JDK8以前版本中，接口只能包含公共常量和抽象方法；之后的版本还可以包含默认方法和静态方法。<br>（3）一个类实现接口就必须实现接口中的所有方法。<br>（4）一个类可以同时实现多个接口。Implements<br>抽象类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 <span class="keyword">abstract</span> class类名&#123;</span><br><span class="line">    抽象方法：修饰符 <span class="keyword">abstract</span> 返回值类型 方法名()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 interface 接口名 [extends 父接口<span class="number">1</span>,父接口<span class="number">2</span>…]&#123;</span><br><span class="line">    公共常量：<span class="type">int</span> 变量名=值:</span><br><span class="line">    抽象方法：<span class="keyword">void</span> 方法名();</span><br><span class="line">    默认方法：<span class="keyword">default</span> <span class="keyword">void</span> 方法名()&#123;&#125;</span><br><span class="line">    静态方法：<span class="keyword">static</span> 数据类型 方法名()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类实现继承与接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 <span class="keyword">class</span> <span class="title class_">extends</span> 父类名 implements 接口<span class="number">1</span>,接口<span class="number">2</span>&#123;</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：当一个类实现接口，若此类是抽象类，只需要实现接口部分抽象方法，其他类则需要实现全部接口的所有抽象方法。</p>
<h5 id="9、多态性："><a href="#9、多态性：" class="headerlink" title="9、	多态性："></a>9、	多态性：</h5><p>（1）向上转型：子转父</p>
<blockquote>
<p>父类 引用&#x3D;new 子类();</p>
</blockquote>
<p>引用.方法名()<br>注：此处调用的方法为子类的方法<br>（2）向下转型：父转子<br>子类 子类的引用&#x3D;(子类) 父类的引用<br>注：关键字instanceof：可判断一个对象是否为某类的实例或子类实例。<br>语法格式：</p>
<blockquote>
<p>对象（或者对象的引用） instanceof 类（或接口）  运行结果为布尔类型</p>
</blockquote>
<p>注意：<br>子类对象可以直接赋值给父类引用<br>父类对象不能直接赋值给子类对象，必须强制还原，并且只是上转型对象才能被还原<br>类型转换的大前提：两种类型之间必须有继承关系</p>
<h5 id="10、内部类："><a href="#10、内部类：" class="headerlink" title="10、内部类："></a>10、内部类：</h5><p>分类：静态内部类、实例内部类、局部内部类</p>
<h5 id="11、异常处理："><a href="#11、异常处理：" class="headerlink" title="11、异常处理："></a>11、异常处理：</h5><p>常见异常：空指针异常、类型转换异常、数组下标越界异常、数字格式化异常<br>（1）try…catch和finally ：可包含多个catch ，捕获处理异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    可能发生异常的语句</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception类或其子类 e)&#123;</span><br><span class="line">    处理语句</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    不管是否发生异常，都执行<span class="keyword">finally</span>的语句，可以用来执行重要的关闭代码（除非<span class="keyword">try</span>…<span class="keyword">catch</span> 中执行了System.exit(<span class="number">0</span>)语句，即退出当前的Java虚拟机，<span class="keyword">finally</span>语句也不执行）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（2）throw ：手动抛出异常，用在方法体内，抛出一个异常类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数类型 参数名)<span class="keyword">throws</span> 抛出的异常类&#123;</span><br><span class="line">    方法体</span><br><span class="line">    Throw <span class="keyword">new</span> <span class="title class_">Exception</span>类或其子类构造方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（3）throws：声明抛出异常,用在方法名的后面，指明方法可能抛出多个异常<br>注意：子类不能比父类抛出更多的异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数类型 参数名)<span class="keyword">throws</span> 抛出的异常类&#123;</span><br><span class="line">    方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（4）自定义异常类：第一步，继承Exception或RuntimeException;第二步，提供一个无参和一个有String参数的构造方法<br>（5）异常对象两个重要方法：<br>String msg&#x3D;exception.getMessage():获取异常的简单的描述信息<br>Exception.printStackTrace():Java后台打印异常堆信息</p>
<h5 id="12、Java的常用类"><a href="#12、Java的常用类" class="headerlink" title="12、Java的常用类"></a>12、Java的常用类</h5><p>（1）Object类：所有类的根类<br> Tostring方法：返回对象的字符串形式，使用时建议重写<br> Equals方法：默认比较两个对象的内存地址是否相等，要比较对象的内容时，必须重写<br> Finalize方法：在对象即将被垃圾回收器回收时执行，垃圾少或小时可能不执行也可能执行<br> GC负责调用finalize方法<br> System.gc();建议启动垃圾回收器<br>（2）	String类：<br>注意：“字符串”.方法()<br>常用方法：使用引用.方法名（）进行调用</p>
<blockquote>
<p>char charAt(int index):返回字符串中index下标的字符<br>int compareTo(string anotherString):按字典顺序比较字符串的大小（0相等、1前大后小、-1前小后大，只比较第一个字符）<br>Boolean contains(CharSequence cs):判断该字符串是否包含指定字符序列<br>Boolean endsWith(String suffix):判断当前字符串是否以某字符串结尾<br>Boolean equalsIgnoreCase(String anotherString):判断两个字符串是否相等，忽略大小写<br>Byte getByte():将字符串转换成字节数组<br>Char[] toCharArray():将字符串转换成char数组<br>Int indexOf(String str):判断某个字符串在当前字符串中第一次出现的下标<br>Boolean isEmpty():判断某个字符串是否为空，length（）为0时返回true<br>Int LastIndexOf(String str):判断某个字符串在当前字符串中最后一次出现的下标<br>String replace(CharSequence target,CharSequence replacement):将字符target替换为replacement<br>String[] split(String regex):以regex为分隔拆分字符串<br>Boolean startsWith(String prefix):判断某个字符串是否以某个字符串开始<br>String substring(int beginIndex，int endindex):从beginindex（包括）开始,endIndex（不包括）结束截取字符串<br>String toLowerCase():转换成小写<br>String toUpperCase():转换成大写<br>String trim():去除字符串前后空白，中间空白不可以</p>
</blockquote>
<p>静态方法：类名.valueOf(非字符串)：将非字符串转换成字符串<br>（3）Stringbuffer类：是线程安全的<br>（4）StringBuilder类：是非线程安全的<br>（5）Number类：是一个抽象类，是数字类型（int、short…）包装类的父类<br> 装箱：基本数据类型—》引用数据类型<br> 拆箱：引用数据类型—》基本数据类型   number的公共方法进行操作<br> 包装类的重要静态方法：包装类名.parseInt(String s)<br>-128~127数值范围的数据在创建数据类型的包装类时，方法区的整数型常量池中已经有了256个对象，因此如果比较是否相等时，是true<br>（6）System类：System.gc():建议启动gc垃圾回收器<br>System.exit():退出jvm<br>System.currentTimeMillis():获取自1970年1月1日00：00：00到当前系统时间的总毫秒数<br>（7）日期类<br>Date()：在Date包，使用前需导包，获取当前系统时间<br>Date(int hms):参数是毫秒数，用于计算从1970加hms的时间<br>SimpleDateFormat:text包下的，专门负责日期格式化   引用.format(Date的引用)<br>特定格式：yyyy年  MM月  dd日  HH时  mm分  ss秒  SSS毫秒<br>日期字符串String转Date:  Date SimpleDateFormat的引用.parse(String s)   格式需一致<br>System.currentTimeMillis():获取自1970年1月1日00：00：00到当前系统时间的总毫秒数    可用于计算一个方法执行的总毫秒数<br>（8）枚举：是引用数据类型，可以作为返回值，并创建多个枚举值</p>
<h5 id="13、集合"><a href="#13、集合" class="headerlink" title="13、集合"></a>13、集合</h5><p>注意：集合类和集合接口都在Java.util包下<br>（1）集合概述：集合实际上是一个容器或一个对象，可以容纳其他类型的数据。集合不能直接储存基本数据类型和Java对象。集合当中存储的是Java对象的内存地址或者说引用。<br>（2）Collection接口：<br>存储元素：<br>在没有使用泛型之前，collection中可以存储object的所有子类型，使用泛型后，只能存储某个具体的类型。<br>泛型：<br>泛型只在程序编译阶段起作用，运行阶段没用，只能存储某个具体的类型<br>泛型的优点：<br>集合的元素类型统一了、取出类型是指定类型，所以不需要进行大量的“向下转型”、调用多个子类的 父类方法时，不需转型<br>泛型的缺点：存储的元素缺乏多样性<br>常见方法：</p>
<blockquote>
<p>Boolean add(Object e) 向集合中添加元素<br>Int size() 获取集合中元素的个数<br>Void clear() 清空集合<br>Boolean contains(Object o) 判断当前集合是否包含o元素<br>Contains在底层string重写了equals方法，比较的是内容<br>Boolean remove(Object o) 删除o元素<br>Remove在底层也调了equals方法，删除的是内容<br>Boolean isEmpty() 判断集合是否为空<br>bject[] toArray() 将集合转换成数组（使用不多）<br>Iterator迭代器（是一个对象）：Iterator it(引用)&#x3D; c(collection对象的引用).iterator()</p>
</blockquote>
<blockquote>
<blockquote>
<p>注意：集合结构一但发生变化，迭代器必须重新获取<br>   迭代过程中，使用迭代的引用来增删元素<br>方法：可使用while循环来迭代</p>
</blockquote>
</blockquote>
<blockquote>
<p>Boolean hasNext() 如果仍有元素可以迭代，则返回true<br>Object next() 返回迭代的下一个元素</p>
</blockquote>
<p>（3）List接口  有序可重复<br>List 的特有常见方法：</p>
<blockquote>
<p>void add(int index,Object element) 在元素的指定下标插入指定元素<br>Object set(int index,Object element) 修改指定下标的元素<br>Object get(int index) 根据下标获取元素<br>Int intdexOf(Object o) 获取指定对象第一次出现的下标<br>Int lastIntdexOf(Object o) 获取指定对象最后一次出现的下标<br>Object remove(int index) 删除指定下标的元素<br>boolean add(E e) 将指定的元素添加到此列表的尾部。<br>void add(int index, E element) 将指定的元素插入此列表中的指定位置。<br>boolean addAll(Collection&lt;? extends E&gt; c) 按照指定 collection 的迭代器所返回的元素顺序，将该 collection 中的所有元素添加到列表的尾部。<br>boolean contains(Object o) 如果此列表中包含指定的元素，则返回 true。<br>void ensureCapacity(int minCapacity) 如有必要，增加此 ArrayList 实例的容量，以确保它至少能够容纳最小容量参数所指定的元素数。<br>E get(int index) 返回此列表中指定位置上的元素。<br>int indexOf(Object o) 返回此列表中首次出现的指定元素的索引，或如果此列表不包含元素，则返回 -1。<br>boolean isEmpty() 如果此列表中没有元素，则返回 true<br>int lastIndexOf(Object o) 返回此列表中最后一次出现的指定元素的索引，或如果此列表不包含索引，则返回 -1。<br>E remove(int index) 移除此列表中指定位置上的元素。<br>E set(int index, E element) 用指定的元素替代此列表中指定位置上的元素。<br>int size() 返回此列表中的元素数。<br>Object[] toArray() 按适当顺序（从第一个到最后一个元素）返回包含此列表中所有元素的数组。<br><T> T[] toArray(T[] a) 按适当顺序（从第一个到最后一个元素）返回包含此列表中所有元素的数组；返回数组的运行时类型是指定数组的运行时&gt;类型。<br>void trimToSize() 将此 ArrayList 实例的容量调整为列表的当前大小。</p>
</blockquote>
<p><em>ArrayList集合</em>：<br>初始化容量为10（先创建一个长度为0的数组，当第一个元素加入时，初始化容量为10）。集合底层是一个Object类型组。扩容增长到原容量的1.5倍。<br><em>Vector集合</em>：<br>初始化容量为10，集合底层是一个Object类型，扩容增长到原容量的2倍。所有方法都是线程同步的（带有syncnronized关键字），但效率较低<br><em>LinkedList集合</em><br>链表：基本单元是节点，节点都有两个属性：存储的数据、下一个节点的内存地址。链表的元素在空间存储上。内存地址不连续<br>分为两类：单向链表和双向链表<br>链表的优点：随机增删元素的效率比较高（因为不涉及大量元素的位移）<br>链表的缺点：查询效率比较低，每次查找都需从头节点开始往下遍历<br>（4）Set接口<br><em>HashSet集合</em>：底层实际上new了一个HashMap集合。向HashSet集合存储元素，实际上是存储到了HashMap集合中	<br><em>TreeSet集合</em>: 继承ShortedSet接口（ShortedSet接口继承Set接口）底层实际上是一个TreeMap。无序不可重复可排序（按字典顺序升序）<br>无法对自定义类型进行排序，因为没有实现Java.lang.Comporable接口<br>要想做到排序包括两种方式：<br>第一，实现Java.lang.Comporable接口（建议当比较规则不会发生改变或只有一个时使用）<br>第二，在构造TreeSet集合的时候给它传一个比较器对象（建议当比较规则多个，并且需要频繁切换比较规则时使用）<br>（5）Map接口<br>Map与Collection没有继承关系。无序不可重复<br>常用方法：<br>V put(K key , V value) 向Map集合中添加键值对<br>V get(Object key) 通过key获取value</p>
<blockquote>
<p>Void clear()  清空Map集合<br>Boolean containsKey(Object key) 判断Map中是否包含某个key<br>Boolean containsValue(Object key) 判断Map中是否包含某个value<br>Boolean isEmpty()  判断Map集合中的元素个数是否为0<br>Set<K> keyset()  获取Map集合所有的key，所有键是一个Set集合<br>V remove(Object key)  通过key删除键值对<br>Int size()  获取Map集合中键值对的个数<br>Collection<V> value()  获取Map集合中所有的value，返回一个Collection类型<br>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() 将Map集合转换成Set集合</p>
<blockquote>
<p>注：Map.Entry&lt;K,V&gt;是一个类型</p>
</blockquote>
</blockquote>
<p><em>HashMap集合</em>：<br>默认初始化容量是16，默认加载因子是0.75（容量达到75%，数组开始扩容，扩容增长到原容量的2倍。）<br>初始化容量必须是2的倍数。非线程安全的<br>常见方法：map.put(k,v)  放   v&#x3D;map.get(k)  取<br><em>Hashtable集合</em>：<br>初始化容量为11，默认加载因子是0.75（容量达到75%，数组开始扩容，扩容增长到（原容量*2）+1）。线程安全的<br><em>Properties集合</em>：<br>一个Map集合，继承Hashtable，因此是线程安全的。Properties的key和value都是String类型。<br>常见方法：引用.setProperty(k,v)  存   引用.getProperty(k)  取<br><em>TreeMap集合</em>：<br>继承SortedMap接口（SortedMap接口继承Map接口，是无序不可重复可自动排序的）<br>哈希表：<br>哈希表是数组和单向链表二者优点的结合体<br>放在HashMap集合key部分的元素，以及放在HashSet集合中的元素，需要同时重写hashCode()和equals()方法<br>Hash值相同放在同一个单向链表里<br>常见方法：map.put(k,v)  放   v&#x3D;map.get(k)  取<br>自平衡二叉树：<br>遵循左小右大原则存放<br>遍历的三种方式：<br>前序遍历：根左右<br>中序遍历：左根右<br>后序遍历：左右根<br>注：前中后指的是根的位置，根也就是交叉的节点</p>
<h5 id="14、IO流"><a href="#14、IO流" class="headerlink" title="14、IO流"></a>14、IO流</h5><p>(1)	概述：I：Input O：Output  通过IO可以完成硬盘文件的读与写<br>(2)	分类：<br>按流的方向：<br>往内存去叫输入&#x2F;读（read）<br>从内存出叫输出&#x2F;写（write）<br>按读取数据方式：<br>万能流：可读文本，图片，声音，视频…<br>字符流：可读纯文本<br>(3)	常见的方法：<br>引用.readline()   读一行，不换行<br>close() 用完流一定要关闭<br>flush() 输出流可以执行该方法清空管道<br>(4)	字节流与字符流：字节流：以Stream结尾   字符流：以Reader&#x2F;writer结尾<br>a)	四个抽象类<br>字节输入流：Java.io.InputStream<br>字节输出流：Java.io.OutputStream<br>字符输入流：Java.io.Reader<br>字符输出流：Java.io.Writer<br>b)	File类：<br>常用方法：</p>
<blockquote>
<p>引用.exists()   判断文件是否存在<br>引用.createNewFile()  以文件形式新建<br>引用.mkdir()   以目录形式新建  引用.mkdirs()   以多重目录形式新建<br>引用.getParent()   获取文件的上级路径<br>引用.getName()   获取文件名	<br>引用.isDirectory()   判断是否是一个目录<br>引用.isFile()   判断是否是一个文件<br>引用.LastModified()  获取文件最后一次修改时间<br>引用.length()   获取文件的大小（字节）<br>引用.ListFiles()   获取当前目录下的所有的子文件</p>
</blockquote>
<p>c)	16个常见的流：（使用前要创建对象）<br>d)	获取一个文件的绝对路径（通用）：<br>直接以流的形式返回：InputStream in&#x3D;Thread.currentThread().getContextClassLoader().getResourceAsStream(“src下的相对路径”)<br>e)	资源绑定器（java.util.ResourceBundle）：ResourceBundle.getBundle(“xxx”)<br>便于获取属性配置文件的内容<br>注：只能绑定xxx.properties文件，且文件必须放在类路径(src)下，括号内路径后的扩展名不能写<br><em>文件专属</em>：<br>FileInputStream类：<br>常用方法：</p>
<blockquote>
<p>int read() 返回一个数据字节，如果以达到文件末尾，则返回-1<br>Int read(byte[] b) 将最多b.length个字节的数据读入一个byte数组中<br>int available() 返回流当中剩余的没有读到的字节数量<br>Long skip(long n) 跳过几个字节不读</p>
</blockquote>
<p>FileOutputStream类:文件字节输出流，从内存到硬盘<br>常见方法：</p>
<blockquote>
<p>FileOutputStream(“文件路径”)  先将原文件清空，再重新写入<br>FileOutputStream(“文件路径”,Boolean append) append为true时在文件末尾写入，不会清空文件。<br>FileReader类：文件字符输入流，只能输出普通文本，word文件不可以<br>FileWriter类：文件字符输出流，只能输出普通文本，word文件不可以</p>
</blockquote>
<p><em>缓冲流专属</em>：<br>BufferedReader类：自带缓冲区的字符输入流，不需要自定义char数组<br>节点流：当一个流的构造方法里传进一个流时，这个传进来的流就是节点流。<br>包装流：外部负责包装的流，就是包装流&#x2F;处理流<br>包装流只需关闭最外层流就行，里面的节点流会自动关闭<br>BufferedWeiter类：自带缓冲区的字符输出流<br><em>转换流</em>：<br>InputStreamReader类：转换流<br>OutputStreamWriterr类：转换流<br><em>数据流专属</em>：<br>DataOutputStream类：将数据连同数据类型一并写入文件。这个文件不是普通文本文件，读的顺序必须与写的顺序一致<br>DataInputStream类<br><em>标准输出流</em>：<br>PrintWreter类<br>PrintStrem类：标准的字节输出流，默认输出到控制台，不需要手动关闭流<br>设置输出方向：System.setOut(new PrintStream(new FileOutputStream(目标文件)))<br><em>对象专属流</em>：<br>ObjectOutputStream类：负责序列化<br>ObjectInputStream类：负责反序列化<br>(5)	序列：<br>序列化：Serialize Java对象存储到文件中，将Java对象的状态保存下来的过程。<br>反序列化：DeSerialize 将硬盘上的数据重新恢复到内存当中，恢复成Java对象<br>Transient关键字表示游离的，不参与序列化<br>注意：参与序列化与反序列化的对象，必须实现Serializable接口<br>Serializable接口：里面没有代码，其标识的作用，jvm在看到这个接口后，<br>会为该类自动生成一个序列化版本号（可用于区分类，建议手动生成）<br>(6)	IO+Properties的联合使用<br>设计理念：经常改变的数据，可以单独写到一个文件中，使用程序动态获取。<br>只需要修改文件的内容，Java代码不需要改变。<br>配置文件：以上机制的这种文件被称为配置文件<br>属性配置文件：当配置文件的内容格式为：key&#x3D;value时，称为属性配置文件<br>建立以.properties作为后缀名，但不是必须的<br>注：#是注释   key重复value自动覆盖<br>Properties：专门存放属性配置文件内容的一个类</p>
<h5 id="15、线程"><a href="#15、线程" class="headerlink" title="15、线程"></a>15、线程</h5><p>（1）	进程与线程<br>进程：是一个应用程序（一个进程是一个软件），一个进程可以启动多个线程<br>线程：是一个进程中的执行场景&#x2F;执行单元<br>（2）Java的线程：堆内存与方法区内存共享，但是栈内存独立，互不干扰，一个线程一个栈，这就是多线程并发（可以提高效率）<br>（3）实现线程：<br>(a)	第一种方式：编写一个类直接继承Thread，并重写run方法<br>步骤：创建线程对象：直接new<br>启动线程：调用线程对象的start方法，启动成功后分支线程会自动调用run方法，并且run方法在栈底部（run与main平级）<br>注：分支线程与主线程并发执行<br>Start方法的作用：启动一个分支线程，在jvm开辟一个新的栈空间<br>单线程：直接在主栈中调用线程对象的run方法的方式就叫单线程<br>(b)	第二种方式：编写一个类实现Runnable接口<br>步骤：<br>定义一个可运行的类（实现Runnable接口）<br>创建线程对象：new Thread(new 可运行类())<br>启动线程<br>上述两种方法的执行结果：主支线程有前有后，有多有少<br>(c)	线程的生命状态<br>新建状态、就绪状态、运行状态、阻塞状态、死亡状态<br>（4）常见方法：<br>设置线程名字：引用.setName()<br>获取线程名字：引用.getNmae()<br>静态方法：<br>获取当前线程对象的名字：Thread.currentThread()<br>睡眠：Thread.sleep(long millis)  参数是毫秒，作用：让当前线程进入休眠（进入阻塞状态），可用于间隔特定的时间，去执行一段特定的代码，每隔多久执行一次<br>终断线程睡眠：引用.interrupt();   干扰睡眠（依赖Java的异常处理机制）<br>在想要终止的线程里，设置一个Boolean变量与if…else来控制<br>线程的终止<br>（5）线程的调度<br>抢占式调度模型：哪个线程的优先级比较高，抢到的cpu时间片的概率就高一些。（Java采用这种方式）<br>均分式调度模型：平均分配cpu时间片，每个线程占有的cpu时间片一样有关方法：<br>实例方法：<br>void setPriority(int newPriority)   设置线程的优先级（最低1，默认5，最高10）<br>Int getPriority()  获取线程优先级<br>Void join()  合并线程，当前线程进入阻塞，调此方法的线程执行，等它结束，当前线程才可重新执行<br>静态方法：<br>static void yield()  让位方法，暂停当前正在执行的线程对象，回到就绪状态，并执行其他线程<br>（6）线程的安全：<br>a)	存在线程安全问题的条件：多线程并发、有共享数据、共享数据有修改行为<br>b）	解决线程安全问题：<br>方案一：尽量使用局部变量代替实例变量和静态变量<br>方案二：如果必须是实例变量，可以考虑创建多个对象，这样对象不共享了，就没有线程安全问题<br>方案三：以上两个方案都不能使用，再选择synchronized，线程<br>同步机制<br>线程排队执行，（不能并发）这种机制被称为：<br>线程同步机制（牺牲了一部分效率）<br>线程同步机制语法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>()&#123;</span><br><span class="line">    线程同步代码块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：<br>如果共享对象就是this，并且需要同步的代码块就是整个方法体可以让Synchronized出现在实例方法上来使用，这样代码简洁<br>执行原理：遇到synchronized后，线程会一个一个排队占有对象锁，占有对象锁的线程执行同步代码块，没占有的线程等候。<br>注：<br>()中填：需要同步的线程的共享对象，这个对象对于别的线程来说不是共享的。<br>Java的任何一个对象都有“一把锁(标记)”，一个对象一把锁</p>
<p>异步编程模型：线程各自执行各自的，这种编程模型叫  做：异步编程模型（其实就是多线程并发，效率较高）<br>同步编程模型：线程之间发生等待关系，这种就是同步编程模型（线程排队执行，效率较低）<br>注：局部变量永远不会有线程安全问题<br>死锁：很难调试，建议不要嵌套使用synchronized<br>（7）守护线程<br>线程的分类：用户线程、守护线程<br>方法：引用.setDaemon(true)   启动线程之前，将线程设置为守护线程，这样当用户线程结束后，守护线程也结束。<br>（8）定时器<br>作用：间隔特定的时间去执行特定的程序<br>Timer类<br>（9）实现线程的第三种方式：实现Collable接口（JDK新特性）<br>优点：可以获取到线程的执行结果<br>缺点；效率比较低，在等待获取另一个线程执行结果的时候，当前线程收到阻塞。<br>（10）wait方法与notify方法（object类中的，任何对象都有）<br>Wait方法：会让当前线程（正在object对象上活动的线程）进入等待状态，并且释放之前占有的object对象的锁<br>Notify方法：唤醒正在object对象上等待的线程<br>NotifyAll方法：唤醒object对象上处于等待的所有线程<br>注：两种方法必须建立在线程同步的基础上<br>（11）生产者与消费者模式<br>目的：为了专门解决某个特定需求的</p>
<h5 id="16、反射"><a href="#16、反射" class="headerlink" title="16、反射"></a>16、反射</h5><p>（1）反射机制：优点：反射机制可以操作字节码文件、使程序更加灵活<br>（2）位置：反射机制的相关类在Java.lang.reflect.*下<br>（3）相关的重要类：<br>Java.lang.Class  代表整个字节码(类)<br>Java.lang.reflect.Method  代表字节码中的方法字节码(方法)<br>Java.lang.reflect.Constructor  代表字节码中的构造方法字节码(构造方法)<br>Java.lang.reflect.Field  代表字节码中的属性字节码(成员变量)<br>（4）获取Class：Class.forName(“完整类名带有包名”)  静态方法<br>注意：如果你只希望一个类的静态代码块执行，其他代码一律不执行，可以使用此方法，这个方法的执行会导致类加载。<br>引用.getClass()  Java中任何一个对象都有此方法，获取引用的类型<br>任何类型.class  直接获取任意类型的字节码<br>（5）Class的newInstance()方法：实例化对象。<br>方法内部实际上调用了无参数构造方法，必须保证无参构造方法的存在才可以<br>（6）反射机制的灵活性：在不改变源代码的基础上，可以做到不同对象的实例化，代码不需要改动，可以修改配置文件，配置文件修改后，可以创建出不同的实例对象<br>（7）类加载器(ClassLoader)：专门负责加载类的命令&#x2F;工具<br>JDK自带三个类加载器：启动类加载器(专门加载rt.jar)  父扩展类加载器(专门加载ext)  母应用类加载器(classpath中的jar包)  子执行代码时，先将所需类全部加载到JVM中，然后通过在类加载器找对应代码文件，找到就加载，找不到就通过启动类加载器找，再找不到就在扩展类加载器找。（双亲委派机制：优先父，加载不到，就母，最后找不到，才轮到子）<br>（8）获取Field<br>获取类中所有public修饰的Field：引用.getFields()   返回一个数组<br>获取类中所有的Field：引用.getDeclaredFields()   返回一个数组<br>获取单个属性：对象引用.getDeclaredField(“属性名”)<br>反射机制调用属性：<br>给属性赋值：属性引用.set(对象)<br>获取属性值：属性引用.get(对象，值)<br>打破封装(可以访问私有变量)：属性引用.setAccessible(true)<br>获取类中所有属性的类型：引用.getType()   返回一个Class<br>获取类中所有的属性的修饰符列表：int i&#x3D;引用.getModifiers()   返回一个数字，每个数字是修饰符的代号<br>Modifier.toString(i)  将数字转换为字符串<br>获取类的简单类名：引用.getSimpleName()<br>（9）获取Method<br>可变长度参数：语法：类型… 名字<br>要求：<br>参数个数是0~N个<br>必须在参数列表中最后一个的位置上，且只能有一个<br>可以当成一个数组来看待<br>获取所有的Method(包括私有的)：引用.getDeclaredMethods()   返回一个数组<br>获取单个的Method：引用.getDeclaredMethod(“方法名”,参数列表)<br>反射机制调用方法（四要素：对象、方法、实参、返回值）：对象引用.invoke(对象,实参)<br>获取修饰符列表：Modifier.toString(引用.getModifiers())<br>获取方法的返回值类型：引用.getReturnType().getSimpleName()<br>获取方法名：引用.getName()<br>获取方法的参数列表：引用.getParameterTypes()  返回一个数组<br>（10）获取Constructor<br>获取所有构造方法：引用.getDeclaredConstructors()<br>获取单个构造方法：对象引用.getDeclaredConstructor(实参)<br>反射机制调用构造方法：Constructor引用.nwInstance(参数)<br>（11）获取类的父类：引用.getSuperclass()<br>获取类实现的接口：引用.getInterfaces()</p>
<h5 id="17、注解（Annotation）"><a href="#17、注解（Annotation）" class="headerlink" title="17、注解（Annotation）"></a>17、注解（Annotation）</h5><p>(1)	注解是一种引用数据类型，编译后生成xxx.class文件<br>注解可以出现在类、属性、方法、变量、注解上，默认下，可以在任意位置<br>(2)	自定义注解的语法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">一、定义</span><br><span class="line"> [修饰符列表] <span class="meta">@interface</span> 注解类型名&#123; </span><br><span class="line">    属性类型 名字();</span><br><span class="line">    属性类型[] 名字();</span><br><span class="line">&#125;</span><br><span class="line">二、 使用</span><br><span class="line"> <span class="meta">@interface</span> 注解类型名</span><br></pre></td></tr></table></figure>
<p>(3)	自定义注解：<br>若自定义注解{}里当中有属性，那么使用注解时必须给属性赋值</p>
<blockquote>
<p>@注解名(属性名&#x3D;属性值,数组属性名&#x3D;{ })    </p>
</blockquote>
<p>注：有默认值就不需要在括号再赋值了<br>当属性名为value时，属性名可以省略<br>当属性数组中只有一个元素时，大括号{}可以省略注解当中的属性可以为：8个基本数据类型、String、Class、枚举、以及以上每种类型的数组类型<br>(4)	元注解：用来标注注解类型的注解。<br>常见元注解：<br>Target注解（用来标注“被标注的注解”可以用在哪些位置）<br>Retention注解（用来标注“被标注的注解”最终保存在哪里）<br>(5)	JDK内置的注解(Java.lang下)：<br>Override注解：只能注解方法。给编译器参考的，与运行阶段无关。带有此注解，编译器会检查，如果这个方法不是重写父类的方法，编译器报错<br>Deprecated注解：表示被注解的程序元素已过时<br>(6)	反射机制判断类上是否有某注解：<br>对象引用.isAnnotationPresent(要判断的注解名.class)<br>获取类上注解：对象引用.getAnnotation(要获取的注解名.class)<br>获取注解上的属性：注解对象引用.属性名()<br>(7)	注解的作用：注解类似一种标记，可以用注解限制某些条件，如果不满足这些条件<br>就报抛出异常。</p>
<hr>
<p>😃END</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>语言</category>
      </categories>
      <tags>
        <tag>java笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL入门</title>
    <url>/posts/c24675b4.html</url>
    <content><![CDATA[<h3 id="什么是数据库？"><a href="#什么是数据库？" class="headerlink" title="什么是数据库？"></a>什么是数据库？</h3><p>概念:<br>指长期存储在计算机内，有组织的、可共享的数据集合<br>构成：<br>数据库可以看成存储数据库对象的容器，MYSQL中，分为系统数据库和用户数据库两大类<br>数据模型:<br>层次模型、网状模型、关系模型(结构简单，常用)<br>数据模型三要素：<br>数据结构、数据操作、完整性约束条件<br>数据库类型：<br>层次模型数据库、网状模型数据库、关系模型数据库<br>数据库系统：<br>硬件、软件、数据库、用户<br>结构化查询语句SQL：<br>DDL、DML、DCL、事务处理语句</p>
<h3 id="关系结构"><a href="#关系结构" class="headerlink" title="关系结构"></a>关系结构</h3><p>关系结构的术语：<br>关系、元组(记录)、属性、域、候选码、主键(主码)、外键(与另一个表的关联)、全码、关系模式<br>关系表必须满足以下条件才能成为关系模式的一部分：<br>信息原则：每个单元只能存储一条数据<br>列唯一性名称：列下的数据必须具有相同数据类型，列没有顺序<br>行的数据唯一：行没有顺序<br>实体完整性：即主键不能为空<br>引用完整性：即外键不能为空</p>
<h3 id="DB、DBMS、SQL的关系"><a href="#DB、DBMS、SQL的关系" class="headerlink" title="DB、DBMS、SQL的关系"></a>DB、DBMS、SQL的关系</h3><p>DB：数据库   DBMS：数据库管理系统   SQL：结构化查询语言<br>DBMS负责执行SQL语句，通过执行SQL语句来操作DB当中的数据</p>
<h3 id="SQL的分类"><a href="#SQL的分类" class="headerlink" title="SQL的分类"></a>SQL的分类</h3><p>DQL（数据查询语言）：查询语句，凡是select语句都是DQL。<br>DML（数据操作语言）：insert 增 delete 删 update 改<br>DDL（数据定义语言）：create drop alter，对表结构的增删改<br>TCL（事务控制语言）：commit提交事务，rollback 回滚事务<br>DCL（数据控制语言）：grant授权，revoke撤销权限等·</p>
<h3 id="常用MySQL命令"><a href="#常用MySQL命令" class="headerlink" title="常用MySQL命令"></a>常用MySQL命令</h3><p>Select database(); 查看当前使用的是哪个数据库<br>Show variables like “%char%”;   查看mysql的本地安装路径<br>Select version();  查看MySQL的版本号<br>Show databases；  查看现有数据库<br>Show create table emp  查看创建表的语句<br>\C   结束一条语句<br>Exit  退出MySQL</p>
<h3 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h3><blockquote>
<p>创建数据库：create database 数据库名;<br>删除数据库：drop database 数据库名;<br>使用数据库：Use 数据库名;</p>
</blockquote>
<h3 id="数据表操作"><a href="#数据表操作" class="headerlink" title="数据表操作"></a>数据表操作</h3><ol>
<li>   操作</li>
</ol>
<blockquote>
<p>创建数据表：create table 数据表名(column_name column_type);<br>删除数据表：drop table 数据表名;<br>表查询：desc 表名;<br>表的复制：</p>
<blockquote>
<p>将查询结果当做表创建出来 ：语法：create table 表名 as select语句<br>将表2的查询结果插入到表1中 ：语法：insert into 表1 select*from 表2</p>
</blockquote>
</blockquote>
<ol start="2">
<li>   常见的数据类型：<br>int<br>bigint：长整型(对应Java中的long)<br>float<br>char：一般在数据长度不发生改变的时候使用  (对应Java中的String)<br>Char(5):指定长度为5个字符<br>varchar：可变长字符串，在数据长度不确定的时候使用(对应Java中的StringBuffer，最多255个)<br>date<br>BLOB  二进制大对象(对应Java中的Object，存储图片、视频等流媒体信息)<br>CLOB  字符大对象(存储较大文本，对应Java中的Object，可以存储4G的字符串)</li>
</ol>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><ol>
<li>操作</li>
</ol>
<blockquote>
<p>insert into 表名(字段名1,字段名2…) values(值1,值2…)<br>insert into 表名values(值1,值2…)  字段名可省，但值需要对应表<br>insert into 表名(字段名1,字段名2…) values(值1,值2…), (值1,值2…)… 一次插入多行数据</p>
</blockquote>
<p>注：<br>字段的数量和值的数量相同，并且数据类型要对应相同<br>当一条insert语句执行之后，表当中必定会多一行记录，后期不能再插入新数据，只能使用update进行更新</p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><ol>
<li>操作</li>
</ol>
<blockquote>
<p>delete from 表名 where 条件；（没条件全部删除）<br>删除大表的数据：truncate table 表名； 表被截断，不可回滚，永久丢失。</p>
</blockquote>
<h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><ol>
<li>操作</li>
</ol>
<blockquote>
<p>update 表名 set 字段名1&#x3D;值1,字段名2&#x3D;值2…where 条件；（没条件全部更新）</p>
</blockquote>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><ol>
<li>   简单查询</li>
</ol>
<blockquote>
<p>select 字段名1,字段名2,…from 表名</p>
</blockquote>
<p>重命名字段名：字段名后加as（可省略）名称（如果名称是字符串，得加单引号）</p>
<ol start="2">
<li>   条件查询</li>
</ol>
<blockquote>
<p>select 字段名1,字段名2,…from 表名 where 条件</p>
</blockquote>
<p>执行顺序：先from，然后where，再select<br>优先级：（）&gt; and &gt; or<br>注：In(值，值):相当于or</p>
<ol start="3">
<li>   模糊查询</li>
</ol>
<blockquote>
<p>select 字段名1,字段名2,…from 表名 Like ‘%查询的数据%’，支持%或下划线_匹配</p>
</blockquote>
<p>注：<br>数据库中null不是一个值，不能用等号，必须使用is null或is not bull只要有Null参与了运算，最后得出得结果一定为null<br>CRUD操作：增删改查的术语，Create、Retrieve、Update、Delete</p>
<ol start="4">
<li>   连续查询<br>(一)	分类：<br>根据语法出现的年代来划分：SQL92、SQL99（比较新）<br>根据表的连接方式来划分：内连接、外连接、全连接<br>内连接：等值连接、非等值连接、自连接<br>等值连接：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select 表1.字段，表2.字段 </span><br><span class="line">from 表1 </span><br><span class="line">inner(可省) join 表2 </span><br><span class="line">on 表1.字段 = 表2.字段</span><br></pre></td></tr></table></figure>
非等值连接：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select 表1.字段，表2.字段 </span><br><span class="line">from 表1 </span><br><span class="line">inner(可省) join 表2 </span><br><span class="line">on 连接条件</span><br></pre></td></tr></table></figure>
自连接<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select a.表名，b.表名</span><br><span class="line">from 表名 a </span><br><span class="line">inner(可省) join 表名 b </span><br><span class="line">on 连接条件</span><br></pre></td></tr></table></figure>
外连接：左外连接（左连接,左表为主表）、右外连接（右连接，右表为主表）<br>左外连接：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select a.表名，b.表名</span><br><span class="line">from 表名 a </span><br><span class="line">left outer(可省) join 表名 b   a 为主表</span><br><span class="line">on 连接条件</span><br></pre></td></tr></table></figure>
右外连接：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select a.表名，b.表名</span><br><span class="line">from 表名 b </span><br><span class="line">right outer(可省) join 表名 a   b 为主表</span><br><span class="line">on 连接条件</span><br></pre></td></tr></table></figure>
内连接与外连接的区别：内连接表之间平等，外连接有主副之分<br>全连接<br>(二)笛卡尔积现象：当两张表进行连接查询的时候，没有任何条件进行限制，最终的查询结果条数是两张表记录条数的乘积。<br>(三)多表查询：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select 表1.字段，表2.字段 ，…</span><br><span class="line">from 表1 </span><br><span class="line">join 表2 </span><br><span class="line">on 连接条件</span><br><span class="line">join 表3 </span><br><span class="line">on 连接条件</span><br><span class="line">left join 表4      表1与表4进行连接，表1为主表</span><br><span class="line">on 连接条件</span><br></pre></td></tr></table></figure>
(四)子查询：select语句当中嵌套select语句，被嵌套的select语句是子查询<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Select</span><br><span class="line">…(select语句)</span><br><span class="line">from </span><br><span class="line">…(select语句)      select语句的查询结果当成一张临时表</span><br><span class="line">Where</span><br><span class="line">…(select语句) </span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><blockquote>
<p>select 字段名1,字段名2,…from 表名 order by 要排序的字段名</p>
</blockquote>
<p>默认是升序，字段名后加asc是升序，字段名后加desc是降序</p>
<h3 id="分组函数（多行处理函数）"><a href="#分组函数（多行处理函数）" class="headerlink" title="分组函数（多行处理函数）"></a>分组函数（多行处理函数）</h3><p>a)	5个函数：count 计数、sum求和、avg 平均值、max、min<br>b)	语法：select 函数名(目标字段名) from 表名<br>c)	特点：输入多行，最终输出一行。自动忽略null。分组函数不能直接使用于where后面<br>d)	单行处理函数：特点:输入一行，输出一行<br>e)	空处理函数：Ifnull(可能为null的数据，做什么处理) 属于单行处理函数<br>f)	Count（*）：统计总记录条数，null会计入总数  Count（某字段）：统计不为null的数据总数量<br>g)	Group by 和having<br>Group by：按照某个字段或某些字段进行分组。<br>Having：对分组后的数据进行再次过滤。<br>分组函数一般都会和group by联合使用，并且分组函数在group by 语句执行结束之后才会执行，而group by 是在where执行后才执行。</p>
<h3 id="去除重复记录"><a href="#去除重复记录" class="headerlink" title="去除重复记录"></a>去除重复记录</h3><p>Distinct关键字去除重复记录<br>特点：distinct只能出现在所有字段的前面，表示所有字段联合去重</p>
<h3 id="Union"><a href="#Union" class="headerlink" title="Union"></a>Union</h3><p>可以将查询结果集相加（表之间的列数要一致）</p>
<h3 id="Limit（MySQL特有，常用于分页查询）"><a href="#Limit（MySQL特有，常用于分页查询）" class="headerlink" title="Limit（MySQL特有，常用于分页查询）"></a>Limit（MySQL特有，常用于分页查询）</h3><p>语法:limit starIndex , length  starIndex 表示起始位置（从0开始）length 表示取几个<br>分页查询：<br>每页显示pageSize条记录：第pageNo页：（pageNo-1）*pageSize，pageSize</p>
<h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><p>添加约束的目的：<br>为了保证表中数据的合法性、有效性、完整性<br>常见的约束：<br>非空约束（not null）约束的字段不能为null<br>唯一约束（unique）约束的字段不能重复，但可以有存在多个null<br>主键约束（primary key，简称PK）约束的字段既不能为null，也不能重复，一张表的主键约束只能有一个外键约束（foreign key，简称FK）外键可以为null，被引用的字段不一定是主键，但必须具有唯一性（既具有unique约束）<br>检查约束（check）：Oracle数据库有check约束，但MySQL没有。</p>
<p>非空约束：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table 表名(</span><br><span class="line">	字段名1 数据类型not null,	（列级约束）</span><br><span class="line">    字段名2 数据类型，</span><br><span class="line">….</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>唯一约束（unique）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table 表名(</span><br><span class="line">	字段名1 数据类型 unique， 字段名1唯一不可重复（列级约束）</span><br><span class="line">    字段名2 数据类型，</span><br><span class="line">….</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table 表名(</span><br><span class="line">	字段名1 数据类型，</span><br><span class="line">字段名2 数据类型，</span><br><span class="line">Unique(字段名1,字段名2…) 多字段联合起来唯一不可重复（表级约束）</span><br><span class="line">….</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>主键约束（primary key）:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table 表名(</span><br><span class="line">	字段名1 数据类型primary key,		（列级约束）</span><br><span class="line">字段名2 数据类型，</span><br><span class="line">….</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table 表名(</span><br><span class="line">	字段名1 数据类型，</span><br><span class="line">字段名2 数据类型，</span><br><span class="line">primary key(字段名1)       （表级约束）</span><br><span class="line">….</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>(一)主键的相关术语：<br>主键字段：被主键约束后的字段叫主键字段<br>主键值：主键字段中的每一个值都是主键值<br>(二)主键的作用：主键值是这行记录在表中的唯一标识<br>(三)主键的分类：<br>根据主键字段的字段数量来划分：单一主键（常用）、复合主键（不常用，违背三范式）<br>根据主键性质来划分：自然主键（常用）、业务主键：主键值与业务挂钩（不常用）<br>(四)主键值自增（MySQL特有）：字段自动维护（生成）一个自增的数字，从1开始，以1递增</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table 表名(</span><br><span class="line">	字段名1 数据类型 primary key atuo_increment, </span><br><span class="line">字段名2 数据类型，</span><br><span class="line">….</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>注：Oracle的自增机制，叫做序列（sequence）<br>外键约束（foreign key）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table 父表(</span><br><span class="line">	字段名1 数据类型，</span><br><span class="line">字段名2 数据类型，</span><br><span class="line">primary key(字段名1)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table 子表(</span><br><span class="line">	字段名1 数据类型，</span><br><span class="line">字段名2 数据类型，</span><br><span class="line">Foreign key(子表的字段名) references 父表(父表的字段名1)</span><br><span class="line">References：表示引用  </span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>(一)外键的相关术语：<br>外键字段：添加有外键约束的字段<br>外键值：外键字段中的每一个外键值<br>(二)顺序要求：<br>删除数据与表时：先子表，再父表<br>添加数据和创建表时：先父表，后子表<br>子表与父表：表1引用了表2中的某字段，此时表1为子表，表2为父表</p>
<h3 id="存储引擎（MySQL特有）"><a href="#存储引擎（MySQL特有）" class="headerlink" title="存储引擎（MySQL特有）"></a>存储引擎（MySQL特有）</h3><p>（一）完整的建表语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table 表名(</span><br><span class="line">			字段名1 数据类型，</span><br><span class="line">字段名2 数据类型，</span><br><span class="line">….</span><br><span class="line">)engine=InnoDB default charsef=utf8;</span><br></pre></td></tr></table></figure>
<p>（二）存储引擎：<br>MySQL支持多个存储引擎，每一种存储引擎都对应一种存储方式<br>（三）查看当前MySQL支持的存储引擎：show engines \G<br>（四）常见的存储引擎：<br>MyISAM存储引擎：不支持事务<br>特征：<br>1.使用三个文件来表示每个表<br>（mytable.frm存储表结构的定义、mytable.MYD存储表行的内容、mytable.MYI存储表上的索引）<br>2.灵活的表自增字段处理<br>3.可被转换为压缩，只读表来节省空间<br>InnoDB存储引擎：支持事务，行级锁，外键等，安全性高，建表时默认采用。<br>特征：<br>1.表的结构存储在mytable.frm文件中，数据存储在table space（逻辑概念）中，无法被压缩，无法被切换成只读<br>2.数据库崩溃后提供自动恢复机制<br>3.支持级联删除和级联更新<br>MEMORY存储引擎：不支持事务，查询速度最快，因为所有数据以及索引存储在内存中。</p>
<h3 id="事务-Transaction"><a href="#事务-Transaction" class="headerlink" title="事务(Transaction)"></a>事务(Transaction)</h3><p>1.概念：<br>一个事务是一个完整的业务逻辑单元，不可再分，事务通常需要多条DML语句共同完成，确保多条DML语句同时成功，或同时失败。<br>注：事务保证数据的完整性，安全性。与事务相关的语句只有DML语句<br>2.事务包括四大特性：ACID<br>A：原子性，事务是最小的工作单元，不可再分。<br>C：一致性，事务必须保证多条DML语句同时成功或者同时失败。<br>I：隔离性，事务A与事务B之间具有隔离<br>D：持久性，最终必须持久化到硬盘文件中，事务才算成功的结束。<br>事务之间的隔离性：<br>a)4个隔离级别：<br>第一级别：<br>读未提交（read uncommitted）<br>对方事务未提交，我方当前事务就可以读取到数据<br>存在脏读（dirty read）现象<br>第二级别：<br>读已提交（read committed）<br>对方事务提交之后，我方事务才可以读取到数据<br>存在不可重复读问题，解决脏读问题<br>第三级别：<br>可重复读（repeatable read）<br>我方事务只可以重复读取到对方开始事务时数据<br>存在读取的数据是幻象问题，解决不可重复读问题<br>第四级别：<br>序列化读&#x2F;串行化读<br>解决了所有问题，但效率低，需要事务排队<br>b)	设置事务的全局隔离级别：<br>Set global transaction isolation level 隔离级别(例,read uncommitted);<br>查看事务的全局隔离级别：Select @@global.tx_isolation;<br>c)	Oracle默认隔离级别：第二级别<br>MySQL默认隔离级别：第三级别<br>3.MySQL的事务是自动提交的：只要执行一条DML，则提交一次<br>可使用start transaction；关闭自动提交机制<br>commit提交事务，rollback 回滚事务</p>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>1.概念：<br>索引就相当于目录，通过目录可以快速的找到对应的数据<br>注：添加索引是给某一个字段或者某些字段添加索引<br>2.数据库检索：<br>有两种方式：全表扫描、根据索引检查(效率很高，根本原因是缩小了扫描范围)<br>3.创建索引对象：create index 索引名称 on 表名(字段名);<br>4.删除索引对象：drop index 索引名称 on 表名;<br>5.添加索引的条件：数据量庞大。（根据客户需求和线上环境而定）<br>该字段很少的DML操作。（因为字段修改时，索引也需要维护，可能导致效率低，维护成本过高等问题）该字段经常出现在where子句中<br>6.查看sql语句的执行计划：<br>explain select语句<br>注：主键和unique约束的字段自动会添加索引。根据主键查询效率较高，尽量使用主键检索<br>7.索引的实现原理：<br>通过B Tree缩小扫描范围，底层索引进行了排序，分区，索引携带数据在表中的“物理地址“，最终通过索引检索到数据之后，获取到关联的物理地址，再通过物理地址定位表中的数据，效率是最高的。<br>注：物理地址：表的每一行在硬盘中真实存在的内存地址<br>检索到匹配的数据后，select … where 条件 会通过索引转换为：<br>select … where物理地址&#x3D;数据的物理地址<br>索引的底层采用的数据结构是：B+Tree<br>8.索引的分类：<br>单一索引：给单个字段添加索引<br>复合索引：给多个字段联合起来添加1个索引<br>主键索引：主键上自动添加索引<br>唯一索引：有unique约束的字段会自动添加索引<br>9.索引的失效：<br>当Where后的使用模糊查询‘%A%’等，索引无法分区时，索引失效</p>
<h3 id="视图（view）"><a href="#视图（view）" class="headerlink" title="视图（view）"></a>视图（view）</h3><p>1.概念：站在不同的角度去看数据<br>2.创建视图：Create view 视图名 as sql语句;<br>注：只能DQL语句才能创建视图<br>3.删除视图：Drop view 视图名<br>4.视图的作用：<br>视图可以隐藏表的数据细节。保密级别较高的系统，要外包或者交互时，可使用视图，这样，程序员只能对视图对象进行CRUD。</p>
<h3 id="DBA命令"><a href="#DBA命令" class="headerlink" title="DBA命令"></a>DBA命令</h3><p>导出整个数据库（dos命令窗口中执行）：<br>Mysqldump 数据库文件&gt;数据库文件路径 -u用户名 -p密码<br>导出指定数据库当中的指定表：<br>Mysqldump 数据库文件 表名&gt;数据库文件路径 -u用户名 -p密码<br>导入数据：<br>create database 数据库文件；<br>use 数据库文件;<br>source 数据库文件路径;</p>
<h3 id="设计三范式"><a href="#设计三范式" class="headerlink" title="设计三范式"></a>设计三范式</h3><p>1.概念：<br>设计表的依据。按照三范式设计的表不会出现数据冗余。<br>2.分类：<br>第一范式：任何一张表都应该有主键，并且每一个字段原子性不可再分。<br>第二范式：建立在第一范式的基础上，所有非主键字段完全依赖主键，不能产生部份依赖。<br>口诀：多对多，三张表，关系表两外键。<br>第三范式：建立在第二范式的基础上，所有非主键字段直接依赖主键，不能产生传递依赖。<br>口诀：一对多，两张表，多的表加外键。<br>注：在实际开发中，以满足客户需求为主，有的时候会拿冗余换执行速度。</p>
<hr>
<p>😂END</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Python入门</title>
    <url>/posts/d9ef328.html</url>
    <content><![CDATA[<h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>语法：变量名&#x3D;值<br>打印：print()   或者 直接打入变量名<br>原始字符串：r ‘字符串’  作用：给字符串的&#x2F;加上&#x2F;进行反义  </p>
<h4 id="分支与循环"><a href="#分支与循环" class="headerlink" title="分支与循环"></a>分支与循环</h4><p>if语句:<br>if 条件：代码体  else：代码体<br>If 条件：代码体  elif：代码体 else: 代码体<br>三元操作符：<br>x if 条件 else y  条件为true返回左边的值，false则返回右边<br>while循环：<br>while 条件：循环体<br>for循环：<br>for 目标 in 表达式：循环体</p>
<h4 id="常见方法"><a href="#常见方法" class="headerlink" title="常见方法"></a>常见方法</h4><p>random.randint(1,10)  随机生成一个1到10的整形<br>range（[strat,] stop [ ,step]）<br>注：[ ] 不是必须的，可省。Step默认值为1，表示数值的间隔为1。<br>作用：生成一个从strat开始到stop结束的数字序列(前开后闭)<br>input(“请输入：”)：获取用户输入的数据<br>id(参数)：查看该参数的内存地址<br>dir(参数)   输出该参数的所有方法<br>help(参数)  输出该参数的帮助文档</p>
<h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>有：int、str、bool、float等<br>类型的判断：type()   isintstance(变量，数据类型)  判断是否是该数据类型</p>
<h4 id="字符串-注：字符串的方法与元组类似"><a href="#字符串-注：字符串的方法与元组类似" class="headerlink" title="字符串(注：字符串的方法与元组类似)"></a>字符串(注：字符串的方法与元组类似)</h4><ol>
<li>格式化字符串：<br>‘字符串1’.format(‘字符串2’)  按字符串1格式化字符串2<br>‘字符串（包含了格式化符号）’ % 值<br>例：’结果是%c’ % 97  -&gt; 结果是97<br>f ‘ 字符串{name}’</li>
<li>字符串的方法</li>
</ol>
<blockquote>
<p>字符串的查找：<br>检测str是否包含sub有返回索引无返回-1：Str.find(sub[,start[,end]])<br>例：“asdf“.find(‘d’)  返回2<br>                           检测str是否包含sub有返回索引无则抛异常：str.index(sub[,start[,end]])<br>字符串的替换：<br>将old替换为new返回新串：str.replace(old,new[,count]) count:替换次数<br>字符串的统计：<br>统计sub出现次数：str.count(sub[,start[,end]])<br>字符串的分隔：<br>通过分割符sep进行切片，返回列表：str.split(sep&#x3D;None,maxsplit&#x3D;-1)<br>    Maxsplit:分割次数，-1表示不限制次数<br>字符串的大小写替换：<br>首字母大写：str.capitalize()<br>单词首字母大写，其他小写：str.title()  例：HelloWord<br>小写转大写：str.upper()<br>字符串的开头判断：<br>是否以prefix开头：str.startswith(prefixe[,start[,end]])<br>字符串的结尾判断：<br>是否以suffix结尾：str.endswith(suffix[,start[,end]])</p>
</blockquote>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="-1"><a href="#-1" class="headerlink" title=""></a></h4><h3 id="-2"><a href="#-2" class="headerlink" title=""></a></h3><h4 id="-3"><a href="#-3" class="headerlink" title=""></a></h4><h4 id="-4"><a href="#-4" class="headerlink" title=""></a></h4><h3 id="-5"><a href="#-5" class="headerlink" title=""></a></h3><h4 id="-6"><a href="#-6" class="headerlink" title=""></a></h4><h4 id="-7"><a href="#-7" class="headerlink" title=""></a></h4><hr>
<p>END</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>语言</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis入门</title>
    <url>/posts/64e66de7.html</url>
    <content><![CDATA[<h3 id="Redis-简介"><a href="#Redis-简介" class="headerlink" title="Redis 简介"></a>Redis 简介</h3><h4 id="1-问题："><a href="#1-问题：" class="headerlink" title="1.问题："></a>1.问题：</h4><p>在涉及大数据量的需求，比如一些商品抢购的情景，或者是主页访问量瞬间较大的时候，单一使用数据库来保存数据的系统会因为面向磁盘，磁盘读&#x2F;写速度比较慢的问题而存在严重的性能弊端，一瞬间成千上万的请求到来，需要系统在极短的时间内完成成千上万次的读&#x2F;写操作，这个时候往往不是数据库能够承受的，极其容易造成数据库系统瘫痪，最终导致服务宕机的严重生产问题。</p>
<h4 id="2-NoSQL-技术"><a href="#2-NoSQL-技术" class="headerlink" title="2.NoSQL 技术"></a>2.NoSQL 技术</h4><p>为了克服上述的问题，Java Web项目通常会引入NoSQL技术，这是一种基于内存的数据库，并且提供一定的持久化功能。<br>Redis和MongoDB是当前使用最广泛的NoSQL，而就Redis技术而言，它的性能十分优越，可以支持每秒十几万此的读&#x2F;写操作，其性能远超数据库，并且还支持集群、分布式、主从同步等配置，原则上可以无限扩展，让更多的数据存储在内存中，更让人欣慰的是它还支持一定的事务能力，这保证了高并发的场景下数据的安全和一致性。</p>
<h4 id="3-使用场景"><a href="#3-使用场景" class="headerlink" title="3.使用场景"></a>3.使用场景</h4><p>一般我们只是使用 Redis 存储一些常用和主要的数据，比如用户登录的信息等。<br>从这几个方面来考虑：<br>业务数据常用吗？命中率如何？如果命中率很低，就没有必要写入缓存；<br>该业务数据是读操作多，还是写操作多？如果写操作多，频繁需要写入数据库，也没有必要使用缓存；<br>业务数据大小如何？如果要存储几百兆字节的文件，会给缓存带来很大的压力，这样也没有必要；</p>
<h4 id="4-redis定义"><a href="#4-redis定义" class="headerlink" title="4.redis定义"></a>4.redis定义</h4><p>REmote DIctionary Server(Redis) 是一个由 Salvatore Sanfilippo 写的 key-value 存储系统，是跨平台的非关系型数据库。<br>Redis 是一个开源的使用 ANSI C 语言编写、遵守 BSD 协议、支持网络、可基于内存、分布式、可选持久性的键值对(Key-Value)存储数据库，并提供多种语言的 API。<br>Redis 通常被称为数据结构服务器，因为值（value）可以是字符串(String)、哈希(Hash)、列表(list)、集合(sets)和有序集合(sorted sets)等类型。</p>
<h3 id="redis数据类型"><a href="#redis数据类型" class="headerlink" title="redis数据类型"></a>redis数据类型</h3><h4 id="1-String字符串"><a href="#1-String字符串" class="headerlink" title="1.String字符串"></a>1.String字符串</h4><p>特点：<br>一个 key 对应一个 value。<br>二进制安全的， string 可以包含任何数据。比如jpg图片或者序列化的对象<br>值最大能存储 512MB<br>命令：</p>
<blockquote>
<p>SET runoob “菜鸟教程”<br>GET runoob<br>DEL runoob</p>
</blockquote>
<h4 id="2-Hash哈希"><a href="#2-Hash哈希" class="headerlink" title="2.Hash哈希"></a>2.Hash哈希</h4><p>特点：<br>一个键值(key&#x3D;&gt;value)对集合<br>一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象<br>命令：</p>
<blockquote>
<p>HMSET runoob field1 “Hello” field2 “World”<br>HGET runoob field1</p>
</blockquote>
<h4 id="3-List列表"><a href="#3-List列表" class="headerlink" title="3.List列表"></a>3.List列表</h4><p>特点：<br>简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）<br>命令：</p>
<blockquote>
<p>lpush runoob redis<br>lrange runoob 0 10</p>
</blockquote>
<h4 id="4-Set集合"><a href="#4-Set集合" class="headerlink" title="4.Set集合"></a>4.Set集合</h4><p>特点：<br>Set 是 string 类型的无序集合<br>集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)<br>命令：</p>
<blockquote>
<p>sadd runoob redis<br>smembers runoob</p>
</blockquote>
<h4 id="5-zset-sorted-set：有序集合"><a href="#5-zset-sorted-set：有序集合" class="headerlink" title="5.zset(sorted set：有序集合)"></a>5.zset(sorted set：有序集合)</h4><p>特点：<br>zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。<br>不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。<br>zset的成员是唯一的,但分数(score)却可以重复。<br>命令：</p>
<blockquote>
<p>zadd runoob 0 redis<br>ZRANGEBYSCORE runoob 0 1000</p>
</blockquote>
<h4 id="6-各个数据类型的应用场景"><a href="#6-各个数据类型的应用场景" class="headerlink" title="6.各个数据类型的应用场景"></a>6.各个数据类型的应用场景</h4><p>String 大多数场景<br>Hash 存储、读取、修改用户属性<br>List 1,最新消息排行等功能(比如朋友圈的时间线) 2,消息队列<br>Set 1、共同好友 2、利用唯一性,统计访问网站的所有独立ip 3、好友推荐时,根据tag求交集,大于某个阈值就可以推荐<br>Sorted Set 1、排行榜 2、带权重的消息队列</p>
<h3 id="redis命令"><a href="#redis命令" class="headerlink" title="redis命令"></a>redis命令</h3><h4 id="1-启动命令"><a href="#1-启动命令" class="headerlink" title="1.启动命令"></a>1.启动命令</h4><p>启动 redis 客户端：</p>
<blockquote>
<p>$ redis-cli</p>
</blockquote>
<p>注：可能出现中文乱码。<br>要在 redis-cli 后面加上 –raw<br>检测 redis 服务是否启动：</p>
<blockquote>
<p>PING</p>
</blockquote>
<p>远程 redis 服务上执行命令：</p>
<blockquote>
<p>$ redis-cli -h host -p port -a password</p>
</blockquote>
<h4 id="2-key命令"><a href="#2-key命令" class="headerlink" title="2.key命令"></a>2.key命令</h4><blockquote>
<p>DEL key<br>该命令用于在 key 存在时删除 key。<br>DUMP key<br>序列化给定 key ，并返回被序列化的值。<br>EXISTS key<br>检查给定 key 是否存在。<br>EXPIRE key seconds<br>为给定 key 设置过期时间，以秒计。<br>EXPIREAT key timestamp<br>EXPIREAT的作用和 EXPIRE 类似，都用于为 key 设置过期时间。 不同在于 EXPIREAT 命令接受的时间参数是 UNIX 时间戳(unix timestamp)。<br>PEXPIRE key milliseconds<br>设置 key 的过期时间以毫秒计。<br>PEXPIREAT key milliseconds-timestamp<br>设置 key 过期时间的时间戳(unix timestamp) 以毫秒计<br>KEYS pattern<br>查找所有符合给定模式( pattern)的 key 。<br>MOVE key db<br>将当前数据库的 key 移动到给定的数据库 db 当中。<br>PERSIST key<br>移除 key 的过期时间，key 将持久保持。<br>PTTL key<br>以毫秒为单位返回 key 的剩余的过期时间。<br>TTL key<br>以秒为单位，返回给定 key 的剩余生存时间(TTL, time to live)。<br>RANDOMKEY<br>从当前数据库中随机返回一个 key 。<br>RENAME key newkey<br>修改 key 的名称<br>RENAMENX key newkey<br>仅当 newkey 不存在时，将 key 改名为 newkey 。<br>SCAN cursor [MATCH pattern] [COUNT count]<br>迭代数据库中的数据库键。<br>TYPE key<br>返回 key 所储存的值的类型。</p>
</blockquote>
<h4 id="3-String命令"><a href="#3-String命令" class="headerlink" title="3.String命令"></a>3.String命令</h4><blockquote>
<p>SET key value<br>设置指定 key 的值。<br>GET key<br>获取指定 key 的值。<br>GETRANGE key start end<br>返回 key 中字符串值的子字符<br>GETSET key value<br>将给定 key 的值设为 value ，并返回 key 的旧值(old value)。<br>GETBIT key offset<br>对 key 所储存的字符串值，获取指定偏移量上的位(bit)。<br>MGET key1 [key2..]<br>获取所有(一个或多个)给定 key 的值。<br>SETBIT key offset value<br>对 key 所储存的字符串值，设置或清除指定偏移量上的位(bit)。<br>SETEX key seconds value<br>将值 value 关联到 key ，并将 key 的过期时间设为 seconds (以秒为单位)。<br>SETNX key value<br>只有在 key 不存在时设置 key 的值。<br>SETRANGE key offset value<br>用 value 参数覆写给定 key 所储存的字符串值，从偏移量 offset 开始。<br>STRLEN key<br>返回 key 所储存的字符串值的长度。<br>MSET key value [key value …]<br>同时设置一个或多个 key-value 对。<br>MSETNX key value [key value …]<br>同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。<br>PSETEX key milliseconds value<br>这个命令和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间，而不是像 SETEX 命令那样，以秒为单位。<br>INCR key<br>将 key 中储存的数字值增一。<br>INCRBY key increment<br>将 key 所储存的值加上给定的增量值（increment） 。<br>INCRBYFLOAT key increment<br>将 key 所储存的值加上给定的浮点增量值（increment） 。<br>DECR key<br>将 key 中储存的数字值减一。<br>DECRBY key decrement<br>key 所储存的值减去给定的减量值（decrement） 。<br>APPEND key value<br>如果 key 已经存在并且是一个字符串， APPEND 命令将指定的 value 追加到该 key 原来值（value）的末尾。</p>
</blockquote>
<h4 id="4-hash命令"><a href="#4-hash命令" class="headerlink" title="4.hash命令"></a>4.hash命令</h4><blockquote>
<p>HDEL key field1 [field2]<br>删除一个或多个哈希表字段<br>HEXISTS key field<br>查看哈希表 key 中，指定的字段是否存在。<br>HGET key field<br>获取存储在哈希表中指定字段的值。<br>HGETALL key<br>获取在哈希表中指定 key 的所有字段和值<br>HINCRBY key field increment<br>为哈希表 key 中的指定字段的整数值加上增量 increment 。<br>HINCRBYFLOAT key field increment<br>为哈希表 key 中的指定字段的浮点数值加上增量 increment 。<br>HKEYS key<br>获取哈希表中的所有字段<br>HLEN key<br>获取哈希表中字段的数量<br>HMGET key field1 [field2]<br>获取所有给定字段的值<br>HMSET key field1 value1 [field2 value2 ]<br>同时将多个 field-value (域-值)对设置到哈希表 key 中。<br>HSET key field value<br>将哈希表 key 中的字段 field 的值设为 value 。<br>HSETNX key field value<br>只有在字段 field 不存在时，设置哈希表字段的值。<br>HVALS key<br>获取哈希表中所有值。<br>HSCAN key cursor [MATCH pattern] [COUNT count]<br>迭代哈希表中的键值对。</p>
</blockquote>
<h4 id="5-List命令"><a href="#5-List命令" class="headerlink" title="5.List命令"></a>5.List命令</h4><blockquote>
<p>BLPOP key1 [key2 ] timeout<br>移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。<br>BRPOP key1 [key2 ] timeout<br>移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。<br>BRPOPLPUSH source destination timeout<br>从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。<br>LINDEX key index<br>通过索引获取列表中的元素<br>LINSERT key BEFORE|AFTER pivot value<br>在列表的元素前或者后插入元素<br>LLEN key<br>获取列表长度<br>LPOP key<br>移出并获取列表的第一个元素<br>LPUSH key value1 [value2]<br>将一个或多个值插入到列表头部<br>LPUSHX key value<br>将一个值插入到已存在的列表头部<br>LRANGE key start stop<br>获取列表指定范围内的元素<br>LREM key count value<br>移除列表元素<br>LSET key index value<br>通过索引设置列表元素的值<br>LTRIM key start stop<br>对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。<br>RPOP key<br>移除列表的最后一个元素，返回值为移除的元素。<br>RPOPLPUSH source destination<br>移除列表的最后一个元素，并将该元素添加到另一个列表并返回<br>RPUSH key value1 [value2]<br>在列表中添加一个或多个值到列表尾部<br>RPUSHX key value<br>为已存在的列表添加值</p>
</blockquote>
<h4 id="6-set命令"><a href="#6-set命令" class="headerlink" title="6.set命令"></a>6.set命令</h4><blockquote>
<p>SADD key member1 [member2]<br>向集合添加一个或多个成员<br>SCARD key<br>获取集合的成员数<br>SDIFF key1 [key2]<br>返回第一个集合与其他集合之间的差异。<br>SDIFFSTORE destination key1 [key2]<br>返回给定所有集合的差集并存储在 destination 中<br>SINTER key1 [key2]<br>返回给定所有集合的交集<br>SINTERSTORE destination key1 [key2]<br>返回给定所有集合的交集并存储在 destination 中<br>SISMEMBER key member<br>判断 member 元素是否是集合 key 的成员<br>SMEMBERS key<br>返回集合中的所有成员<br>SMOVE source destination member<br>将 member 元素从 source 集合移动到 destination 集合<br>SPOP key<br>移除并返回集合中的一个随机元素<br>SRANDMEMBER key [count]<br>返回集合中一个或多个随机数<br>SREM key member1 [member2]<br>移除集合中一个或多个成员<br>SUNION key1 [key2]<br>返回所有给定集合的并集<br>SUNIONSTORE destination key1 [key2]<br>所有给定集合的并集存储在 destination 集合中<br>SSCAN key cursor [MATCH pattern] [COUNT count]<br>迭代集合中的元素</p>
</blockquote>
<h4 id="7-sorted-set命令"><a href="#7-sorted-set命令" class="headerlink" title="7. sorted set命令"></a>7. sorted set命令</h4><blockquote>
<p>ZADD key score1 member1 [score2 member2]<br>向有序集合添加一个或多个成员，或者更新已存在成员的分数<br>ZCARD key<br>获取有序集合的成员数<br>ZCOUNT key min max<br>计算在有序集合中指定区间分数的成员数<br>ZINCRBY key increment member<br>有序集合中对指定成员的分数加上增量 increment<br>ZINTERSTORE destination numkeys key [key …]<br>计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 destination 中<br>ZLEXCOUNT key min max<br>在有序集合中计算指定字典区间内成员数量<br>ZRANGE key start stop [WITHSCORES]<br>通过索引区间返回有序集合指定区间内的成员<br>ZRANGEBYLEX key min max [LIMIT offset count]<br>通过字典区间返回有序集合的成员<br>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT]<br>通过分数返回有序集合指定区间内的成员<br>ZRANK key member<br>返回有序集合中指定成员的索引<br>ZREM key member [member …]<br>移除有序集合中的一个或多个成员<br>ZREMRANGEBYLEX key min max<br>移除有序集合中给定的字典区间的所有成员<br>ZREMRANGEBYRANK key start stop<br>移除有序集合中给定的排名区间的所有成员<br>ZREMRANGEBYSCORE key min max<br>移除有序集合中给定的分数区间的所有成员<br>ZREVRANGE key start stop [WITHSCORES]<br>返回有序集中指定区间内的成员，通过索引，分数从高到低<br>ZREVRANGEBYSCORE key max min [WITHSCORES]<br>返回有序集中指定分数区间内的成员，分数从高到低排序<br>ZREVRANK key member<br>返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序<br>ZSCORE key member<br>返回有序集中，成员的分数值<br>ZUNIONSTORE destination numkeys key [key …]<br>计算给定的一个或多个有序集的并集，并存储在新的 key 中<br>ZSCAN key cursor [MATCH pattern] [COUNT count]<br>迭代有序集合中的元素（包括元素成员和元素分值）</p>
</blockquote>
<h4 id="8-HyperLogLog-命令"><a href="#8-HyperLogLog-命令" class="headerlink" title="8. HyperLogLog 命令"></a>8. HyperLogLog 命令</h4><blockquote>
<p>PFADD key element [element …]<br>添加指定元素到 HyperLogLog 中。<br>PFCOUNT key [key …]<br>返回给定 HyperLogLog 的基数估算值。<br>PFMERGE destkey sourcekey [sourcekey …]<br>将多个 HyperLogLog 合并为一个 HyperLogLog</p>
</blockquote>
<h3 id="redis发布订阅"><a href="#redis发布订阅" class="headerlink" title="redis发布订阅"></a>redis发布订阅</h3><p>Redis 发布订阅 (pub&#x2F;sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。<br>Redis 客户端可以订阅任意数量的频道。<br>发布订阅命令：</p>
<blockquote>
<p>PSUBSCRIBE pattern [pattern …]<br>订阅一个或多个符合给定模式的频道。<br>PUBSUB subcommand [argument [argument …]]<br>查看订阅与发布系统状态。<br>PUBLISH channel message<br>将信息发送到指定的频道。<br>PUNSUBSCRIBE [pattern [pattern …]]<br>退订所有给定模式的频道。<br>SUBSCRIBE channel [channel …]<br>订阅给定的一个或多个频道的信息。<br>UNSUBSCRIBE [channel [channel …]]<br>指退订给定的频道。</p>
</blockquote>
<h3 id="redis事务"><a href="#redis事务" class="headerlink" title="redis事务"></a>redis事务</h3><p>Redis 事务可以一次执行多个命令， 并且带有以下三个重要的保证：<br>批量操作在发送 EXEC 命令前被放入队列缓存。<br>收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。<br>在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。<br>一个事务从开始到执行会经历以下三个阶段：<br>开始事务。<br>命令入队。<br>执行事务。<br>事务命令：</p>
<blockquote>
<p>DISCARD<br>取消事务，放弃执行事务块内的所有命令。<br>EXEC<br>执行所有事务块内的命令。<br>MULTI<br>标记一个事务块的开始。<br>UNWATCH<br>取消 WATCH 命令对所有 key 的监视。<br>WATCH key [key …]<br>监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。</p>
</blockquote>
<h3 id="redis脚本"><a href="#redis脚本" class="headerlink" title="redis脚本"></a>redis脚本</h3><p>Redis 脚本使用 Lua 解释器来执行脚本.<br>脚本命令：</p>
<blockquote>
<p>EVAL script numkeys key [key …] arg [arg …]<br>执行 Lua 脚本。<br>EVALSHA sha1 numkeys key [key …] arg [arg …]<br>执行 Lua 脚本。<br>SCRIPT EXISTS script [script …]<br>查看指定的脚本是否已经被保存在缓存当中。<br>SCRIPT FLUSH<br>从脚本缓存中移除所有脚本。<br>SCRIPT KILL<br>杀死当前正在运行的 Lua 脚本。<br>SCRIPT LOAD script<br>将脚本 script 添加到脚本缓存中，但并不立即执行这个脚本。</p>
</blockquote>
<h3 id="redis连接"><a href="#redis连接" class="headerlink" title="redis连接"></a>redis连接</h3><p>连接命令：</p>
<blockquote>
<p>AUTH password<br>验证密码是否正确<br>ECHO message<br>打印字符串<br>PING<br>查看服务是否运行<br>QUIT<br>关闭当前连接<br>SELECT index<br>切换到指定的数据库</p>
</blockquote>
<h3 id="redis服务器"><a href="#redis服务器" class="headerlink" title="redis服务器"></a>redis服务器</h3><p>服务器命令:</p>
<blockquote>
<p>BGREWRITEAOF<br>异步执行一个 AOF（AppendOnly File） 文件重写操作<br>BGSAVE<br>在后台异步保存当前数据库的数据到磁盘<br>CLIENT KILL [ip:port] [ID client-id]<br>关闭客户端连接<br>CLIENT LIST<br>获取连接到服务器的客户端连接列表<br>CLIENT GETNAME<br>获取连接的名称<br>CLIENT PAUSE timeout<br>在指定时间内终止运行来自客户端的命令<br>CLIENT SETNAME connection-name<br>设置当前连接的名称<br>CLUSTER SLOTS<br>获取集群节点的映射数组<br>COMMAND<br>获取 Redis 命令详情数组<br>COMMAND COUNT<br>获取 Redis 命令总数<br>COMMAND GETKEYS<br>获取给定命令的所有键<br>TIME<br>返回当前服务器时间<br>COMMAND INFO command-name [command-name …]<br>获取指定 Redis 命令描述的数组<br>CONFIG GET parameter<br>获取指定配置参数的值<br>CONFIG REWRITE<br>对启动 Redis 服务器时所指定的 redis.conf 配置文件进行改写<br>CONFIG SET parameter value<br>修改 redis 配置参数，无需重启<br>CONFIG RESETSTAT<br>重置 INFO 命令中的某些统计数据<br>DBSIZE<br>返回当前数据库的 key 的数量<br>DEBUG OBJECT key<br>获取 key 的调试信息<br>DEBUG SEGFAULT<br>让 Redis 服务崩溃<br>FLUSHALL<br>删除所有数据库的所有key<br>FLUSHDB<br>删除当前数据库的所有key<br>INFO [section]<br>获取 Redis 服务器的各种信息和统计数值<br>LASTSAVE<br>返回最近一次 Redis 成功将数据保存到磁盘上的时间，以 UNIX 时间戳格式表示<br>MONITOR<br>实时打印出 Redis 服务器接收到的命令，调试用<br>ROLE<br>返回主从实例所属的角色<br>SAVE<br>同步保存数据到硬盘<br>SHUTDOWN [NOSAVE] [SAVE]<br>异步保存数据到硬盘，并关闭服务器<br>SLAVEOF host port<br>将当前服务器转变为指定服务器的从属服务器(slave server)<br>SLOWLOG subcommand [argument]<br>管理 redis 的慢日志</p>
</blockquote>
<h3 id="redis-Stream"><a href="#redis-Stream" class="headerlink" title="redis Stream"></a>redis Stream</h3><p>Redis 5.0 版本新增加的数据结构。<br>Redis Stream 主要用于消息队列（MQ，Message Queue），Redis 本身是有一个 Redis 发布订阅 (pub&#x2F;sub) 来实现消息队列的功能，但它有个缺点就是消息无法持久化，如果出现网络断开、Redis 宕机等，消息就会被丢弃。<br>简单来说发布订阅 (pub&#x2F;sub) 可以分发消息，但无法记录历史消息。<br>而 Redis Stream 提供了消息的持久化和主备复制功能，可以让任何客户端访问任何时刻的数据，并且能记住每一个客户端的访问位置，还能保证消息不丢失。</p>
<hr>
<p>😛END</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring入门</title>
    <url>/posts/421a3e14.html</url>
    <content><![CDATA[<h3 id="Spring简介"><a href="#Spring简介" class="headerlink" title="Spring简介"></a>Spring简介</h3><p>Spring是一个分层的Java SE&#x2F;EE应用一站式的轻量级开源框架。Spring核心是IOC和AOP<br>Spring主要优点包括：<br>方便解耦，简化开发，通过Spring提供的IoC容器，我们可以将对象之间的依赖关系交由Spring进行控制，避免硬编码造成的程序耦合度高。<br>AOP编程的支持，通过Spring提供的AOP功能，方便进行面向切面编程。<br>声明式事务的支持，在Spring中，我们可以从单调烦闷的事务管理代码中解脱出来，通过声明式方式灵活地进行事务的管理，提高开发效率和质量。<br>方便程序的测试，可以用非容器依赖的编程方式进行几乎所有的测试工作。<br>方便集成各种优秀框架，Spring提供了对各种优秀框架的直接支持。</p>
<h3 id="Spring体系结构"><a href="#Spring体系结构" class="headerlink" title="Spring体系结构"></a>Spring体系结构</h3><p>Spring 框架是一个分层架构，整个spring框架按其所属功能可以划分为五个主要模块。<br>这些模块分为<br>Rore Container ： Beans Core Context Expression Language<br>Date Access&#x2F;Integration ：JDBC ORM OXM JMS Transactions<br>Web ：Web Servlet Portlet Struts<br>AOP(Aspect Oriented Programming)<br>Instrumentation<br>test</p>
<h4 id="核心模块-Core-Container"><a href="#核心模块-Core-Container" class="headerlink" title="核心模块(Core Container)"></a>核心模块(Core Container)</h4><p>Spring的核心模块实现了IoC的功能，它将类和类之间的依赖从代码中脱离出来，用配置的方式进行依赖关系描述。由IoC容器负责类的创建，管理，获取等。BeanFactory接口是Spring框架的核心接口，实现了容器很多核心的功能。<br>Context模块构建于核心模块之上，扩展了BeanFactory的功能，包括国际化，资源加载，邮件服务，任务调度等多项功能。ApplicationContext是Context模块的核心接口。<br>表达式语言(Expression Language)是统一表达式语言(EL)的一个扩展，支持设置和获取对象属性，调用对象方法，操作数组、集合等。使用它可以很方便的通过表达式和Spring IoC容器进行交互。</p>
<h4 id="AOP模块"><a href="#AOP模块" class="headerlink" title="AOP模块"></a>AOP模块</h4><p>Spring AOP模块提供了满足AOP Alliance规范的实现，还整合了AspectJ这种AOP语言级的框架。通过AOP能降低耦合。</p>
<h4 id="数据访问集成模块（Data-Access-x2F-Integration-）"><a href="#数据访问集成模块（Data-Access-x2F-Integration-）" class="headerlink" title="数据访问集成模块（Data Access&#x2F;Integration ）"></a>数据访问集成模块（Data Access&#x2F;Integration ）</h4><p>该模块包括了JDBC、ORM、OXM、JMS和事务管理：<br>事务模块：该模块用于Spring管理事务，只要是Spring管理对象都能得到Spring管理事务的好处，无需在代码中进行事务控制了，而且支持编程和声明性的事务管理。<br>JDBC模块：提供了一个JBDC的样例模板，使用这些模板能消除传统冗长的JDBC编码还有必须的事务控制，而且能享受到Spring管理事务的好处。<br>ORM模块：提供与流行的“对象-关系”映射框架的无缝集成，包括hibernate、JPA、MyBatis等。而且可以使用Spring事务管理，无需额外控制事务。<br>OXM模块：提供了一个对Object&#x2F;XML映射实现，将Java对象映射成XML数据，或者将XML数据映射成java对象，Object&#x2F;XML映射实现包括JAXB、Castor、XMLBeans和XStream。<br>JMS模块：用于JMS(Java Messaging Service)，提供一套“消息生产者、消息消费者”模板用于更加简单的使用JMS，JMS用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。</p>
<h4 id="Web模块"><a href="#Web模块" class="headerlink" title="Web模块"></a>Web模块</h4><p>该模块建立在ApplicationContext模块之上，提供了Web应用的功能，如文件上传、FreeMarker等。Spring可以整合Struts2等MVC框架。此外，Spring自己提供了MVC框架Spring MVC。</p>
<h4 id="测试模块"><a href="#测试模块" class="headerlink" title="测试模块"></a>测试模块</h4><p>Spring可以用非容器依赖的编程方式进行几乎所有的测试工作，支持JUnit和TestNG等测试框架。</p>
<h3 id="初识IOC与DI"><a href="#初识IOC与DI" class="headerlink" title="初识IOC与DI"></a>初识IOC与DI</h3><h4 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h4><p>IoC(控制反转:Inverse of Control)是Spring容器的核心<br>DI（依赖注入：Dependency Injection）</p>
<h4 id="控制反转与依赖注入："><a href="#控制反转与依赖注入：" class="headerlink" title="控制反转与依赖注入："></a>控制反转与依赖注入：</h4><p>传统程序设计中，我们需要使用某个对象的方法，需要先通过new创建一个该对象，我们这时是主动行为；而IoC是我们将创建对象的控制权交给IoC容器，这时是由容器帮忙创建及注入依赖对象，我们的程序被动的接受IoC容器创建的对象，控制权反转，所以叫控制反转。<br>IoC是目的，DI是手段，创建对象的过程往往意味着依赖的注入。我们为了实现IoC，让生成对象的方式由传统方式(new)反转过来，需要创建相关对象时由IoC容器帮我们注入(DI)。<br>简单的说，就是我们类里需要另一个类，只需要让Spring帮我们创建 ，这叫做控制反转；然后Spring帮我们将需要的对象设置到我们的类中，这叫做依赖注入。</p>
<h4 id="常见的几种注入方法："><a href="#常见的几种注入方法：" class="headerlink" title="常见的几种注入方法："></a>常见的几种注入方法：</h4><p>使用有参构造方法注入<br>使用属性注入<br>使用接口注入<br>通过容器完成依赖关系的注入<br>Spring就是这样的容器，一个第三方容器能帮助我们完成类的实例化，以及依赖关系的装配，那么我们只需要专注于业务逻辑的开发即可。它通过配置文件或注解描述类和类之间的依赖关系，自动完成类的初始化和依赖注入的工作。</p>
<h3 id="资源访问Resource接口"><a href="#资源访问Resource接口" class="headerlink" title="资源访问Resource接口"></a>资源访问Resource接口</h3><p>Spring设计了一个Resource接口，为应用提供了更强的访问底层资源的能力，该接口拥有对应不同资源类型的实现类。</p>
<h4 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h4><p>boolean exists()：资源是否存在<br>boolean isOpen()：资源是否打开<br>URL getURL()：返回对应资源的URL<br>File getFile()：返回对应的文件对象<br>InputStream getInputStream()：返回对应资源的输入流</p>
<h4 id="具体实现类"><a href="#具体实现类" class="headerlink" title="具体实现类"></a>具体实现类</h4><p>ByteArrayResource：二进制数组表示的资源<br>ClassPathResource：类路径下的资源 ，资源以相对于类路径的方式表示<br>FileSystemResource：文件系统资源，资源以文件系统路径方式表示，如d:&#x2F;a&#x2F;b.txt<br>InputStreamResource：对应一个InputStream的资源<br>ServletContextResource：为访问容器上下文中的资源而设计的类。负责以相对于web应用根目录的路径加载资源<br>UrlResource：封装了java.net.URL。用户能够访问任何可以通过URL表示的资源，如Http资源，Ftp资源等</p>
<h4 id="资源加载机制"><a href="#资源加载机制" class="headerlink" title="资源加载机制"></a>资源加载机制</h4><p>为了访问不同类型的资源，必须使用相应的Resource实现类，这是比较麻烦的。Spring提供了一个强大的加载资源的机制，仅通过资源地址的特殊标识就可以加载相应的资源。<br>首先，我们了解一下Spring支持哪些资源类型的地址前缀:<br>classpath：例如classpath:com&#x2F;cad&#x2F;domain&#x2F;bean.xml。从类路径中加载资源<br>file：例如 file:com&#x2F;cad&#x2F;domain&#x2F;bean.xml.使用UrlResource从文件系统目录中加载资源。<br>http：&#x2F;&#x2F; 例如<a href="http://www.baidu.com/resource/bean.xml">http://www.baidu.com/resource/bean.xml</a> 使用UrlResource从web服务器加载资源<br>ftp：&#x2F;&#x2F; 例如frp:&#x2F;&#x2F;10.22.10.11&#x2F;bean.xml 使用UrlResource从ftp服务器加载资源<br>Spring定义了一套资源加载的接口。ResourceLoader接口仅有一个getResource(String location)的方法，可以根据资源地址加载文件资源。资源地址仅支持带资源类型前缀的地址，不支持Ant风格的资源路径表达式。ResourcePatternResolver扩展ResourceLoader接口，定义新的接口方法getResources(String locationPattern)，该方法支持带资源类型前缀以及Ant风格的资源路径的表达式。PathMatchingResourcePatternResolver是Spring提供的标准实现类。</p>
<h3 id="详解Ioc容器"><a href="#详解Ioc容器" class="headerlink" title="详解Ioc容器"></a>详解Ioc容器</h3><h4 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h4><p>BeanFactory是一个类工厂，和传统的类工厂不同，传统的类工厂仅负责构造一个类或几个类的实例；而BeanFactory可以创建并管理各种类的对象，Spring称这些被创建和管理的Java对象为Bean。<br>BeanFactory是一个接口，Spring为BeanFactory提供了多种实现，最常用的就是XmlBeanFactory。其中，BeanFactory接口最主要的方法就是getBean(String beanName)，该方法从容器中返回指定名称的Bean。此外，BeanFactory接口的功能可以通过实现它的接口进行扩展(比如ApplicationContext)。</p>
<h4 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h4><p>ApplicationContext由BeanFactory派生而来，提供了更多面向实际应用的功能。在BeanFactory中，很多功能需要编程方式来实现，而ApplicationContext中可以通过配置的方式来实现。ApplicationContext的主要实现类是ClassPathXmlApplicationContext和FileSystemXmlApplicationContext，前者默认从类路径加载配置文件，后者默认从文件系统中加载配置文件<br>ApplicationContext的初始化和BeanFactory初始化有一个重大的区别：<br>BeanFactory初始化容器时并未初始化Bean，只有第一次访问Bean时才创建；而ApplicationContext则在初始化时就实例化所有的单实例的Bean。因此，ApplicationContext的初始化时间会稍长一点。</p>
<h4 id="WebApplicationContext"><a href="#WebApplicationContext" class="headerlink" title="WebApplicationContext"></a>WebApplicationContext</h4><p>WebApplicationContext是专门为Web应用准备的，它允许以相对于Web根目录的路径中加载配置文件完成初始化工作。从WebApplicationContext中可以获取ServletContext的引用，整个WebApplicationContext对象作为属性放置到ServletContext中，以便Web应用环境中可以访问Spring应用上下文。ConfigurableWebApplicationContext扩展了WebApplicationContext,允许通过配置方式实例化WebApplicationContext，定义了两个重要方法。<br>setServletContext(ServletContext servletcontext)：为Spring设置ServletContext<br>setConfigLocation(String[] configLocations)：设置Spring配置文件地址。<br>WebApplicationContext初始化的时机和方式是：利用Spring提供的ContextLoaderListener监听器去监听ServletContext对象的创建，当ServletContext对象创建时，创建并初始化WebApplicationContext对象。因此，我们只需要在web.xml配置监听器即可。</p>
<h4 id="BeanFactory、ApplicationContext和WebApplicationContext的联系与区别"><a href="#BeanFactory、ApplicationContext和WebApplicationContext的联系与区别" class="headerlink" title="BeanFactory、ApplicationContext和WebApplicationContext的联系与区别"></a>BeanFactory、ApplicationContext和WebApplicationContext的联系与区别</h4><p>Spring通过一个配置文件描述Bean与Bean之间的依赖关系，通过Java语言的反射技术能实例化Bean并建立Bean之间的依赖关系。Spring的IoC容器在完成这些底层工作的基础上，还提供了bean实例缓存、生命周期管理、事件发布，资源装载等高级服务。<br>BeanFactory是Spring最核心的接口，提供了高级IoC的配置机制。ApplicationContext建立在BeanFactory的基础上，是BeanFactory的子接口，提供了更多面向应用的功能。我们一般称BeanFactory为IoC容器，ApplicationContext为应用上下文，也称为Spring容器。WebApplicationContext是专门为Web应用准备的，它允许以相对于Web根目录的路径中加载配置文件完成初始化工作，是ApplicationContext接口的子接口。<br>BeanFactory是Spring框架的基础，面向Spring本身；ApplicationContext面向使用Spring框架的开发者，几乎所有的应用我们都直接使用ApplicationContext而非底层的BeanFactory；WebApplicationContext是专门用于Web应用。</p>
<h4 id="父子容器"><a href="#父子容器" class="headerlink" title="父子容器"></a>父子容器</h4><p>通过HierarchicalBeanFactory接口，Spring的IoC容器可以建立父子层级关联的体系：子容器可以访问父容器的Bean，父容器不能访问子容器的Bean。<br>Spring使用父子容器实现了很多功能，比如在Spring MVC中，控制器Bean位于子容器中，业务层和持久层Bean位于父容器中。但即使这样，控制器Bean也可以引用持久层和业务层的Bean，而业务层和持久层就看不到控制器Bean。</p>
<h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><p>面向切面的编程 (AOP) </p>
<h4 id="AOP-术语："><a href="#AOP-术语：" class="headerlink" title="AOP 术语："></a>AOP 术语：</h4><p>Aspect<br>这是一个模块，它具有一组提供横切要求的 API。 例如，日志记录模块将被称为 AOP 切面的日志记录。 根据要求，应用程序可以具有任意数量的切面。<br>Join point<br>这代表了您的应用程序中的一个点，您可以在其中插入 AOP 切面。 您也可以说，它是应用程序中使用 Spring AOP 框架执行操作的实际位置。	<br>Advice<br>这是在方法执行之前或之后要采取的实际操作。 这是一段由 Spring AOP 框架在程序执行期间调用的实际代码。	<br>Pointcut<br>这是应该执行通知的一组一个或多个连接点。 正如我们将在 AOP 示例中看到的那样，您可以使用表达式或模式指定切入点<br>Introduction<br>Introduction 允许您向现有类添加新方法或属性。<br>Target object<br>一个或多个切面所通知的对象。 此对象将始终是代理对象，也称为通知对象。<br>Weaving<br>Weaving 是将切面与其他应用程序类型或对象链接以创建通知对象的过程。 这可以在编译时、加载时或运行时完成。</p>
<h4 id="通知类型："><a href="#通知类型：" class="headerlink" title="通知类型："></a>通知类型：</h4><p>before<br>在方法执行之前运行通知。<br>after<br>在方法执行后运行通知，无论其结果如何。<br>after-returning<br>仅当方法成功完成时，才在方法执行后运行通知。	<br>after-throwing<br>仅当方法因抛出异常而退出时，才在方法执行后运行通知。<br>around<br>在调用建议方法之前和之后运行通知。</p>
<h4 id="自定义切面实现"><a href="#自定义切面实现" class="headerlink" title="自定义切面实现"></a>自定义切面实现</h4><p>Spring 支持 @AspectJ annotation style 方法和 schema-based 方法来实现自定义切面<br>基于 XML 模式<br>切面是使用常规类和基于 XML 的配置来实现的。<br>基于@AspectJ<br>@AspectJ 指的是一种将切面声明为使用 Java 5 注解进行注解的常规 Java 类的风格。</p>
<h3 id="Bean"><a href="#Bean" class="headerlink" title="Bean"></a>Bean</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>构成应用程序主干并由 Spring IoC 容器管理的对象称为 beans。bean 是由 Spring IoC 容器实例化、组装和管理的对象。 这些 bean 使用您提供给容器的配置元数据创建。 例如，以 XML &lt;bean&#x2F;&gt; 的形式</p>
<h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>在定义 &lt;bean&gt; 时，您可以选择为该 bean 声明一个作用域。 例如，要强制 Spring 在每次需要时生成一个新的 bean 实例，您应该将 bean 的 scope 属性声明为 prototype。 同样，如果您希望 Spring 在每次需要时返回相同的 bean 实例，您应该将 bean 的 scope 属性声明为 singleton。<br>五个作用域：<br>singleton<br>这将 bean 定义范围限定为每个 Spring IoC 容器的单个实例（默认）。<br>prototype<br>这将单个 bean 定义的范围限定为具有任意数量的对象实例。<br>request<br>这将 bean 定义的范围限定为 HTTP 请求。 仅在 Web 感知 Spring ApplicationContext 的上下文中有效。<br>session<br>这将 bean 定义范围限定为 HTTP 会话。 仅在 Web 感知 Spring ApplicationContext 的上下文中有效。<br>global-session<br>这将 bean 定义范围限定为全局 HTTP 会话。 仅在 Web 感知 Spring ApplicationContext 的上下文中有效。</p>
<h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>实例化 bean 时，可能需要执行一些初始化以使其进入可用状态。 同样，当不再需要 bean 并将其从容器中取出时，可能需要进行一些清理。<br>要为 bean 定义设置和销毁，我们只需使用 initmethod 和&#x2F;或 destroy-method 参数声明 &lt;bean&gt;。 init-method 属性指定了在实例化时立即在 bean 上调用的方法。 类似地，destroymethod 指定了一个在从容器中删除 bean 之前调用的方法。</p>
<h4 id="回调方法"><a href="#回调方法" class="headerlink" title="回调方法"></a>回调方法</h4><p>BeanPostProcessor 接口定义了回调方法，你可以实现这些方法来提供你自己的实例化逻辑、依赖解析逻辑等。你也可以在Spring容器完成实例化、配置和初始化一个 bean 通过插入一个或多个 BeanPostProcessor 实现。<br>您可以配置多个 BeanPostProcessor 接口，并且您可以通过设置 order 属性来控制这些 BeanPostProcessor 接口的执行顺序，前提是 BeanPostProcessor 实现了 Ordered 接口。<br>BeanPostProcessor 对 bean（或对象）实例进行操作，这意味着 Spring IoC 容器实例化一个 bean 实例，然后 BeanPostProcessor 接口完成它们的工作。<br>ApplicationContext 会自动检测任何通过 BeanPostProcessor 接口的实现定义的 bean，并将这些 bean 注册为 postprocessors，然后在 bean 创建时由容器适当地调用。</p>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>一个 bean 定义可以包含很多配置信息，包括构造函数参数、属性值以及容器特定的信息，例如初始化方法、static factory 方法名称等。<br>子 bean 定义继承父定义的配置数据。 子定义可以根据需要覆盖某些值或添加其他值。<br>Spring Bean 定义继承与 Java 类继承无关，但继承概念是相同的。 您可以将父 bean 定义定义为模板，其他子 bean 可以从父 bean 继承所需的配置。<br>当您使用基于 XML 的配置元数据时，您可以通过使用 parent 属性来指示子 bean 定义，并将父 bean 指定为该属性的值。</p>
<h4 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h4><p>Spring 容器可以在协作 bean 之间自动装配关系，而无需使用 &lt;constructor-arg&gt; 和 &lt;property&gt; 元素，这有助于减少您为基于 Spring 的大型应用程序编写的 XML 配置量。</p>
<h3 id="基于注解的配置"><a href="#基于注解的配置" class="headerlink" title="基于注解的配置"></a>基于注解的配置</h3><p>从 Spring 2.5 开始，可以使用 annotations 配置依赖注入。 因此，您可以通过在相关类、方法或字段声明上使用注解，将 bean 配置移动到组件类本身，而不是使用 XML 来描述 bean 连接。<br>注解注入在 XML 注入之前执行。 因此，对于通过这两种方法连接的属性，后一种配置将覆盖前者。<br>默认情况下，Spring 容器中未开启注解连接。 因此，在我们可以使用基于注解的连接之前，我们需要在 Spring 配置文件中启用它。 因此，如果您想在 Spring 应用程序中使用任何注解，请考虑以下配置文件。<br>重要注解：<br>@Required<br>@Required 注解适用于 bean 属性设置器方法。<br>@Autowired<br>@Autowired 注解可以应用于 bean 属性设置方法、非设置方法、构造函数和属性。<br>@Qualifier<br>@Qualifier 注解和@Autowired 可用于通过指定将被连接的确切bean 来消除混淆。<br>JSR-250 注解<br>Spring 支持基于 JSR-250 的注解，其中包括 @Resource、@PostConstruct 和 @PreDestroy 注解。</p>
<h3 id="基于-Java-的配置"><a href="#基于-Java-的配置" class="headerlink" title="基于 Java 的配置"></a>基于 Java 的配置</h3><p>@Configuration &amp; @Bean 注解<br>使用 @Configuration 注解一个类表明该类可以被 Spring IoC 容器用作 bean 定义的来源。 @Bean 注解告诉 Spring，使用 @Bean 注解的方法将返回一个对象，该对象应在 Spring 应用程序上下文中注册为 bean。<br>@Bean 注解<br>当@Beans相互依赖时，表示依赖就像让一个bean方法调用另一个bean方法一样简单<br>@Import 注解<br>@Import 注解允许从另一个配置类加载@Bean 定义。<br>生命周期回调<br>@Bean 注解支持指定任意初始化和销毁回调方法，很像 Spring XML 的 bean 元素上的 init-method 和 destroy-method 属性<br>指定 Bean 作用域<br>默认作用域是 singleton (单例)，但您可以使用 @Scope 注解覆盖它</p>
<h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><p>ApplicationContext，它管理 bean 的完整生命周期。 ApplicationContext 在加载 bean 时发布某些类型的事件。 例如，ContextStartedEvent 在上下文启动时发布，ContextStoppedEvent 在上下文停止时发布。<br>ApplicationContext 中的事件处理是通过ApplicationEvent 类和ApplicationListener 接口提供的。 因此，如果 bean 实现了 ApplicationListener，那么每次 ApplicationEvent 发布到 ApplicationContext 时，都会通知该 bean。</p>
<hr>
<p>😎END</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot入门</title>
    <url>/posts/1d3cd056.html</url>
    <content><![CDATA[<h3 id="SpringBoot简介"><a href="#SpringBoot简介" class="headerlink" title="SpringBoot简介"></a>SpringBoot简介</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>Spring Boot 的设计是为了让你尽可能快的跑起来 Spring 应用程序并且尽可能减少你的配置文件。</p>
<h4 id="四个主要特性"><a href="#四个主要特性" class="headerlink" title="四个主要特性"></a>四个主要特性</h4><p>1、SpringBoot Starter：他将常用的依赖分组进行了整合，将其合并到一个依赖中，这样就可以一次性添加到项目的Maven或Gradle构建中；</p>
<p>2、自动配置：SpringBoot的自动配置特性利用了Spring4对条件化配置的支持，合理地推测应用所需的bean并自动化配置他们；</p>
<p>3、命令行接口：（Command-line-interface, CLI）：SpringBoot的CLI发挥了Groovy编程语言的优势，并结合自动配置进一步简化Spring应用的开发；</p>
<p>4、Actuatir：它为SpringBoot应用的所有特性构建一个小型的应用程序。但首先，我们快速了解每项特性，更好的体验他们如何简化Spring编程模型。</p>
<h3 id="SpringBoot-starter启动器"><a href="#SpringBoot-starter启动器" class="headerlink" title="SpringBoot starter启动器"></a>SpringBoot starter启动器</h3><p>Spring Boot 将日常企业应用研发中的各种场景都抽取出来，做成一个个的 starter（启动器），starter 中整合了该场景下各种可能用到的依赖，用户只需要在 Maven 中引入 starter 依赖，SpringBoot 就能自动扫描到要加载的信息并启动相应的默认配置。starter 提供了大量的自动配置，让用户摆脱了处理各种依赖和配置的困扰。所有这些 starter 都遵循着约定成俗的默认配置，并允许用户调整这些配置，即遵循“约定大于配置”的原则。</p>
<h4 id="自定义starter"><a href="#自定义starter" class="headerlink" title="自定义starter"></a>自定义starter</h4><p>代码实现：<br>1.导入依赖<br>2.编写JavaBean<br>3.编写配置类MyAutoConfiguration<br>4.esources下创建&#x2F;META-INF&#x2F;spring.factories<br>使用自定义starter：<br>1.对应项目导入自定义starter的依赖<br>2.在全局配置文件中配置属性值<br>热插拔技术：<br>@Enablexxx注解就是一种热拔插技术，加了这个注解就可以启动对应的starter，当不需要对应的starter的时候只需要把这个注解注释掉就行。<br>1.新增标记类ConfigMarker<br>2.新增EnableRegisterServer注解，将@Import引入的组件类生成实例，添加进容器<br>3.改造 MyAutoConfiguration 新增条件注解 @ConditionalOnBean(ConfigMarker.class) ，@ConditionalOnBean 这个是条件注解，前面的意思代表只有当期上下文中含有 ConfigMarker对象，被标注的类才会被实例化，才能让自动配置类生效。<br>4.在启动类上新增上面自定义@EnableRegisterServer注解，根据之前的源码分析可以知道他在执行过程中会解析这个注解，再去解析里面的@Import注解，从而拿到组件类生成实例化对象存入容器，满足自动装配条件。</p>
<h4 id="spring-boot-starter-parent"><a href="#spring-boot-starter-parent" class="headerlink" title="spring-boot-starter-parent"></a>spring-boot-starter-parent</h4><p>spring-boot-starter-parent 是所有 Spring Boot 项目的父级依赖，它被称为 Spring Boot 的版本仲裁中心，可以对项目内的部分常用依赖进行统一管理。<br>Spring Boot 项目可以通过继承 spring-boot-starter-parent 来获得一些合理的默认配置，它主要提供了以下特性：<br>默认 JDK 版本（Java 8）<br>默认字符集（UTF-8）<br>依赖管理功能<br>资源过滤<br>默认插件配置<br>识别 application.properties 和 application.yml 类型的配置文件</p>
<h4 id="spring-boot-starter-web"><a href="#spring-boot-starter-web" class="headerlink" title="spring-boot-starter-web"></a>spring-boot-starter-web</h4><p>spring-boot-starter-web ，它能够为提供 Web 开发场景所需要的几乎所有依赖，因此在使用 Spring Boot 开发 Web 项目时，只需要引入该 Starter 即可，而不需要额外导入 Web 服务器和其他的 Web 依赖。、</p>
<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><h4 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h4><p>他是一个组合注解，是项目的核心启动类。<br>由@SpringBootConfiguration、@EnableAutoConfiguration、@ComponentScan这三个注解构成<br>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(excludeFilters = &#123;</span></span><br><span class="line"><span class="meta">		@Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span></span><br><span class="line"><span class="meta">		@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="SpringBootConfiguration"><a href="#SpringBootConfiguration" class="headerlink" title="@SpringBootConfiguration"></a>@SpringBootConfiguration</h4><p>核心启动类注解源码中含此注解，这个注解标注在某个类上，表示这是一个 Spring Boot的配置类。他的核心代码中，内部有一个核心注解@Configuration来表明当前类是配置类，并且可以被组件扫描器扫到，所以@SpringBootConfiguration与@Configuration具有相同作用，只是前者又做了一次封装。<br>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootConfiguration &#123;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h4><p>主要作用是从定义的扫描路径中，找出标识了需要装配的类自动装配到spring 的bean容器中。默认扫描路径是为@ComponentScan注解的类所在的包为基本的扫描路径（也就是标注了@SpringBootApplication注解的项目启动类所在的路径），所以这里就解释了之前spring boot为什么只能扫描自己所在类的包及其子包。<br>我们可以通过basePackages等属性来细粒度的定制@ComponentScan自动扫描的范围，如果不指定，则默认Spring框架实现会从声明@ComponentScan所在类的package进行扫描。<br>所以SpringBoot的启动类最好是放在root package下，因为默认不指定basePackages。<br>常用属性：<br>basePackages、value：指定扫描路径，如果为空则以@ComponentScan注解的类所在的包为基本的扫描路径。<br>basePackageClasses：指定具体扫描的类。<br>includeFilters：指定满足Filter条件的类。<br>excludeFilters：指定排除Filter条件的类。<br>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Repeatable(ComponentScans.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ComponentScan &#123;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="🍉-EnableAutoConfiguration"><a href="#🍉-EnableAutoConfiguration" class="headerlink" title="🍉@EnableAutoConfiguration"></a>🍉@EnableAutoConfiguration</h4><p>Spring 中有很多以 Enable 开头的注解，其作用就是借助 @Import 来收集并注册特定场景相关的Bean ，并加载到 IOC 容器。而这个注解就是借助@Import来收集所有符合自动配置条件的bean定义，并加载到IoC容器。<br>@EnableAutoConfiguration会根据类路径中的jar依赖为项目进行自动配置，如：添加了spring-boot-starter-web依赖，会自动添加Tomcat和Spring MVC的依赖，Spring Boot会对Tomcat和Spring MVC进行自动配置。<br>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;deprecation&quot;)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import(EnableAutoConfigurationImportSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="AutoConfigurationPackage"><a href="#AutoConfigurationPackage" class="headerlink" title="@AutoConfigurationPackage"></a>@AutoConfigurationPackage</h4><p>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Import(AutoConfigurationPackages.Registrar.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AutoConfigurationPackage &#123;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Import-AutoConfigurationImportSelector-class"><a href="#Import-AutoConfigurationImportSelector-class" class="headerlink" title="@Import(AutoConfigurationImportSelector.class)"></a>@Import(AutoConfigurationImportSelector.class)</h4><p>该注解是Spring boot的底层注解，AutoConfigurationImportSelector类可以帮助 Springboot 应用将所有符合条件的 @Configuration配置都加载到当前Spring Boot创建并使用的IOC容器( ApplicationContext )中。</p>
<h3 id="内嵌tomcat原理"><a href="#内嵌tomcat原理" class="headerlink" title="内嵌tomcat原理"></a>内嵌tomcat原理</h3><p>Spring Boot默认支持Tomcat，Jetty，和Undertow作为底层容器。而Spring Boot默认使用Tomcat，一旦引入spring-boot-starter-web模块，就默认使用Tomcat容器。<br>通过前面我们可以知道核心启动类在启动的时候，进入AutoConfigurationImportSelector类中的getAutoConfigurationEntry方法去各个模块WEB-INF下的spring.factories配置文件中加载相关配置类，获取到ServletWebServerFactoryAutoConfiguration自动配置类，也就是tomcat自动配置。</p>
<h4 id="自动配置Spring-MVC"><a href="#自动配置Spring-MVC" class="headerlink" title="自动配置Spring MVC"></a>自动配置Spring MVC</h4><p>SpringBoot项目里面是可以直接使用诸如 @RequestMapping 这类的SpringMVC的注解，在以前的项目中除了引入包之外还需要在web.xml配置一个前端控制器org.springframework.web.servlet.DispatcherServlet。spring Boot通过自动装配就实现了相同的效果, IOC容器的注入后，最重要的一点就是需要把DispatcherServlet再注册进servletContext中，也就是servlet容器中。</p>
<hr>
<p>😎END</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC入门</title>
    <url>/posts/30e1f2b1.html</url>
    <content><![CDATA[<h3 id="SpringMVC简介"><a href="#SpringMVC简介" class="headerlink" title="SpringMVC简介"></a>SpringMVC简介</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>SpringMVC就是一个Spring内置的MVC框架。<br>MVC框架，它解决WEB开发中常见的问题(参数接收、文件上传、表单验证、国际化等等)，而且使用简单，与Spring无缝集成。支持 RESTful风格的URL请求。<br>采用了松散耦合可插拔组件结构，比其他 MVC 框架更具扩展性和灵活性。</p>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>MVC模式(Model-View-Controller)：解决页面代码和后台代码的分离</p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>在没有使用SpringMVC之前我们都是使用Servlet在做Web开发。但是使用Servlet开发在接收请求参数，数据共享，页面跳转等操作相对比较复杂。servlet是java进行web开发的标准，那么很显然SpringMVC底层就是Servlet，SpringMVC就是对Servlet进行深层次的封装。</p>
<h3 id="MVC模式"><a href="#MVC模式" class="headerlink" title="MVC模式"></a>MVC模式</h3><p>MVC分别是：模型model(javabean)、视图view(jsp&#x2F;img)、控制器Controller(Action&#x2F;servlet)。<br>C存在的目的就是为了保证M和V的一致性，当M发生改变时，C可以把M中的新内容更新到V中。</p>
<h3 id="SpringMVC执行流程和原理"><a href="#SpringMVC执行流程和原理" class="headerlink" title="SpringMVC执行流程和原理"></a>SpringMVC执行流程和原理</h3><p>执行流程：<br>01、用户发送出请求被前端控制器DispatcherServlet拦截进行处理。<br>02、DispatcherServlet收到请求调用HandlerMapping（处理器映射器）。<br>03、HandlerMapping找到具体的处理器(查找xml配置或注解配置)，生成处理器对象及处理器拦截器(如果有)，再一起返回给DispatcherServlet。<br>04、DispatcherServlet调用HandlerAdapter（处理器适配器）。<br>05、HandlerAdapter经过适配调用具体的处理器（Handler&#x2F;Controller）。<br>06、Controller执行完成返回ModelAndView对象。<br>07、HandlerAdapter将Controller执行结果ModelAndView返回给DispatcherServlet。<br>08、DispatcherServlet将ModelAndView传给ViewReslover（视图解析器）。<br>09、ViewReslover解析ModelAndView后返回具体View（视图）给DispatcherServlet。<br>10、DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。<br>11、DispatcherServlet响应View给用户。<br>涉及到的组件分析：<br>1、前端控制器DispatcherServlet（不需要程序员开发）由框架提供，在web.xml中配置。<br>作用：接收请求，响应结果，相当于转发器，中央处理器。</p>
<p>2、处理器映射器HandlerMapping（不需要程序员开发）由框架提供。<br>作用：根据请求的url查找Handler（处理器&#x2F;Controller），可以通过XML和注解方式来映射。</p>
<p>3、处理器适配器HandlerAdapter（不需要程序员开发）由框架提供。<br>作用：按照特定规则（HandlerAdapter要求的规则）去执行Handler中的方法。</p>
<p>4、处理器Handler（也称之为Controller，需要程序员开发）<br>注意：编写Handler时按照HandlerAdapter的要求去做，这样适配器才可以去正确执行Handler。<br>作用：接受用户请求信息，调用业务方法处理请求，也称之为后端控制器。</p>
<p>5、视图解析器ViewResolver（不需要程序员开发）由框架提供。<br>作用：进行视图解析，把逻辑视图解析成真正的物理视图。<br>SpringMVC框架支持多种View视图技术，包括：jstlView、freemarkerView、ThymeleafView等。</p>
<p>6、视图View（需要工程师开发）<br>作用：把数据展现给用户的页面<br>View是一个接口，实现类支持不同的View技术（jsp、freemarker、pdf等）</p>
<hr>
<p>🥰END</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>yaml入门</title>
    <url>/posts/a03240f4.html</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>YAML 全称 YAML Ain’t Markup Language，它是一种以数据为中心的标记语言，比 XML 和 JSON 更适合作为配置文件。<br>想要使用 YAML 作为属性配置文件（以 .yml 或 .yaml 结尾），需要将 SnakeYAML 库添加到 classpath 下，Spring Boot 中的 spring-boot-starter-web 或 spring-boot-starter 都对 SnakeYAML 库做了集成， 只要项目中引用了这两个 Starter 中的任何一个，Spring Boot 会自动添加 SnakeYAML 库到 classpath 下。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>使用缩进表示层级关系。<br>缩进时不允许使用 Tab 键，只允许使用空格。<br>缩进的空格数不重要，但同级元素必须左侧对齐。<br>大小写敏感。<br>例如:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="string">dev</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://127.0.01/project_springboot</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br></pre></td></tr></table></figure>
<h3 id="常用写法"><a href="#常用写法" class="headerlink" title="常用写法"></a>常用写法</h3><p>YAML 支持以下三种数据结构：<br>对象：键值对的集合<br>数组：一组按次序排列的值<br>字面量：单个的、不可拆分的值</p>
<h3 id="字面量写法"><a href="#字面量写法" class="headerlink" title="字面量写法"></a>字面量写法</h3><p>字面量是指单个的，不可拆分的值，例如：数字、字符串、布尔值、以及日期等。<br>在 YAML 中，使用“key:[空格]value”的形式表示一对键值对（空格不能省略），如 url: <a href="http://www.biancheng.net./">www.biancheng.net。</a><br>默认情况下字符串是不需要使用单引号或双引号的</p>
<h3 id="对象写法"><a href="#对象写法" class="headerlink" title="对象写法"></a>对象写法</h3><p>在 YAML 中，对象可能包含多个属性，每一个属性都是一对键值对。<br>YAML 为对象提供了 2 种写法：<br>普通写法，使用缩进表示对象与属性的层级关系。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">website:</span> </span><br><span class="line">  <span class="attr">name:</span> <span class="string">project</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">www.baidu.net</span></span><br></pre></td></tr></table></figure>
<p>行内写法：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">website:</span> &#123;<span class="attr">name:</span> <span class="string">project</span>,<span class="attr">url:</span> <span class="string">www.baidu.net</span>&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组写法"><a href="#数组写法" class="headerlink" title="数组写法"></a>数组写法</h3><p>YAML 使用“-”表示数组中的元素，普通写法如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">pets:</span></span><br><span class="line">  <span class="string">-dog</span></span><br><span class="line">  <span class="string">-cat</span></span><br><span class="line">  <span class="string">-pig</span></span><br></pre></td></tr></table></figure>
<p>行内写法：pets: [dog,cat,pig]</p>
<h3 id="组织结构"><a href="#组织结构" class="headerlink" title="组织结构"></a>组织结构</h3><p>一个 YAML 文件可以由一个或多个文档组成，文档之间使用“—”作为分隔符，且个文档相互独立，互不干扰。如果 YAML 文件只包含一个文档，则“—”分隔符可以省略。</p>
<hr>
<p>😁END</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>yaml</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringClound入门</title>
    <url>/posts/3ce02997.html</url>
    <content><![CDATA[<h3 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>微服务，又叫微服务架构，是一种软件架构方式。它将应用构建成一系列按业务领域划分模块的、小的自治服务。<br>在微服务架构中，每个服务都是自我包含的，并且实现了单一的业务功能。<br>简单来说，就是将一个系统按业务划分成多个子系统，每个子系统都是完整的，可独立运行的，子系统间的交互可通过HTTP协议进行通信（也可以采用消息队列来通信，如RoocketMQ，Kafaka等）。<br>所以，不同子系统可以使用不同的编程语言实现，使用不同的存储技术。但是，因为子系统服务数量越多，管理起来越复杂，因此需要采用集中化管理，例如Eureka，Zookeeper等都是比较常见的服务集中化管理框架；同时，使用自动化部署（如Jenkins）减少人为控制，降低出错概率，提高效率。</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>解耦：同一系统内的服务大部分可以被解耦。因此应用，作为一个整体，可以轻易地被构建、修改和扩展。<br>组件化：微服务可以被看成相互独立的组件，这些组件可以被轻易地替换和升级。<br>业务能力：微服务很小，它们可以专注于某种单一的能力<br>自治：开发者和团队可以独立地工作，提高开发速度。<br>持续交付：允许持续发布软件新版本，通过系统化的自动手段来创建、测试和批准新版本。<br>职责明确：微服务不把应用看成一个又一个的项目。相反，它们把应用当成了自己需要负责的项目。<br>去中心化管理：关注于使用正确的工具来完成正确的工作。这也就是说，没有标准化的方式或者技术模式。开发者们有权选择最的工具来解决问题。<br>敏捷性：微服务支持敏捷开发。任何新功能都可以被快速开发或丢弃。</p>
<h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><p>独立开发：基于各个微服务所独有的功能，它们可以被轻易开发出来。<br>独立部署：基于它们所提供的服务，它们可以被独立地部署到应用中。<br>错误隔离：即便其中某个服务发生了故障，整个系统还可以继续工作。<br>混合技术栈：可以使用不同的语言和技术来为同一个应用构建不同的服务。<br>按粒度扩展：可以根据需求扩展某一个组件，不需要将所有组件全部扩展。</p>
<h3 id="SpringClound简介"><a href="#SpringClound简介" class="headerlink" title="SpringClound简介"></a>SpringClound简介</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>Spring Cloud 是一个服务治理平台，是若干个框架的集合，提供了全套的分布式系统解决方案。包含了：服务注册与发现、配置中心、服务网关、智能路由、负载均衡、断路器、监控跟踪、分布式消息队列等等。<br>Spring Cloud 通过 Spring Boot 风格的封装，屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、容易部署的分布式系统开发工具包。开发者可以快速的启动服务或构建应用、同时能够快速和云平台资源进行对接。微服务是可以独立部署、水平扩展、独立访问（或者有独立的数据库）的服务单元，Spring Cloud 就是这些微服务的大管家，采用了微服务这种架构之后，项目的数量会非常多，Spring Cloud 做为大管家需要管理好这些微服务，自然需要很多小弟来帮忙。</p>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点有：<br>集大成者，Spring Cloud 包含了微服务架构的方方面面。<br>约定优于配置，基于注解，没有配置文件。<br>轻量级组件，Spring Cloud 整合的组件大多比较轻量级，且都是各自领域的佼佼者。<br>开发简便，Spring Cloud 对各个组件进行了大量的封装，从而简化了开发。<br>开发灵活，Spring Cloud 的组件都是解耦的，开发人员可以灵活按需选择组件。<br>缺点：<br>项目结构复杂，每一个组件或者每一个服务都需要创建一个项目。<br>部署门槛高，项目部署需要配合 Docker 等容器技术进行集群部署，而要想深入了解 Docker，学习成本高。</p>
<h3 id="SpringClound核心组件"><a href="#SpringClound核心组件" class="headerlink" title="SpringClound核心组件"></a>SpringClound核心组件</h3><h4 id="Eureka-注册中心"><a href="#Eureka-注册中心" class="headerlink" title="Eureka 注册中心"></a>Eureka 注册中心</h4><p>思考：当一个订单服务想要调用库存服务等服务，怎么调用？<br>这个时候，就轮到Spring Cloud Eureka出场了。Eureka是微服务架构中的注册中心，专门负责服务的注册与发现。</p>
<p>执行过程：<br>库存服务等服务都有一个Eureka Client组件，这个组件专门负责将这个服务的信息注册到Eureka Server中。说白了，就是告诉Eureka Server，自己在哪台机器上，监听着哪个端口。而Eureka Server是一个注册中心，里面有一个注册表，保存了各服务所在的机器和端口号</p>
<p>订单服务里也有一个Eureka Client组件，这个Eureka Client组件会找Eureka Server问一下：库存服务在哪台机器啊？监听着哪个端口啊？然后就可以把这些相关信息从Eureka Server的注册表中拉取到自己本地缓存起来。</p>
<p>这时如果订单服务想要调用库存服务，不就可以找自己本地的Eureka Client问一下库存服务在哪台机器？监听哪个端口吗？收到响应后，紧接着就可以发送一个请求过去，调用库存服务扣减库存的那个接口！</p>
<h4 id="Feign-动态代理"><a href="#Feign-动态代理" class="headerlink" title="Feign 动态代理"></a>Feign 动态代理</h4><p>问题又来了：难道订单服务要自己写一大堆代码，跟其他服务建立网络连接，然后构造一个复杂的请求，接着发送请求过去，最后对返回的响应结果再写一大堆代码来处理吗？<br>用注解定义一个 FeignClient接口，然后调用那个接口就可以了。Feign Client会在底层根据你的注解，跟你指定的服务建立连接、构造请求、发起靕求、获取响应、解析响应等等。</p>
<p>Feign关键机制：动态代理<br>首先，如果你对某个接口定义了@FeignClient注解，Feign就会针对这个接口创建一个动态代理<br>接着你要是调用那个接口，本质就是会调用 Feign创建的动态代理，这是核心中的核心<br>Feign的动态代理会根据你在接口上的@RequestMapping等注解，来动态构造出你要请求的服务的地址<br>最后针对这个地址，发起请求、解析响应</p>
<h4 id="Ribbon-负载均衡"><a href="#Ribbon-负载均衡" class="headerlink" title="Ribbon 负载均衡"></a>Ribbon 负载均衡</h4><p>新的问题又来了：如果库存服务部署在了5台机器上，Feign怎么知道该请求哪台机器呢？<br>Ribbon就是专门解决这个问题的。它的作用是负载均衡，会帮你在每次请求时选择一台机器，均匀的把请求分发到各个机器上<br>Ribbon的负载均衡默认使用的最经典的Round Robin轮询算法。这是啥？简单来说，就是如果订单服务对库存服务发起10次请求，那就先让你请求第1台机器、然后是第2台机器、第3台机器、第4台机器、第5台机器，接着再来—个循环，第1台机器、第2台机器。。。以此类推</p>
<p>Ribbon是和Feign以及Eureka紧密协作，完成工作的，具体如下：<br>首先Ribbon会从 Eureka Client里获取到对应的服务注册表，也就知道了所有的服务都部署在了哪些机器上，在监听哪些端口号。<br>然后Ribbon就可以使用默认的Round Robin算法，从中选择一台机器<br>Feign就会针对这台机器，构造并发起请求。</p>
<h4 id="Hystrix-熔断保护"><a href="#Hystrix-熔断保护" class="headerlink" title="Hystrix 熔断保护"></a>Hystrix 熔断保护</h4><p>在微服务架构里，一个系统会有很多的服务。现在假设订单服务自己最多只有100个线程可以处理请求，然后呢，积分服务不幸的挂了，每次订单服务调用积分服务的时候，都会卡住几秒钟，然后抛出—个超时异常。</p>
<p>但是我们思考一下，就算积分服务挂了，订单服务也可以不用挂啊！为什么？<br>如果积分服务挂了，大不了等他恢复之后，慢慢人肉手工恢复数据！为啥一定要因为一个积分服务挂了，就直接导致订单服务也挂了呢？不可以接受！</p>
<p>这时就轮到Hystrix闪亮登场了。Hystrix是隔离、熔断以及降级的一个框架。啥意思呢？说白了，Hystrix会搞很多个小小的线程池，比如订单服务请求库存服务是一个线程池，请求仓储服务是一个线程池，请求积分服务是一个线程池。每个线程池里的线程就仅仅用于请求那个服务。</p>
<p>打个比方：现在很不幸，积分服务挂了，会咋样？</p>
<p>当然会导致订单服务里那个用来调用积分服务的线程都卡死不能工作了啊！但由于订单服务调用库存服务、仓储服务的这两个线程池都是正常工作的，所以这两个服务不会受到任何影响。</p>
<p>这个时候如果别人请求订单服务，订单服务还是可以正常调用库存服务扣减库存，调用仓储服务通知发货。只不过调用积分服务的时候，每次都会报错。但是如果积分服务都挂了，每次调用都要去卡住几秒钟干啥呢？有意义吗？当然没有！所以我们直接对积分服务熔断不就得了，比如在5分钟内请求积分服务直接就返回了，不要去走网络请求卡住几秒钟，这个过程，就是所谓的熔断！</p>
<p>那人家又说，兄弟，积分服务挂了你就熔断，好歹你干点儿什么啊！别啥都不干就直接返回啊？没问题，咱们就来个降级：每次调用积分服务，你就在数据库里记录一条消息，说给某某用户增加了多少积分，因为积分服务挂了，导致没增加成功！这样等积分服务恢复了，你可以根据这些记录手工加一下积分。这个过程，就是所谓的降级。</p>
<h4 id="Zuul-网关"><a href="#Zuul-网关" class="headerlink" title="Zuul 网关"></a>Zuul 网关</h4><p>Zuul，也就是微服务网关。这个组件是负责网络路由</p>
<p>问题:<br>假设你后台部署了几百个服务，现在有个前端兄弟，人家请求是直接从浏览器那儿发过来的。打个比方：人家要请求一下库存服务，你难道还让人家记着这服务的名字叫做inventory-service？部署在5台机器上？就算人家肯记住这一个，你后台可有几百个服务的名称和地址呢？难不成人家请求一个，就得记住一个？</p>
<p>所以：<br>上面这种情况，压根儿是不现实的。所以一般微服务架构中都必然会设计一个网关在里面，像android、ios、pc前端、微信小程序、H5等等，不用去关心后端有几百个服务，就知道有一个网关，所有请求都往网关走，网关会根据请求中的一些特征，将请求转发给后端的各个服务。</p>
<hr>
<p>🤪END</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>SpringClound</tag>
      </tags>
  </entry>
  <entry>
    <title>emoji</title>
    <url>/posts/b64bf632.html</url>
    <content><![CDATA[<p>😀😃😄😁🤣😂🥰😇<br>🤩🤪😎<br>👾💩🤡👻👽<br>💔💖<br>💬<br>❓❗❌✔<br>🍉🍋🍓🧀🍚🍦</p>
]]></content>
      <categories>
        <category>资源</category>
        <category>杂项</category>
      </categories>
  </entry>
  <entry>
    <title>数据库调优策略</title>
    <url>/posts/77699b9e.html</url>
    <content><![CDATA[<h3 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h3><h4 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h4><p>explain可用来分析SQL的执行计划</p>
<h4 id="用法："><a href="#用法：" class="headerlink" title="用法："></a>用法：</h4><p>explain sql语句<br>explain extended sql语句<br>-会在 explain 的基础上额外提供一些查询优化的信息。紧随其后通过 show warnings 命令可以得到优化后的查询语句，从而看出优化器优化了什么<br>explain partitions sql语句<br>-相比 explain 多了个 partitions 字段，如果查询是基于分区表的话，会显示查询将访问的分区。</p>
<h4 id="explain字段含义"><a href="#explain字段含义" class="headerlink" title="explain字段含义:"></a>explain字段含义:</h4><h5 id="10个字段："><a href="#10个字段：" class="headerlink" title="10个字段："></a>10个字段：</h5><p>id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |</p>
<h5 id="id"><a href="#id" class="headerlink" title="id"></a>id</h5><p>该语句的唯一标识。如果explain的结果包括多个id值，则数字越大越先执行；而对于相同id的行，则表示从上往下依次执行。</p>
<h5 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h5><p>表示对应行是是简单还是复杂的查询，如果是复杂的查询，又是上述三种复杂查询中的哪一种。<br>1）simple：简单查询。查询不包含子查询和union<br>2）primary：复杂查询中最外层的 select<br>3）subquery：包含在 select 中的子查询（不在 from 子句中）<br>4）derived：包含在 from 子句中的子查询。MySQL会将结果存放在一个临时表中，也称为派生表（derived的英文含义）<br>5）union：在 union 中的第二个和随后的 select<br>6）union result：从 union 临时表检索结果的 select</p>
<h5 id="table"><a href="#table" class="headerlink" title="table"></a>table</h5><p>表示 explain 的这一行正在访问哪个表。<br>当 from 子句中有子查询时，table列是 <derivenN> 格式，表示当前查询依赖 id&#x3D;N 的查询，于是先执行 id&#x3D;N 的查询。<br>当有 union 时，UNION RESULT 的 table 列的值为 &lt;union1,2&gt;，1和2表示参与 union 的 select 行id。</p>
<h5 id="type"><a href="#type" class="headerlink" title="type"></a>type</h5><p>表示关联类型或访问类型，即MySQL决定如何查找表中的行。<br>依次从最优到最差分别为：<br>system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</p>
<h5 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h5><p>显示查询可能使用哪些索引来查找。<br>explain 时可能出现 possible_keys 有列，而 key 显示 NULL 的情况，这种情况是因为表中数据不多，mysql认为索引对此查询帮助不大，选择了全表查询。<br>如果该列是NULL，则没有相关的索引。在这种情况下，可以通过检查 where 子句看是否可以创造一个适当的索引来提高查询性能，然后用 explain 查看效果。</p>
<h5 id="key"><a href="#key" class="headerlink" title="key"></a>key</h5><p>显示mysql实际采用哪个索引来优化对该表的访问。<br>如果没有使用索引，则该列是 NULL。如果想强制mysql使用或忽视possible_keys列中的索引，在查询中使用 force index、ignore index。</p>
<h5 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h5><p>显示了mysql在索引里使用的字节数，通过这个值可以算出具体使用了索引中的哪些列。</p>
<h5 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h5><p>显示了在key列记录的索引中，表查找值所用到的列或常量，常见的有：const（常量），func，NULL，字段名（例：film.id）</p>
<h5 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h5><p>mysql估计要读取并检测的行数，注意这个不是结果集里的行数。</p>
<h5 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h5><p>展示的是额外信息。常见的重要值如下：<br>distinct: 一旦mysql找到了与行相联合匹配的行，就不再搜索了<br>Using index：这发生在对表的请求列都是同一索引的部分的时候，返回的列数据只使用了索引中的信息，而没有再去访问表中的行记录。是性能高的表现。<br>Using where：mysql服务器将在存储引擎检索行后再进行过滤。就是先读取整行数据，再按 where 条件进行检查，符合就留下，不符合就丢弃。<br>Using temporary：mysql需要创建一张临时表来处理查询。出现这种情况一般是要进行优化的，首先是想到用索引来优化。<br>Using filesort：mysql 会对结果使用一个外部索引排序，而不是按索引次序从表里读取行。此时mysql会根据联接类型浏览所有符合条件的记录，并保存排序关键字和行指针，然后排序关键字并按顺序检索行信息。这种情况下一般也是要考虑使用索引来优化的。</p>
<h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>定义：<br>只需要在一棵索引树上就能获取SQL所需的所有列数据，无需回表，速度更快。mysql执行计划explain结果里的key有使用索引，如果select后面查询的字段都可以从这个索引的树中获取，这种情况一般可以说是用到了覆盖索引，<em>extra里一般都有using index</em>；覆盖索引一般针对的是辅助索引，整个查询结果只通过辅助索引就能拿到结果，不需要通过辅助索引树找到主键，再通过主键去主键索引树里获取其它字段值。<br>实现：<br>将被查询的字段，建立到联合索引里去。</p>
<h3 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h3><p>定义：<br>ALTER TABLE <code>table_name</code> ADD INDEX (<code>col1</code>,<code>col2</code>,<code>col3</code>);<br>注：当创建(col1,col2,col3)联合索引时，相当于创建了(col)单列索引，(clo1,clo2)联合索引以及(col1,col2,col3)联合索引想要索引生效，只能使用col1和col1,col2和col1,col2,col3三种组合；当然，col1,col3组合也可以，但实际上只用到了col1的索引，col3并没有用到！</p>
<h3 id="最左匹配原则"><a href="#最左匹配原则" class="headerlink" title="最左匹配原则"></a>最左匹配原则</h3><p>定义：<br>在MySQL建立联合索引时会遵守最左前缀匹配原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。</p>
<h3 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h3><p>定义：<br>索引下推的下推其实就是指将部分上层（服务层）负责的事情，交给了下层（引擎层）去处理。<br>注：索引下推是MySQL 5.6版本的新特性<br>使用条件：<br>只能用于range、 ref、 eq_ref、ref_or_null访问方法；<br>只能用于InnoDB和 MyISAM存储引擎及其分区表；<br>对InnoDB存储引擎来说，索引下推只适用于二级索引（也叫辅助索引）;</p>
<h3 id="唯一索引普通索引选择难题"><a href="#唯一索引普通索引选择难题" class="headerlink" title="唯一索引普通索引选择难题"></a>唯一索引普通索引选择难题</h3><p>change buffer的作用：<br>对非唯一的二级索引进行DML（删除行、写入行、修改行）操作时作出的优化逻辑<br>change buffer的主要目的：<br>将记录的变更动作缓存下来，所以在一个数据页做merge之前，change buffer记录的变更越多（也就是这个页面上要更新的次数越多），收益就越大。<br>因此，对于写多读少的业务来说，页面在写完以后马上被访问到的概率比较小，此时change buffer的使用效果最好，这种业务模型常见的就是账单类、日志类的系统。</p>
<h3 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h3><p>我们存在邮箱作为用户名的情况，每个人的邮箱都是不一样的，那我们是不是可以在邮箱上建立索引，但是邮箱这么长，我们怎么去建立索引呢？<br>MySQL是支持前缀索引的，也就是说，你可以定义字符串的一部分作为索引。默认地，如果你创建索引的语句不指定前缀长度，那么索引就会包含整个字符串。<br>❓很长的字段，想做索引我们怎么去优化他呢？<br>答：建立一个区分度很高的前缀索引</p>
<h3 id="条件字段函数操作"><a href="#条件字段函数操作" class="headerlink" title="条件字段函数操作"></a>条件字段函数操作</h3><p>对索引字段做函数操作，可能会破坏索引值的有序性，因此优化器就决定放弃走树搜索功能。</p>
<h3 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h3><p>select * from t where id &#x3D; 1<br>如果id是字符类型的，1是数字类型的，你用explain会发现走了全表扫描，根本用不上索引，为啥呢？<br>因为MySQL底层会对你的比较进行转换，相当于加了 CAST( id AS signed int) 这样的一个函数，上面说过函数会导致走不上索引。</p>
<h3 id="隐式字符编码转换"><a href="#隐式字符编码转换" class="headerlink" title="隐式字符编码转换"></a>隐式字符编码转换</h3><p>如果两个表的字符集不一样，一个是utf8mb4，一个是utf8，因为utf8mb4是utf8的超集，所以一旦两个字符比较，就会转换为utf8mb4再比较。<br>转换的过程相当于加了CONVERT(id USING utf8mb4)函数，那又回到上面的问题了，用到函数就用不上索引了。</p>
<h3 id="flush"><a href="#flush" class="headerlink" title="flush"></a>flush</h3><p>定义：<br>redo log总会找个时间去更新到磁盘，这个操作就是flush。<br>在更新之前，当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为“脏页”。<br>内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为“干净页“。<br>什么时候会flush：<br>InnoDB的redo log写满了，这时候系统会停止所有更新操作，把checkpoint往前推进，redo log留出空间可以继续写。<br>系统内存不足，当需要新的内存页，而内存不够用的时候，就要淘汰一些数据页，空出内存给别的数据页使用。如果淘汰的是“脏页”，就要先将脏页写到磁盘。<br>把握flush的时机：<br>正确地告诉InnoDB所在主机的IO能力，这样InnoDB才能知道需要全力刷脏页的时候，可以刷多快。要用到innodb_io_capacity这个参数了，它会告诉InnoDB你的磁盘能力，这个值建议设置成磁盘的IOPS，磁盘的IOPS可以通过fio这个工具来测试。</p>
<hr>
<p>🥰END</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库调优</tag>
      </tags>
  </entry>
  <entry>
    <title>消息队列</title>
    <url>/posts/fec99276.html</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>消息队列（Message Queue，简称MQ），指保存消息的一个容器，本质是个队列。</p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><h4 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h4><p>消息队列的主要特点是异步处理，主要目的是减少请求响应时间，实现非核心流程异步化，提高系统响应性能。<br>例如：<br>用户注册的例子，用户注册成功后，系统需要发送注短信注册成功通知，以及赠送注册成功的积分。<br>由于短信通知与增加积分为非核心流程，为了提升系统响应性能，从而我把它改造为异步。<br>之前需要等用户注册10ms+短信通知100ms+增加积分100ms才能返回，现在把短信通知和增加积分改为异步的形式，用户注册后写入消息10ms左右立即返回成功给客户端，无需等待耗时较久的同步(短信+积分)就可以返回，从而极大的提升了系统的吞吐量。</p>
<h4 id="应用解耦"><a href="#应用解耦" class="headerlink" title="应用解耦"></a>应用解耦</h4><p>系统A产生数据之后，将该数据写到MQ中，系统A就不管了，不用关心谁消费，谁不消费，即使是再来一个系统E，或者是系统D不需要数据了，系统A也不需要做任何改变，而系统B、C、D是否消费成功，也不用系统A去关心，通过这样一种机制，系统A和其他各系统之间的强耦合是不是一下子就解除了，系统A是不是一下子清爽了很多？</p>
<h4 id="流量削峰"><a href="#流量削峰" class="headerlink" title="流量削峰"></a>流量削峰</h4><p>流量削锋也是消息队列中的常用场景，一般在秒杀或团抢活动中使用广泛。<br>这种场景中系统的峰值流量往往集中于一小段时间内，所以为了防止系统在短时间内的峰值流量冲垮，往往采用消息队列来削弱峰值流量，相当于消息队列做了一次缓冲。</p>
<p>下游系统下单时只需要往MQ里发消息，我的订单系统可以设定消费的频率，比如每秒我就消费2000个消息（在数据库的可承受范围），不管你下游系统每秒下多少单，我都保持这个速率，既不会影响我订单系统的数据库，也不影响你下游系统的下单操作，很好的保护了系统，也提高了下单的吞吐量。<br>我们都知道，大促也就几分钟的事，往多了说是几个小时吧，咱就说4个小时吧，每秒5000，4小时7200W单往MQ里写，订单系统每秒消费2000单，大促过后，MQ里会积压4320W个消息，剩下的就慢慢消费呗。当然了，大促的时候肯定会临时申请加机器的，每秒消费不止2000。</p>
<h4 id="日志处理"><a href="#日志处理" class="headerlink" title="日志处理"></a>日志处理</h4><p>日志处理是指将消息队列用在日志处理中，比如Kafka的应用，解决大量日志传输的问题。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>缺点：<br>1、增加了系统的复杂性。<br>原来系统A、 B、C、D之间就直接用接口调用的方式，现在引进了MQ要考虑很多MQ的问题，如：消息会不会丢失？积压了很多消息咋办？MQ满了咋办？消息会不会重复？怎么保证消息顺序性等问题。<br>2、降低了系统的可用性。<br>各个系统之间强依赖MQ，MQ的可用性就变得非常的关键，我还要额外的去保证MQ的高可用，担心他会挂了。<br>3、一致性问题。<br>如：多个系统依赖一个系统发送的消息，如果部分系统消费成功而部分系统消费失败，可能会导致数据不一致的问题。</p>
<h3 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h3><h4 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h4><p>Producer 消息生产者：负责产生和发送消息到 Broker；<br>Broker 消息处理中心：负责消息存储、确认、重试等，一般其中会包含多个 queue；<br>Consumer 消息消费者：负责从 Broker 中获取消息，并进行相应处理；</p>
<h4 id="详细设计"><a href="#详细设计" class="headerlink" title="详细设计"></a>详细设计</h4><ol>
<li>RPC 通信</li>
</ol>
<p>Producer生产消息向Broker发送会涉及到通信的问题，同样Consumer 消费消息也会涉及到通信的问题。<br>上图中的Producer,Broker,Consumer最后就通过RPC将数据流串起来了，所以需要解决通信的问题。<br>你可以基于Netty 来做底层通信，用 Zookeeper、Euraka 等来做注册中心，然后自定义一套新的通信协议。<br>也可以直接利用成熟的 RPC 框架 Dubbo 或者 Thrift 实现即可，这样不需要考虑服务注册与发现、负载均衡、通信协议、序列化方式等一系列问题了。</p>
<ol start="2">
<li>Broker存储</li>
</ol>
<p>消息到达服务端后需要存储到Broker。<br>大家关注的流量削峰、最终一致性等需求都是需要Broker先存储下来，然后选择时机投递，这才达到流量削峰、泄洪的目的，所以Broker一个非常重要的功能就是存储。<br>存储可以做成很多方式，比如存储在内存里，存储在分布式KV里，存储在磁盘里，存储在数据库里等等，存储的选型需要综合考虑性能&#x2F;高可用和开发维护成本等诸多因素。<br>目前主流的方案：追加写日志文件（数据部分） + 索引文件的方式，索引设计上可以考虑稠密索引或者稀疏索引，查找消息可以利用跳转表、二份查找等，还可以通过操作系统的页缓存、零拷贝等技术来提升磁盘文件的读写性能。</p>
<ol start="3">
<li>消费模型</li>
</ol>
<p>消息到达Broker后，最终还是需要Consumer去消费消息，这里就会涉及到到消费模型。<br>这里的消费模型，目前主要就两种：单播和广播。所谓单播，就是点到点；而广播，是一点对多点。</p>
<ol start="4">
<li>高级特性</li>
</ol>
<p>如果Consumer端把消息消费了，除了需要消息确认，还会涉及到比如：重复消息、顺序消息、消息延迟、事务消息等需要考虑的高级特性。</p>
<h4 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h4><p>消息队列MQ主要包含两种模型：点对点与发布订阅两种模型。</p>
<ol>
<li>点对点模型</li>
</ol>
<p>用于 消息生产者 和 消息消费者 之间 点到点 的通信，包含三个角色：<br>消息队列（Queue）<br>发送者(Sender)<br>接收者(Receiver)</p>
<p>每个消息都被发送到一个特定的队列，接收者从队列中获取消息。队列保留着消息，可以放在 内存 中也可以 持久化，直到他们被消费或超时。</p>
<p>特点<br>每个消息只有一个消费者（Consumer）(即一旦被消费，消息就不再在消息队列中)<br>发送者和接收者之间在时间上没有依赖性<br>接收者在成功接收消息之后需向队列应答成功</p>
<ol start="2">
<li>发布订阅消息模型Topic</li>
</ol>
<p>发布订阅模型包含三个角色：<br>主题（Topic）<br>发布者（Publisher）<br>订阅者（Subscriber）<br>多个发布者将消息发送到Topic,系统将这些消息传递给多个订阅者。</p>
<p>特点</p>
<p>每个消息可以有多个消费者：和点对点方式不同，发布消息可以被所有订阅者消费<br>发布者和订阅者之间有时间上的依赖性。<br>针对某个主题（Topic）的订阅者，它必须创建一个订阅者之后，才能消费发布者的消息。<br>为了消费消息，订阅者必须保持运行的状态。</p>
<h3 id="产品"><a href="#产品" class="headerlink" title="产品"></a>产品</h3><p>ActiveMQ：<br>Apache出品，最早使用的消息队列产品，时间比较长了，最近版本更新比较缓慢，性能在万级&#x2F;秒。<br>RabbitMQ：<br>RabbitMQ是erlang语言开发，结合erlang语言本身的并发优势，支持很多的协议：AMQP，XMPP, SMTP, STOMP，性能在万级&#x2F;秒<br>Kafka：<br>Kafka是由Apache软件基金会开发的一个开源消息系统项目，由Scala写成。Kafka最初是由LinkedIn开发，并于2011年初开源。Kafka是一个分布式的、分区的、多复本的日志提交服务，性能在百万级&#x2F;秒。<br>RocketMQ：<br>阿里开源的消息中间件，纯Java开发，具有高吞吐量、高可用性、适合大规模分布式系统应用的特点，参考Kafka而设计的，性能在十万级&#x2F;秒<br>Pulsar：<br>Apache Pulsar是Apache软件基金会顶级项目，是下一代云原生分布式消息流平台，集消息、存储、轻量化函数式计算为一体，采用计算与存储分离架构设计，支持多租户、持久化存储、多机房跨区域数据复制，具有强一致性、高吞吐、低延时及高可扩展性等流数据存储特性，被看作是云原生时代实时消息流传输、存储和计算最佳解决方案。</p>
<p>注：<br>选型<br>广泛来说，电商、金融等对事务性要求很高的，可以考虑RocketMQ，技术挑战不是特别高，用 RabbitMQ 是不错的选择，如果是大数据领域的实时计算、日志采集等场景可以考虑 Kafka。</p>
<hr>
<p>🥰END</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
      </tags>
  </entry>
</search>
