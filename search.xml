<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java面试题</title>
    <url>/posts/a7ef9c4d.html</url>
    <content><![CDATA[<h4 id="❓-面向对象的三个基本特征？"><a href="#❓-面向对象的三个基本特征？" class="headerlink" title="❓ 面向对象的三个基本特征？"></a>❓ 面向对象的三个基本特征？</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>继承：让某个类型的对象获得另一个类型的对象的属性的方法。继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。</p>
<p>封装：隐藏部分对象的属性和实现细节，对数据的访问只能通过外公开的接口。通过这种方式，对象对内部数据提供了不同级别的保护，以防止程序中无关的部分意外的改变或错误的使用了对象的私有部分。</p>
<p>多态：对于同一个行为，不同的子类对象具有不同的表现形式。多态存在的3个条件：1）继承；2）重写；3）父类引用指向子类对象。</p>
</div></div>

<h4 id="❓-下面两个代码块能正常编译和执行吗？"><a href="#❓-下面两个代码块能正常编译和执行吗？" class="headerlink" title="❓ 下面两个代码块能正常编译和执行吗？"></a>❓ 下面两个代码块能正常编译和执行吗？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码块1</span></span><br><span class="line"><span class="type">short</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="number">1</span>; s1 = s1 + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 代码块2</span></span><br><span class="line"><span class="type">short</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="number">1</span>; s1 += <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>代码块1编译报错，错误原因是：不兼容的类型: 从int转换到short可能会有损失”。<br>代码块2正常编译和执行。原因：代码块2编译后，字节码中包含了 i2s 指令，该指令用于将 int 转成 short</p>
</div></div>

<h4 id="❓-amp-和-amp-amp-的区别？"><a href="#❓-amp-和-amp-amp-的区别？" class="headerlink" title="❓ &amp;和&amp;&amp;的区别？"></a>❓ &amp;和&amp;&amp;的区别？</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>&amp;&amp;：逻辑与运算符。当运算符左右两边的表达式都为 true，才返回 true。同时具有短路性，如果第一个表达式为 false，则直接返回 false。</p>
<p>&amp;：逻辑与运算符、按位与运算符。<br>按位与运算符：用于二进制的计算，只有对应的两个二进位均为1时，结果位才为1 ，否则为0。<br>逻辑与运算符：&amp; 在用于逻辑与时，和 &amp;&amp; 的区别是不具有短路性。所在通常使用逻辑与运算符都会使用 &amp;&amp;，而 &amp; 更多的适用于位运算。</p>
</div></div>

<h4 id="❓-String-是-Java-基本数据类型吗？"><a href="#❓-String-是-Java-基本数据类型吗？" class="headerlink" title="❓  String 是 Java 基本数据类型吗？"></a>❓  String 是 Java 基本数据类型吗？</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>不是。Java 中的基本数据类型只有8个：byte、short、int、long、float、double、char、boolean；<br>除了基本类型（primitive type），剩下的都是引用类型（reference type）。</p>
<p>基本数据类型：数据直接存储在栈上<br>引用数据类型区别：数据存储在堆上，栈上只存储引用地址</p>
</div></div>

<h4 id="❓-String-类可以继承吗？"><a href="#❓-String-类可以继承吗？" class="headerlink" title="❓  String 类可以继承吗？"></a>❓  String 类可以继承吗？</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>不行。String 类使用 final 修饰，无法被继承。</p>
</div></div>

<h4 id="❓-String和StringBuilder、StringBuffer的区别？"><a href="#❓-String和StringBuilder、StringBuffer的区别？" class="headerlink" title="❓  String和StringBuilder、StringBuffer的区别？"></a>❓  String和StringBuilder、StringBuffer的区别？</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>String：String 的值被创建后不能修改，任何对 String 的修改都会引发新的 String 对象的生成。<br>StringBuffer：跟 String 类似，但是值可以被修改，使用 synchronized 来保证线程安全。<br>StringBuilder：StringBuffer 的非线程安全版本，没有使用 synchronized，具有更高的性能，推荐优先使用。</p>
</div></div>

<h4 id="❓-String-s-x3D-new-String-“xyz”-创建了几个字符串对象？"><a href="#❓-String-s-x3D-new-String-“xyz”-创建了几个字符串对象？" class="headerlink" title="❓  String s &#x3D; new String(“xyz”) 创建了几个字符串对象？"></a>❓  String s &#x3D; new String(“xyz”) 创建了几个字符串对象？</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>一个或两个。如果字符串常量池已经有“xyz”，则是一个；否则，两个。</p>
<p>当字符串常量池没有 “xyz”，此时会创建如下两个对象：<br>一个是字符串字面量 “xyz” 所对应的、驻留（intern）在一个全局共享的字符串常量池中的实例，此时该实例也是在堆中，字符串常量池只放引用。<br>另一个是通过 new String() 创建并初始化的，内容与”xyz”相同的实例，也是在堆中。</p>
</div></div>

<h4 id="❓-String-s-x3D-“xyz”-和-String-s-x3D-new-String-“xyz”-区别？"><a href="#❓-String-s-x3D-“xyz”-和-String-s-x3D-new-String-“xyz”-区别？" class="headerlink" title="❓  String s &#x3D; “xyz” 和 String s &#x3D; new String(“xyz”) 区别？"></a>❓  String s &#x3D; “xyz” 和 String s &#x3D; new String(“xyz”) 区别？</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>两个语句都会先去字符串常量池中检查是否已经存在 “xyz”，如果有则直接使用，如果没有则会在常量池中创建 “xyz” 对象。<br>另外，String s &#x3D; new String(“xyz”) 还会通过 new String() 在堆里创建一个内容与 “xyz” 相同的对象实例。<br>所以前者其实理解为被后者的所包含。</p>
</div></div>

<h4 id="❓-x3D-x3D-和-equals-的区别是什么？"><a href="#❓-x3D-x3D-和-equals-的区别是什么？" class="headerlink" title="❓  &#x3D;&#x3D; 和 equals 的区别是什么？"></a>❓  &#x3D;&#x3D; 和 equals 的区别是什么？</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>&#x3D;&#x3D;：运算符，用于比较基础类型变量和引用类型变量。<br>对于基础类型变量，比较的变量保存的值是否相同，类型不一定要相同。<br>对于引用类型变量，比较的是两个对象的地址是否相同。<br>equals：Object 类中定义的方法，通常用于比较两个对象的值是否相等。<br>equals 在 Object 方法中其实等同于 &#x3D;&#x3D;，但是在实际的使用中，equals 通常被重写用于比较两个对象的值是否相同。</p>
</div></div>

<h4 id="❓-两个对象的-hashCode-相同，则-equals-也一定为-true，对吗？"><a href="#❓-两个对象的-hashCode-相同，则-equals-也一定为-true，对吗？" class="headerlink" title="❓  两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗？"></a>❓  两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗？</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>不对。hashCode() 和 equals() 之间的关系如下：<br>当有 a.equals(b) &#x3D;&#x3D; true 时，则 a.hashCode() &#x3D;&#x3D; b.hashCode() 必然成立，<br>反过来，当 a.hashCode() &#x3D;&#x3D; b.hashCode() 时，a.equals(b) 不一定为 true。</p>
</div></div>


<h4 id="❓-什么是反射"><a href="#❓-什么是反射" class="headerlink" title="❓  什么是反射"></a>❓  什么是反射</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>反射是指在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法；并且对于任意一个对象，都能够调用它的任意一个方法；这种动态获取信息以及动态调用对象方法的功能称为反射机制。</p>
</div></div>


<h4 id="❓-深拷贝和浅拷贝区别是什么？"><a href="#❓-深拷贝和浅拷贝区别是什么？" class="headerlink" title="❓  深拷贝和浅拷贝区别是什么？"></a>❓  深拷贝和浅拷贝区别是什么？</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>数据分为基本数据类型和引用数据类型。基本数据类型：数据直接存储在栈中；引用数据类型：存储在栈中的是对象的引用地址，真实的对象数据存放在堆内存里。<br>浅拷贝：对于基础数据类型：直接复制数据值；对于引用数据类型：只是复制了对象的引用地址，新旧对象指向同一个内存地址，修改其中一个对象的值，另一个对象的值随之改变。<br>深拷贝：对于基础数据类型：直接复制数据值；对于引用数据类型：开辟新的内存空间，在新的内存空间里复制一个一模一样的对象，新老对象不共享内存，修改其中一个对象的值，不会影响另一个对象。<br>深拷贝相比于浅拷贝速度较慢并且花销较大。</p>
</div></div>

<h4 id="❓-并发和并行有什么区别？"><a href="#❓-并发和并行有什么区别？" class="headerlink" title="❓  并发和并行有什么区别？"></a>❓  并发和并行有什么区别？</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>并发：两个或多个事件在同一时间间隔发生。<br>并行：两个或者多个事件在同一时刻发生。<br>并行是真正意义上，同一时刻做多件事情，而并发在同一时刻只会做一件事件，只是可以将时间切碎，交替做多件事情。</p>
</div></div>


<h4 id="❓-构造器是否可被-重写"><a href="#❓-构造器是否可被-重写" class="headerlink" title="❓  构造器是否可被 重写?"></a>❓  构造器是否可被 重写?</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>Constructor 不能被 override（重写），但是可以 overload（重载），所以你可以看到⼀个类中有多个构造函数的情况。</p>
</div></div>


<h4 id="❓-重载（Overload）和重写（Override）的区别？"><a href="#❓-重载（Overload）和重写（Override）的区别？" class="headerlink" title="❓  重载（Overload）和重写（Override）的区别？"></a>❓  重载（Overload）和重写（Override）的区别？</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。</p>
<p>重载：一个类中有多个同名的方法，但是具有有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）。</p>
<p>重写：发生在子类与父类之间，子类对父类的方法进行重写，参数都不能改变，返回值类型可以不相同，但是必须是父类返回值的派生类。即外壳不变，核心重写！重写的好处在于子类可以根据需要，定义特定于自己的行为。</p>
</div></div>

<h4 id="❓-Error-和-Exception-有什么区别？"><a href="#❓-Error-和-Exception-有什么区别？" class="headerlink" title="❓  Error 和 Exception 有什么区别？"></a>❓  Error 和 Exception 有什么区别？</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>Error 和 Exception 都是 Throwable 的子类，用于表示程序出现了不正常的情况。区别在于：<br>Error 表示系统级的错误和程序不必处理的异常，是恢复不是不可能但很困难的情况下的一种严重问题，比如内存溢出，不可能指望程序能处理这样的情况。<br>Exception 表示需要捕捉或者需要程序进行处理的异常，是一种设计或实现问题，也就是说，它表示如果程序运行正常，从不会发生的情况。</p>
</div></div>


<h4 id="❓-wait-和-sleep-方法的区别"><a href="#❓-wait-和-sleep-方法的区别" class="headerlink" title="❓  wait() 和 sleep() 方法的区别"></a>❓  wait() 和 sleep() 方法的区别</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>来源不同：sleep() 来自 Thread 类，wait() 来自 Object 类。</p>
<p>对于同步锁的影响不同：sleep() 不会改变同步锁的行为，如果当前线程持有同步锁，那么 sleep 是不会让线程释放同步锁的。wait() 会释放同步锁，让其他线程进入 synchronized 代码块执行。</p>
<p>使用范围不同：sleep() 可以在任何地方使用。wait() 只能在同步控制方法或者同步控制块里面使用，否则会抛 IllegalMonitorStateException。</p>
<p>恢复方式不同：两者会暂停当前线程，但是在恢复上不太一样。sleep() 在时间到了之后会重新恢复；wait() 则需要其他线程调用同一对象的 notify()&#x2F;nofityAll() 才能重新恢复。</p>
</div></div>


<h4 id="❓-线程的-join-方法是干啥用的？"><a href="#❓-线程的-join-方法是干啥用的？" class="headerlink" title="❓  线程的 join() 方法是干啥用的？"></a>❓  线程的 join() 方法是干啥用的？</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>用于等待当前线程终止。如果一个线程A执行了 threadB.join() 语句，其含义是：当前线程A等待 threadB 线程终止之后才从 threadB.join() 返回继续往下执行自己的代码。</p>
</div></div>

<h4 id="❓-编写多线程程序有几种实现方式？"><a href="#❓-编写多线程程序有几种实现方式？" class="headerlink" title="❓  编写多线程程序有几种实现方式？"></a>❓  编写多线程程序有几种实现方式？</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>通常来说，可以认为有三种方式：1）继承 Thread 类；2）实现 Runnable 接口；3）实现 Callable 接口。</p>
<p>其中，Thread 其实也是实现了 Runable 接口。Runnable 和 Callable 的主要区别在于是否有返回值。</p>
</div></div>


<h4 id="❓-synchronized-和-Lock-的区别"><a href="#❓-synchronized-和-Lock-的区别" class="headerlink" title="❓  synchronized 和 Lock 的区别"></a>❓  synchronized 和 Lock 的区别</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>1）Lock 是一个接口；synchronized 是 Java 中的关键字，synchronized 是内置的语言实现；</p>
<p>2）Lock 在发生异常时，如果没有主动通过 unLock() 去释放锁，很可能会造成死锁现象，因此使用 Lock 时需要在 finally 块中释放锁；synchronized 不需要手动获取锁和释放锁，在发生异常时，会自动释放锁，因此不会导致死锁现象发生；</p>
<p>3）Lock 的使用更加灵活，可以有响应中断、有超时时间等；而 synchronized 却不行，使用 synchronized 时，等待的线程会一直等待下去，直到获取到锁；</p>
<p>4）在性能上，随着近些年 synchronized 的不断优化，Lock 和 synchronized 在性能上已经没有很明显的差距了，所以性能不应该成为我们选择两者的主要原因。官方推荐尽量使用 synchronized，除非 synchronized 无法满足需求时，则可以使用 Lock。</p>
</div></div>

<h4 id="❓-线程池的核心属性有哪些？"><a href="#❓-线程池的核心属性有哪些？" class="headerlink" title="❓  线程池的核心属性有哪些？"></a>❓  线程池的核心属性有哪些？</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>threadFactory（线程工厂）：用于创建工作线程的工厂。</p>
<p>corePoolSize（核心线程数）：当线程池运行的线程少于 corePoolSize 时，将创建一个新线程来处理请求，即使其他工作线程处于空闲状态。</p>
<p>workQueue（队列）：用于保留任务并移交给工作线程的阻塞队列。</p>
<p>maximumPoolSize（最大线程数）：线程池允许开启的最大线程数。</p>
<p>handler（拒绝策略）：往线程池添加任务时，将在下面两种情况触发拒绝策略：1）线程池运行状态不是 RUNNING；2）线程池已经达到最大线程数，并且阻塞队列已满时。</p>
<p>keepAliveTime（保持存活时间）：如果线程池当前线程数超过 corePoolSize，则多余的线程空闲时间超过 keepAliveTime 时会被终止。</p>
</div></div>

<h4 id="❓-线程池有哪些拒绝策略？"><a href="#❓-线程池有哪些拒绝策略？" class="headerlink" title="❓  线程池有哪些拒绝策略？"></a>❓  线程池有哪些拒绝策略？</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>AbortPolicy：中止策略。默认的拒绝策略，直接抛出 RejectedExecutionException。调用者可以捕获这个异常，然后根据需求编写自己的处理代码。</p>
<p>DiscardPolicy：抛弃策略。什么都不做，直接抛弃被拒绝的任务。</p>
<p>DiscardOldestPolicy：抛弃最老策略。抛弃阻塞队列中最老的任务，相当于就是队列中下一个将要被执行的任务，然后重新提交被拒绝的任务。如果阻塞队列是一个优先队列，那么“抛弃最旧的”策略将导致抛弃优先级最高的任务，因此最好不要将该策略和优先级队列放在一起使用。</p>
<p>CallerRunsPolicy：调用者运行策略。在调用者线程中执行该任务。该策略实现了一种调节机制，该策略既不会抛弃任务，也不会抛出异常，而是将任务回退到调用者（调用线程池执行任务的主线程），由于执行任务需要一定时间，因此主线程至少在一段时间内不能提交任务，从而使得线程池有时间来处理完正在执行的任务。</p>
</div></div>

<h4 id="❓-ArrayList-和-LinkedList-的区别。"><a href="#❓-ArrayList-和-LinkedList-的区别。" class="headerlink" title="❓  ArrayList 和 LinkedList 的区别。"></a>❓  ArrayList 和 LinkedList 的区别。</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>ArrayList 底层基于动态数组实现，LinkedList 底层基于链表实现。</p>
<p>对于按 index 索引数据（get&#x2F;set方法）：ArrayList 通过 index 直接定位到数组对应位置的节点，而 LinkedList需要从头结点或尾节点开始遍历，直到寻找到目标节点，因此在效率上 ArrayList 优于 LinkedList。</p>
<p>对于随机插入和删除：ArrayList 需要移动目标节点后面的节点（使用System.arraycopy 方法移动节点），而 LinkedList 只需修改目标节点前后节点的 next 或 prev 属性即可，因此在效率上 LinkedList 优于 ArrayList。</p>
<p>对于顺序插入和删除：由于 ArrayList 不需要移动节点，因此在效率上比 LinkedList 更好。这也是为什么在实际使用中 ArrayList 更多，因为大部分情况下我们的使用都是顺序插入。</p>
</div></div>

<h4 id="❓-什么是双亲委派模型？"><a href="#❓-什么是双亲委派模型？" class="headerlink" title="❓  什么是双亲委派模型？"></a>❓  什么是双亲委派模型？</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。</p>
</div></div>

<h4 id="❓-介绍下垃圾收集机制（在什么时候，对什么，做了什么）？"><a href="#❓-介绍下垃圾收集机制（在什么时候，对什么，做了什么）？" class="headerlink" title="❓  介绍下垃圾收集机制（在什么时候，对什么，做了什么）？"></a>❓  介绍下垃圾收集机制（在什么时候，对什么，做了什么）？</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>在什么时候？<br>在触发GC的时候，具体如下，这里只说常见的 Young GC 和 Full GC。<br>触发Young GC：当新生代中的 Eden 区没有足够空间进行分配时会触发Young GC。<br>触发Full GC：<br>当准备要触发一次Young GC时，如果发现统计数据说之前Young GC的平均晋升大小比目前老年代剩余的空间大，则不会触发Young GC而是转为触发Full GC。（通常情况）<br>如果有永久代的话，在永久代需要分配空间但已经没有足够空间时，也要触发一次Full GC。<br>System.gc()默认也是触发Full GC。<br>heap dump带GC默认也是触发Full GC。<br>CMS GC时出现Concurrent Mode Failure会导致一次Full GC的产生。</p>
<p>对什么？<br>对那些JVM认为已经“死掉”的对象。即从GC Root开始搜索，搜索不到的，并且经过一次筛选标记没有复活的对象。</p>
<p>做了什么？<br>对这些JVM认为已经“死掉”的对象进行垃圾收集，新生代使用复制算法，老年代使用标记-清除和标记-整理算法。</p>
</div></div>
]]></content>
      <categories>
        <category>资源</category>
        <category>面试题</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/posts/0.html</url>
    <content><![CDATA[<!-- #### ❓  
<div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"></div></div>

<p>&lt;</p>
<p>–&gt;</p>
<hr>
<p>END</p>
]]></content>
  </entry>
  <entry>
    <title>MySQL面试题</title>
    <url>/posts/d4eb4c98.html</url>
    <content><![CDATA[<h4 id="❓-日常是怎么优化-SQL-的？"><a href="#❓-日常是怎么优化-SQL-的？" class="headerlink" title="❓  日常是怎么优化 SQL 的？"></a>❓  日常是怎么优化 SQL 的？</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>通过慢查询日志、EXPLAIN 分析查询、show profile 分析、以及 show 命令查询系统状态及系统变量</p>
</div></div>

<h4 id="❓-MySQL-如何对大表-千万-x2F-亿级-做优化？"><a href="#❓-MySQL-如何对大表-千万-x2F-亿级-做优化？" class="headerlink" title="❓  MySQL 如何对大表(千万&#x2F;亿级)做优化？"></a>❓  MySQL 如何对大表(千万&#x2F;亿级)做优化？</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>优化顺序：</p>
<p>优化 SQL 语句和索引</p>
<p>对频繁查询的数据进行缓存</p>
<p>对数据库进行主从复制，读写分离，从库可以使用 MyISAM，查询效率会更高</p>
<p>对表进行分区，SQL 条件中需要带上做分区的列，可以使查询定位到少量的分区上，查询会比较快，如果每用到分区的列会扫描全部分区</p>
<p>垂直拆分，对大表拆分成小表</p>
<p>水平拆分，将数据分片，拆分到其他表或数据库上</p>
</div></div>

<h4 id="❓-分区、分表、分库有什么作用？"><a href="#❓-分区、分表、分库有什么作用？" class="headerlink" title="❓  分区、分表、分库有什么作用？"></a>❓  分区、分表、分库有什么作用？</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>逻辑数据分割</p>
<p>提高单一的写和读应用速度</p>
<p>提高分区范围读查询的速度</p>
<p>分割数据能够有多个不同的物理文件路径，避免单目录或单文件过大</p>
<p>高效的保存历史记录</p>
<p>便于磁盘清理</p>
</div></div>

<h4 id="❓-如何分区、分表、分库？"><a href="#❓-如何分区、分表、分库？" class="headerlink" title="❓  如何分区、分表、分库？"></a>❓  如何分区、分表、分库？</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>分区：<br>RANGE 分区，LIST 分区，HASH 分区，KEY 分区<br>分表：<br>范围分表，哈希取余分表<br>分库：<br>业务分库，垂直分库。</p>
</div></div>

<h4 id="❓-MySQL-如何实现高可用？"><a href="#❓-MySQL-如何实现高可用？" class="headerlink" title="❓  MySQL 如何实现高可用？"></a>❓  MySQL 如何实现高可用？</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>实现高可用的手段主要是数据备份和失效转移机制。</p>
<p>MySQL 采用 Master-Slave 同步机制，通过主从复制的方式实现数据的热备。</p>
<p>失效转移需要从应用层面实现，如对服务器进行心跳检测，或通过应用程序访问失败的报告来判断失效，控制中心判断失效之后对服务进行切换，MySQL 如果做了主主备份，那么就切换到备份的主库上。</p>
</div></div>

<h4 id="❓-MySQL-主从复制的原理？"><a href="#❓-MySQL-主从复制的原理？" class="headerlink" title="❓  MySQL 主从复制的原理？"></a>❓  MySQL 主从复制的原理？</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>MySQL 主从复制主要涉及三个异步线程：</p>
<p>binlog 线程：负责将主服务器上所有的更改操作写入到二进制日志中(binary log)</p>
<p>I&#x2F;O 线程：负责从主服务器上读取二进制的日志，并写入到从服务器的中继日志中(Relay log)</p>
<p>SQL 线程：负责读取中继日志，解析出主服务器已经执行的数据更改操作，并在 Slave 机器上重放</p>
</div></div>

<h4 id="❓-MySql-读写分离的作用？"><a href="#❓-MySql-读写分离的作用？" class="headerlink" title="❓  MySql 读写分离的作用？"></a>❓  MySql 读写分离的作用？</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>读写分离：主服务器负责处理写操作和对数据实时性要求比较高的读操作，从服务器只负责处理读操作。</p>
<p>读写分离主要有以下几个作用：</p>
<p>提高读写的性能，由于主从服务器负责各自的读写，极大程度缓解了锁的争用</p>
<p>从服务器可以使用 MyISAM 存储引擎，提升查询性能，节约系统开销</p>
<p>增加了服务器冗余，提高可用性</p>
</div></div>

<h4 id="❓-聚集索引和非聚集索引区别？"><a href="#❓-聚集索引和非聚集索引区别？" class="headerlink" title="❓  聚集索引和非聚集索引区别？"></a>❓  聚集索引和非聚集索引区别？</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>根本区别：聚集索引和非聚集索引的根本区别是表记录的排列顺序和与索引的排列顺序是否一致。<br>聚集索引表记录的排列顺序和索引的排列顺序一致，所以查询效率快，只要找到第一个索引值记录，其余就连续性的记录在物理也一样连续存放。聚集索引对应的缺点就是修改慢，因为为了保证表中记录的物理和索引顺序一致，在记录插入的时候，会对数据页重新排序。<br>非聚集索引制定了表中记录的逻辑顺序，但是记录的物理和索引不一定一致，两种索引都采用B+树结构，非聚集索引的叶子层并不和实际数据页相重叠，而采用叶子层包含一个指向表中的记录在数据页中的指针方式。非聚集索引层次多，不会造成数据重排。</p>
</div></div>
<h4 id="❓-有哪些锁（乐观锁悲观锁），select-时怎么加排它锁？"><a href="#❓-有哪些锁（乐观锁悲观锁），select-时怎么加排它锁？" class="headerlink" title="❓  有哪些锁（乐观锁悲观锁），select 时怎么加排它锁？"></a>❓  有哪些锁（乐观锁悲观锁），select 时怎么加排它锁？</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>悲观锁和乐观锁是数据库用来保证数据并发安全防止更新丢失的两种方法，例子在select … for update前加个事务就可以防止更新丢失。悲观锁和乐观锁大部分场景下差异不大，一些独特场景下有一些差别，一般我们可以从如下几个方面来判断。</p>
<p>响应速度：如果需要非常高的响应速度，建议采用乐观锁方案，成功就执行，不成功就失败，不需要等待其他并发去释放锁。<br>冲突频率：如果冲突频率非常高，建议采用悲观锁，保证成功率，如果冲突频率大，乐观锁会需要多次重试才能成功，代价比较大。<br>重试代价：如果重试代价大，建议采用悲观锁。</p>
</div></div>
<h4 id="❓-SQL语句主要分为哪几类"><a href="#❓-SQL语句主要分为哪几类" class="headerlink" title="❓  SQL语句主要分为哪几类"></a>❓  SQL语句主要分为哪几类</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>数据据定义语言DDL（Data Definition Language）：主要有CREATE，DROP，ALTER等对逻辑结构有操作的，包括表结构、视图和索引。<br>数据库查询语言DQL（Data Query Language）：主要以SELECT为主<br>数据操纵语言DML（Data Manipulation Language）：主要包括INSERT，UPDATE，DELETE<br>数据控制功能DCL（Data Control Language）：主要是权限控制能操作，包括GRANT，REVOKE，COMMIT，ROLLBACK等。</p>
</div></div>
<h4 id="❓-什么是临时表，什么时候会使用到临时表，什么时候删除临时表？"><a href="#❓-什么是临时表，什么时候会使用到临时表，什么时候删除临时表？" class="headerlink" title="❓  什么是临时表，什么时候会使用到临时表，什么时候删除临时表？"></a>❓  什么是临时表，什么时候会使用到临时表，什么时候删除临时表？</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>MySQL在执行SQL语句的时候会临时创建一些存储中间结果集的表，这种表被称为临时表，临时表只对当前连接可见，在连接关闭后，临时表会被删除并释放空间。</p>
<p>临时表主要分为内存临时表和磁盘临时表两种。内存临时表使用的是MEMORY存储引擎，磁盘临时表使用的是MyISAM存储引擎。</p>
<p>一般在以下几种情况中会使用到临时表：</p>
<p>FROM中的子查询<br>DISTINCT查询并加上ORDER BY<br>ORDER BY和GROUP BY的子句不一样时会产生临时表<br>使用UNION查询会产生临时表</p>
</div></div>
<h4 id="❓-了解慢日志查询吗？统计过慢查询吗？对慢查询如何优化？"><a href="#❓-了解慢日志查询吗？统计过慢查询吗？对慢查询如何优化？" class="headerlink" title="❓  了解慢日志查询吗？统计过慢查询吗？对慢查询如何优化？"></a>❓  了解慢日志查询吗？统计过慢查询吗？对慢查询如何优化？</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>慢查询一般用于记录执行时间超过某个临界值的SQL语句的日志。</p>
<p>相关参数：<br>slow_query_log：是否开启慢日志查询，1表示开启，0表示关闭。<br>slow_query_log_file：MySQL数据库慢查询日志存储路径。<br>long_query_time：慢查询阈值，当SQL语句查询时间大于阈值，会被记录在日志上。<br>log_queries_not_using_indexes：未使用索引的查询会被记录到慢查询日志中。<br>log_output：日志存储方式。“FILE”表示将日志存入文件。“TABLE”表示将日志存入数据库。<br>如何对慢查询进行优化？</p>
<p>分析语句的执行计划，查看SQL语句的索引是否命中<br>优化数据库的结构，将字段很多的表分解成多个表，或者考虑建立中间表。<br>优化LIMIT分页。</p>
</div></div>
<h4 id="❓-字段为什么要设置成not-null"><a href="#❓-字段为什么要设置成not-null" class="headerlink" title="❓  字段为什么要设置成not null?"></a>❓  字段为什么要设置成not null?</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>首先说一点，NULL和空值是不一样的，空值是不占用空间的，而NULL是占用空间的，所以字段设为NOT NULL后仍然可以插入空值。<br>字段设置成not null主要有以下几点原因：<br>NULL值会影响一些函数的统计，如count，遇到NULL值，这条记录不会统计在内。<br>B树不存储NULL，所以索引用不到NULL，会造成第一点中说的统计不到的问题。<br>NOT IN子查询在有NULL值的情况下返回的结果都是空值。<br>MySQL在进行比较的时候，NULL会参与字段的比较，因为NULL是一种比较特殊的数据类型，数据库在处理时需要进行特数处理，增加了数据库处理记录的复杂性。</p>
</div></div>

<h4 id="❓-如何优化LIMIT分页？"><a href="#❓-如何优化LIMIT分页？" class="headerlink" title="❓  如何优化LIMIT分页？"></a>❓  如何优化LIMIT分页？</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>在LIMIT偏移量较大的时候，查询效率会变低，可以记录每次取出的最大ID，下次查询时可以利用ID进行查询</p>
<p>建立复合索引</p>
</div></div>

<h4 id="❓-什么是垂直分表、垂直分库、水平分表、水平分库？"><a href="#❓-什么是垂直分表、垂直分库、水平分表、水平分库？" class="headerlink" title="❓  什么是垂直分表、垂直分库、水平分表、水平分库？"></a>❓  什么是垂直分表、垂直分库、水平分表、水平分库？</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>垂直分表：将一个表按照字段分成多个表，每个表存储其中一部分字段。一般会将常用的字段放到一个表中，将不常用的字段放到另一个表中。</p>
<p>垂直分表的优势：</p>
<p>避免IO竞争减少锁表的概率。因为大的字段效率更低，第一数据量大，需要的读取时间长。第二，大字段占用的空间更大，单页内存储的行数变少，会使得IO操作增多。<br>可以更好地提升热门数据的查询效率。<br>垂直分库：按照业务对表进行分类，部署到不同的数据库上面，不同的数据库可以放到不同的服务器上面。</p>
<p>垂直分库的优势：</p>
<p>降低业务中的耦合，方便对不同的业务进行分级管理。<br>可以提升IO、数据库连接数、解决单机硬件资源的瓶颈问题。<br>垂直拆分（分库、分表）的缺点：</p>
<p>主键出现冗余，需要管理冗余列<br>事务的处理变得复杂<br>仍然存在单表数据量过大的问题<br>水平分表：在同一个数据库内，把同一个表的数据按照一定规则拆分到多个表中。</p>
<p>水平分表的优势：</p>
<p>解决了单表数据量过大的问题<br>避免IO竞争并减少锁表的概率<br>水平分库：把同一个表的数据按照一定规则拆分到不同的数据库中，不同的数据库可以放到不同的服务器上。</p>
<p>水平分库的优势：</p>
<p>解决了单库大数据量的瓶颈问题<br>IO冲突减少，锁的竞争减少，某个数据库出现问题不影响其他数据库（可用性），提高了系统的稳定性和可用性<br>水平拆分（分表、分库）的缺点：</p>
<p>分片事务一致性难以解决<br>跨节点JOIN性能差，逻辑会变得复杂<br>数据扩展难度大，不易维护<br>在系统设计时应根据业务耦合来确定垂直分库和垂直分表的方案，在数据访问压力不是特别大时应考虑缓存、读写分离等方法，若数据量很大，或持续增长可考虑水平分库分表，水平拆分所涉及的逻辑比较复杂，常见的方案有客户端架构和恶代理架构。</p>
</div></div>]]></content>
      <categories>
        <category>资源</category>
        <category>面试题</category>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>网络协议面试题</title>
    <url>/posts/e172783f.html</url>
    <content><![CDATA[<h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><h4 id="❓-当你用浏览器打开一个链接的时候，计算机做了哪些工作步骤。"><a href="#❓-当你用浏览器打开一个链接的时候，计算机做了哪些工作步骤。" class="headerlink" title="❓  当你用浏览器打开一个链接的时候，计算机做了哪些工作步骤。"></a>❓  当你用浏览器打开一个链接的时候，计算机做了哪些工作步骤。</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>（1）解析域名。<br>​ （2）发起TCP的3次握手。<br>​ （3）建立TCP请求后发起HTTP请求。<br>​ （4）服务器相应HTTP请求。<br>​ （5）浏览器得到HTML代码，进行解析和处理JSON数据，并请求HTML代码中的静态资源（JS、CSS、图片等）。<br>​ （6）浏览器对页面进行渲染。</p>
</div></div>

<h4 id="❓-HTTPS的加密方式是什么，讲讲整个加密解密流程。"><a href="#❓-HTTPS的加密方式是什么，讲讲整个加密解密流程。" class="headerlink" title="❓  HTTPS的加密方式是什么，讲讲整个加密解密流程。"></a>❓  HTTPS的加密方式是什么，讲讲整个加密解密流程。</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>1）对称密码算法：指加密和解密使用相同的密钥，速度高，可加密内容较大，用来加密会话过程中的消息。典型算法DES、AES、RC5、IDEA（分组加密）RC4。</p>
<p> 2）非对称密码算法：又称为公钥加密算法，是指加密和解密使用不同的密钥，加密速度较慢，但能提供更好的身份认证技术，用来加密对称加密的密钥（公开的密钥用于加密，私有的密钥用于解密）典型的算法RSA、DSA、DH。</p>
<p> 3）散列算法：将文件内容通过此算法加密变成固定长度的值（散列值），这个过程可以使用密钥也可以不使用。这种散列变化是不可逆的，也就是说不能从散列值编程原文，因此散列变化通道常用语验证原文是否被篡改。典型的算法MD5、SHA、BASE64、CRC等。</p>
</div></div>

<h4 id="❓-Http与Https的区别："><a href="#❓-Http与Https的区别：" class="headerlink" title="❓  Http与Https的区别："></a>❓  Http与Https的区别：</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>HTTP 的URL 以http:&#x2F;&#x2F; 开头，而HTTPS 的URL 以https:&#x2F;&#x2F; 开头</p>
<p>HTTP 是不安全的，而 HTTPS 是安全的</p>
<p>HTTP 标准端口是80 ，而 HTTPS 的标准端口是443</p>
<p>在OSI 网络模型中，HTTP工作于应用层，而HTTPS 的安全传输机制工作在传输层</p>
<p>HTTP 无法加密，而HTTPS 对传输的数据进行加密</p>
<p>HTTP无需证书，而HTTPS 需要CA机构颁发的SSL证书</p>
</div></div>

<h4 id="❓-什么是Http协议无状态协议-怎么解决Http协议无状态协议"><a href="#❓-什么是Http协议无状态协议-怎么解决Http协议无状态协议" class="headerlink" title="❓  什么是Http协议无状态协议?怎么解决Http协议无状态协议?"></a>❓  什么是Http协议无状态协议?怎么解决Http协议无状态协议?</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>无状态协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息</p>
<p>也就是说，当客户端一次HTTP请求完成以后，客户端再发送一次HTTP请求，HTTP并不知道当前客户端是一个”老用户“。</p>
<p>可以使用Cookie来解决无状态的问题，Cookie就相当于一个通行证，第一次访问的时候给客户端发送一个Cookie，当客户端再次来的时候，拿着Cookie(通行证)，那么服务器就知道这个是”老用户“</p>
</div></div>

<h4 id="❓-常见的HTTP相应状态码"><a href="#❓-常见的HTTP相应状态码" class="headerlink" title="❓  常见的HTTP相应状态码"></a>❓  常见的HTTP相应状态码</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>200：请求被正常处理</p>
<p>204：请求被受理但没有资源可以返回</p>
<p>206：客户端只是请求资源的一部分，服务器只对请求的部分资源执行GET方法，相应报文中通过Content-Range指定范围的资源。</p>
<p>301：永久性重定向</p>
<p>302：临时重定向</p>
<p>303：与302状态码有相似功能，只是它希望客户端在请求一个URI的时候，能通过GET方法重定向到另一个URI上</p>
<p>304：发送附带条件的请求时，条件不满足时返回，与重定向无关</p>
<p>307：临时重定向，与302类似，只是强制要求使用POST方法</p>
<p>400：请求报文语法有误，服务器无法识别</p>
<p>401：请求需要认证</p>
<p>403：请求的对应资源禁止被访问</p>
<p>404：服务器无法找到对应资源</p>
<p>500：服务器内部错误</p>
<p>503：服务器正忙</p>
</div></div>

<h4 id="❓-Session和cookie的区别。"><a href="#❓-Session和cookie的区别。" class="headerlink" title="❓  Session和cookie的区别。"></a>❓  Session和cookie的区别。</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>（1）Cookie保存在客户端，未设置存储时间的Cookie，关闭浏览器会话Cookie就会被删除；设置了存储时间的Cookie保存在用户设备的磁盘中知道过期，同时Cookie在客户端所以可以伪造，不是十分安全，敏感数据不易保存。Session保存在服务器端，存储在IIS的进程开辟的内存中，而Session过多会消耗服务器资源，所以尽量少使用Session。<br>（2）Session是服务器用来跟踪用户的一种手段，每个Session都有一个唯一标识：session ID。当服务端生成一个Session时就会向客户端发送一个Cookie保存到客户端，这个Cookie保存的是Session的SessionId这样才能保证客户端发起请求后，用户能够与服务器端成千上万的Session进行匹配，同时也保证了不同页面之间传值的正确性.<br>（3）存储数据类型不同：Session能够存储任意的JAVA对象，Cookie只能存储String类型的对象。<br>（4）长于10K的数据，不要用到Cookies。</p>
</div></div>

<h3 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h3><h4 id="❓-网络的七层结构及其作用"><a href="#❓-网络的七层结构及其作用" class="headerlink" title="❓  网络的七层结构及其作用"></a>❓  网络的七层结构及其作用</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>自上而下是：</p>
<p>应用层（数据）：确定进程之间通信的性质以满足用户需要以及提供网络与用户应用</p>
<p>表示层（数据）：主要解决用户信息的语法表示问题，如加密解密</p>
<p>会话层（数据）：提供包括访问验证和会话管理在内的建立和维护应用之间通信的机制，如服务器验证用户登录便是由会话层完成的</p>
<p>传输层（段）：实现网络不同主机上用户进程之间的数据通信，可靠</p>
<p>与不可靠的传输，传输层的错误检测，流量控制等</p>
<p>网络层（包）：提供逻辑地址（IP）、选路，数据从源端到目的端的</p>
<p>传输</p>
<p>数据链路层（帧）：将上层数据封装成帧，用MAC地址访问媒介，错误检测与修正</p>
<p>物理层（比特流）：设备之间比特流的传输，物理接口，电气特性等</p>
</div></div>

<h4 id="❓-为什么-TCP-连接需要三次握手，两次不可以么，为什么？"><a href="#❓-为什么-TCP-连接需要三次握手，两次不可以么，为什么？" class="headerlink" title="❓  为什么 TCP 连接需要三次握手，两次不可以么，为什么？"></a>❓  为什么 TCP 连接需要三次握手，两次不可以么，为什么？</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>为了防止已失效的连接请求报文突然又传送到了服务端，因而产生错误。客户端发出的连接请求报文并未丢失，而是在某个网络节点长时间滞留了，以致延误到链接释放以后的某个时间才到达 Server 。</p>
</div></div>

<h4 id="❓-什么是-TCP-四次挥手？"><a href="#❓-什么是-TCP-四次挥手？" class="headerlink" title="❓  什么是 TCP 四次挥手？"></a>❓  什么是 TCP 四次挥手？</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>四次挥手，简单来说，就是：</p>
<p>发送方：我要和你断开连接！</p>
<p>接收方：好的，断吧。</p>
<p>接收方：我也要和你断开连接！</p>
<p>发送方：好的，断吧。</p>
</div></div>

<h3 id="UDP-协议"><a href="#UDP-协议" class="headerlink" title="UDP 协议"></a>UDP 协议</h3><h4 id="❓-UDP-是什么？"><a href="#❓-UDP-是什么？" class="headerlink" title="❓  UDP 是什么？"></a>❓  UDP 是什么？</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>UDP（User Data Protocol，用户数据报协议），是与 TCP 相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去。</p>
</div></div>

<h4 id="❓-UDP-主要特点"><a href="#❓-UDP-主要特点" class="headerlink" title="❓  UDP 主要特点"></a>❓  UDP 主要特点</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>UDP 是无连接的。</p>
<p>UDP 使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态（这里面有许多参数）。</p>
<p>UDP 是面向报文的。</p>
<p>UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低。</p>
</div></div>

<h4 id="❓-TCP与UDP的区别"><a href="#❓-TCP与UDP的区别" class="headerlink" title="❓  TCP与UDP的区别"></a>❓  TCP与UDP的区别</h4><div class="hide-block"><button type="button" class="hide-button" style="">查看答案
    </button><div class="hide-content"><p>TCP 是面向连接的；UDP 是无连接的。</p>
<p>TCP 是可靠的；UDP 是不可靠的。</p>
<p>TCP 只支持点对点通信；UDP 支持一对一、一对多、多对一、多对多的通信模式。</p>
<p>TCP 是面向字节流的；UDP 是面向报文的。</p>
<p>TCP 有拥塞控制机制；UDP 没有拥塞控制，适合媒体通信。</p>
<p>TCP 首部开销(20 个字节)，比 UDP 的首部开销(8 个字节)要大。</p>
</div></div>
]]></content>
      <categories>
        <category>资源</category>
        <category>面试题</category>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>Hibernate入门</title>
    <url>/posts/f89c868b.html</url>
    <content><![CDATA[<h3 id="Hibernate简介"><a href="#Hibernate简介" class="headerlink" title="Hibernate简介"></a>Hibernate简介</h3><h4 id="1-什么是Hibernate"><a href="#1-什么是Hibernate" class="headerlink" title="1.什么是Hibernate"></a>1.什么是Hibernate</h4><p>Hibernate是一个开放源代码的对象关系映射框架，它对JDBC进行了非常轻量级的对象封装，它将POJO与数据库表建立映射关系，是一个全自动的orm框架，hibernate可以自动生成SQL语句，自动执行，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。Hibernate可以应用在任何使用JDBC的场合，既可以在Java的客户端程序使用，也可以在Servlet&#x2F;JSP的Web应用中使用。</p>
<h4 id="2-什么是ORM"><a href="#2-什么是ORM" class="headerlink" title="2.什么是ORM"></a>2.什么是ORM</h4><p>对象关系映射（英语：Object Relation Mapping，简称ORM，或O&#x2F;RM，或O&#x2F;R mapping），是一种程序技术，用于实现面向对象编程语言里不同类型系统的数据之间的转换。<br>ORM模型的简单性简化了数据库查询过程。使用ORM查询工具，用户可以访问期望数据，而不必理解数据库的底层结构。<br>简单来说，我们使用ORM可以将我们的对象(或类)去进行映射，使得我们可以去操作对象就能完成对表的操作。</p>
<h4 id="3-Hibernate开发步骤"><a href="#3-Hibernate开发步骤" class="headerlink" title="3.Hibernate开发步骤"></a>3.Hibernate开发步骤</h4><p>创建持久化类<br>创建对象-关系映射文件<br>创建Hibernate配置文件<br>通过Hibernate API编写访问数据库的代码</p>
<h4 id="4-Hibernate的5个核心接口"><a href="#4-Hibernate的5个核心接口" class="headerlink" title="4.Hibernate的5个核心接口"></a>4.Hibernate的5个核心接口</h4><p>Configuration：负责管理hibernate配置信息<br>SessionFactory：负责创建session实例<br>Session：是hibernate持久化操作的基础，提供了众多的持久化方法<br>Transaction：是hibernate进行事务操作的接口，是对实际事务实现的一个抽象，这些实现包括JDBC的事务，JTA中的UserTransaction,甚至可以是CORBA事务。<br>Query和Criteria接口 :查询接口，用于向数据库查询对象，包装了HQL查询语言，采用了新的面向对象的查询方式。</p>
<h4 id="5-hibernate执行过程"><a href="#5-hibernate执行过程" class="headerlink" title="5.hibernate执行过程"></a>5.hibernate执行过程</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>通过<span class="type">Configuration</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Configuration</span>().configure();<span class="comment">//读取并解析hibernate.cfg.xml配置文件</span></span><br><span class="line"><span class="number">2.</span>由hibernate.cfg.xml中的&lt;mapping resource=<span class="string">&quot;com/xx/User.hbm.xml&quot;</span>/&gt;读取并解析映射信息</span><br><span class="line"><span class="number">3.</span>通过<span class="type">SessionFactory</span> <span class="variable">sf</span> <span class="operator">=</span> config.buildSessionFactory();<span class="comment">//创建SessionFactory</span></span><br><span class="line"><span class="number">4.</span><span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> sf.openSession();<span class="comment">//打开Sesssion</span></span><br><span class="line"><span class="number">5.</span><span class="type">Transaction</span> <span class="variable">tx</span> <span class="operator">=</span> session.beginTransaction();<span class="comment">//创建并启动事务Transation</span></span><br><span class="line"><span class="number">6.</span>persistent operate操作数据，持久化操作</span><br><span class="line"><span class="number">7.</span>tx.commit();<span class="comment">//提交事务</span></span><br><span class="line"><span class="number">8.</span>关闭Session</span><br><span class="line"><span class="number">9.</span>关闭SesstionFactory</span><br></pre></td></tr></table></figure>

<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><h4 id="1-hibernate-cfg-xml"><a href="#1-hibernate-cfg-xml" class="headerlink" title="1.hibernate.cfg.xml"></a>1.hibernate.cfg.xml</h4><p>注：<br>常用的配置信息都可以在hibernate-distribution-3.6.0.Final\project\etc\hibernate.properties目录下可以找到。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hibernate-configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 通常，一个session-factory节点代表一个数据库 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">session-factory</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 1. 数据库连接配置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.connection.driver_class&quot;</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.connection.url&quot;</span>&gt;</span>jdbc:mysql:///xxx<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.connection.username&quot;</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.connection.password&quot;</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--            数据库方法配置， hibernate在运行的时候，会根据不同的方言生成符合当前数据库语法的sql         --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.dialect&quot;</span>&gt;</span>org.hibernate.dialect.MySQL5Dialect<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 2. 其他相关配置 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 2.1 显示hibernate在运行时候执行的sql语句 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.show_sql&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 2.2 格式化sql --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.format_sql&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 2.3 自动建表  --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.hbm2ddl.auto&quot;</span>&gt;</span>create<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--3. 加载所有映射--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapping</span> <span class="attr">resource</span>=<span class="string">&quot;xxx/xxx/User.hbm.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">session-factory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在程序中加载映射文件：<br>在Configuration对象中提供了addClass()的方法。<br>一般地我们的映射配置文件和JavaBean对象是放在同一个包下的。并且映射文件的命名是有规范的。因此Hibernate是可以通过提供的JavaBean对象从而找到相对应的映射文件！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取加载配置管理类</span></span><br><span class="line"><span class="type">Configuration</span> <span class="variable">configuration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Configuration</span>();</span><br><span class="line"><span class="comment">//加载User的映射文件！</span></span><br><span class="line">configuration.configure().addClass(User.class);</span><br></pre></td></tr></table></figure>
<h4 id="2-映射配置文件"><a href="#2-映射配置文件" class="headerlink" title="2.映射配置文件"></a>2.映射配置文件</h4><p>映射文件: 映射一个实体类对象； 描述一个对象最终实现可以直接保存对象数据到数据库中<br>通常地，我们都是一个JavaBean对象对应一个映射配置文件，并且配置文件和JavaBean对象是放在同一个目录下的</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--在domain包下--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span> <span class="attr">package</span>=<span class="string">&quot;zhongfucheng.domain&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--类名为User，表名也为User--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">&quot;User&quot;</span>  <span class="attr">table</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--主键映射，属性名为id，列名也为id--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--根据底层数据库主键自动增长--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">&quot;native&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--非主键映射，属性和列名一一对应--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">column</span>=<span class="string">&quot;username&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;cellphone&quot;</span> <span class="attr">column</span>=<span class="string">&quot;cellphone&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">column</span>=<span class="string">&quot;password&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>节点说明：<br><strong>hibernate-mapping</strong><br>package【要映射的对象所在的包(可选,如果不指定,此文件所有的类都要指定全路径)】<br>auto-import<br>-默认为true， 在写hql的时候自动导入包名<br>-如果指定为false, 再写hql的时候必须要写上类的全名；<br><strong>class</strong><br>class 映射某一个对象的(一般情况，一个对象写一个映射文件，即一个class节点)<br>name【指定要映射的对象的类型】<br>table【指定对象对应的表】如果没有指定，默认与对象名称一样<br><strong>property</strong><br>property是普通属性的映射，即JavaBean普通的成员变量属性就使用property来描述！<br>name 指定对象的属性名称<br>column 指定对象属性对应的表的字段名称<br>-如果不写默认与对象属性一致。<br>length 指定字符的长度, 默认为255<br>type 指定映射表的字段的类型，如果不指定会匹配属性的类型<br>-java类型： 必须写全名【例：java.lang.String】<br>-hibernate类型： 直接写类型，都是小写<br>注意：如果列名称为数据库关键字，需要用反引号或改列名。当然啦，我们一般不使用关键字来作为列名<br><strong>id</strong><br>id是主键映射<br>name 指定对象的属性名<br>column 指定对象属性对应的表的字段名称<br><strong>generator</strong><br>主键的自动生成策略<br> identity 自增长(mysql,db2)<br> sequence 自增长(序列)， oracle中自增长是以序列方法实现<br> native 自增长【会根据底层数据库自增长的方式选择identity或sequence】<br>  -如果是mysql数据库, 采用的自增长方式是identity<br>  -如果是oracle数据库， 使用sequence序列的方式实现自增长<br> increment 自增长(会有并发访问的问题，一般在服务器集群环境使用会存在问题。)<br>  -指定主键生成策略为手动指定主键的值<br> assigned<br>  -指定主键生成策略为UUID生成的值<br> uuid<br> foreign(外键的方式)<br><strong>composite-id</strong><br>主键一般分为两种：单列主键、多列复合主键<br>单列主键使用上述generator的方式<br>多列复合主键就需要使用composite-id节点来配置了<br>步骤：<br>想要使用username和password作为复合主键？<br>-将username和password抽取成一个类—-&gt;CompositeKey….必须实现Serializable接口<br>-在User2中需要指定一个变量来维护这个主键对象</p>
<h4 id="2-configuration-配置对象"><a href="#2-configuration-配置对象" class="headerlink" title="2.configuration:配置对象"></a>2.configuration:配置对象</h4><h5 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h5><p>在使用hibernate的时候,首先要创建configuration的实例,Configuration实例主要用于启动,加载,管理hibernate的配置文件信息,在启动hibernate的过程中,configuration首先确定hibernate的配置文件的位置,然后读取相关配置,最后创建一个唯一的SessionFactory实例,configuration值存在于最初的系统初始化阶段,它将sessionFactory创建完成之后,就完成它的使命了.hibernate通常会使用new Configuration().configure(),来创建一个配置类对象,默认的是在resources下的hibernate.cfg.xml配置文件,如果不想创建和该文件名一样的xml配置文件,可以在cofigure()中添加一个参数,参数的内容是配置文件的名称。<br>注：<br>它拥有一个子类AnnotationConfiguration，也就是说：我们可以使用注解来代替XML配置文件来配置相对应的信息</p>
<h5 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h5><p>configure()方法用于加载配置文件<br> -如果指定参数，那么加载参数的路径配置文件<br> -如果不指定参数，默认加载src&#x2F;目录下的hibernate.cfg.xml<br>buildSessionFactory()用于创建Session工厂</p>
<h4 id="3-sessionFactory：session的工厂对象，也可以说代表了hibernate-cfg-xml这个文件"><a href="#3-sessionFactory：session的工厂对象，也可以说代表了hibernate-cfg-xml这个文件" class="headerlink" title="3.sessionFactory：session的工厂对象，也可以说代表了hibernate.cfg.xml这个文件"></a>3.sessionFactory：session的工厂对象，也可以说代表了hibernate.cfg.xml这个文件</h4><h5 id="作用：-1"><a href="#作用：-1" class="headerlink" title="作用："></a>作用：</h5><p>sessionFactory接口负责将Hibernate的初始化和建立session对象,它在hibernate中起到一个缓冲区的作用,hibernate可以将自动生成的sql语句,映射数据以及某些可重复利用的数据放在这个缓冲区中,同时它还保存了对数据库配置的所有映射关系,维护了当前的二级缓存。<br>特点：<br>线程安全，它的同一个实例能够提供多个线程共享<br>重量级的，不能随意的创建和销毁它的实例</p>
<h5 id="方法：-1"><a href="#方法：-1" class="headerlink" title="方法："></a>方法：</h5><p>openSession方法创建一个Session对象<br>getCurrentSession方法创建Session对象或取出Session对象<br>两种方式的区别：<br>openSession获取Session时，sessionFactory直接创建一个新的Session实例，并在使用完成后需要调用close()手动关闭<br>getCurrentSession创建的Session实例会被绑定到当前线程种，它在提交或回滚操作时会自动关闭。</p>
<h4 id="8-Session：Hibernate最重要的对象"><a href="#8-Session：Hibernate最重要的对象" class="headerlink" title="8.Session：Hibernate最重要的对象"></a>8.Session：Hibernate最重要的对象</h4><h5 id="作用：-2"><a href="#作用：-2" class="headerlink" title="作用："></a>作用：</h5><p>Session是应用程序与数据库之间交互操作的一个单线程对象，是Hibernate运作的中心，它的主要功能是为持久化对象提供创建、读取和删除的能力，所有持久化对象必须在session的管理下才可以进行持久化操作。<br>Session是线程不安全的，多个并发线程同时操作一个Session实例时，可能导致Session数据存取的混乱</p>
<h5 id="删除操作："><a href="#删除操作：" class="headerlink" title="删除操作："></a>删除操作：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">session.delete();  【删除一个对象】</span><br></pre></td></tr></table></figure>
<h5 id="更新操作："><a href="#更新操作：" class="headerlink" title="更新操作："></a>更新操作：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">session.save(obj); 【保存一个对象】</span><br><span class="line">session.update(obj); 【更新一个对象】</span><br><span class="line">session.saveOrUpdate(obj); 【保存或者更新的方法】</span><br><span class="line">-没有设置主键，执行保存；</span><br><span class="line">-有设置主键，执行更新操作;</span><br><span class="line">-如果设置主键不存在报错！</span><br></pre></td></tr></table></figure>
<h5 id="主键查询："><a href="#主键查询：" class="headerlink" title="主键查询："></a>主键查询：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">session.get(javaBean.class, <span class="type">int</span> id); 【传入对应的class和id就可以查询】</span><br><span class="line">session.load(javaBean.class, <span class="type">int</span> id); 【支持懒加载】</span><br></pre></td></tr></table></figure>
<h5 id="HQL查询："><a href="#HQL查询：" class="headerlink" title="HQL查询："></a>HQL查询：</h5><p><strong>HQL vs SQL</strong><br>HQL:hibernate query language 即hibernate提供的面向对象的查询语言<br>注：<br>查询的是对象以及对象的属性【因此是区分大小写的！】。<br>HQL是面向对象的查询语言，可以用来查询全部的数据！<br>SQL：Struct query language 结构化查询语言<br>注：<br>查询的是表以及列【不区分大小写】<br>实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Query</span> <span class="variable">query</span> <span class="operator">=</span> session.createQuery(<span class="string">&quot;FROM User&quot;</span>);</span><br><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> query.list();</span><br><span class="line">System.out.println(list);</span><br><span class="line"><span class="type">Query</span> <span class="variable">query</span> <span class="operator">=</span> session.createQuery(<span class="string">&quot;FROM User WHERE id=?&quot;</span>);</span><br><span class="line"><span class="comment">//这里的？号是从0开始的，并不像JDBC从1开始的！</span></span><br><span class="line">query.setParameter(<span class="number">0</span>, user.getId());</span><br><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> query.list();</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure>
<h5 id="QBC查询"><a href="#QBC查询" class="headerlink" title="QBC查询"></a>QBC查询</h5><p>QBC查询: query by criteria 完全面向对象的查询<br>HQL查询是需要SQL的基础的，因为还是要写少部分的SQL代码….QBC查询就是完全的面向对象查询…但是用得比较少</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建关于user对象的criteria对象</span></span><br><span class="line"><span class="type">Criteria</span> <span class="variable">criteria</span> <span class="operator">=</span> session.createCriteria(User.class);</span><br><span class="line"><span class="comment">//添加条件</span></span><br><span class="line">criteria.add(Restrictions.eq(<span class="string">&quot;id&quot;</span>, <span class="number">1</span>));</span><br><span class="line"><span class="comment">//查询全部数据</span></span><br><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> criteria.list();</span><br><span class="line"> System.out.println(list);</span><br></pre></td></tr></table></figure>
<h5 id="本地SQL查询"><a href="#本地SQL查询" class="headerlink" title="本地SQL查询"></a>本地SQL查询</h5><p>有的时候，如果SQL是非常复杂的，我们不能靠HQL查询来实现功能的话，我们就需要使用原生的SQL来进行复杂查询了！<br>但是呢，它有一个缺陷：它是不能跨平台的…因此我们在主配置文件中已经配置了数据库的“方言“了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将所有的记录封装成User对象存进List集合中</span></span><br><span class="line"><span class="type">SQLQuery</span> <span class="variable">sqlQuery</span> <span class="operator">=</span> session.createSQLQuery(<span class="string">&quot;SELECT * FROM user&quot;</span>).addEntity(User.class);</span><br><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> sqlQuery.list();</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure>
<h5 id="beginTransaction方法"><a href="#beginTransaction方法" class="headerlink" title="beginTransaction方法"></a>beginTransaction方法</h5><p>开启事务，返回的是一个事务对象….Hibernate规定所有的数据库操作都必须在事务环境下进行，否则报错！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Transaction transaction=session.beginTransaction();</span><br></pre></td></tr></table></figure>
<h4 id="9-transaction事务"><a href="#9-transaction事务" class="headerlink" title="9.transaction事务"></a>9.transaction事务</h4><p>Transaction接口主要用于管理事务，它是Hibernate的数据库事务接口，Transaction接口的事务对象是通过Session对象开启的<br>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">transaction.commit();  提交相关联的session实例</span><br><span class="line">transaction.rollback();  撤销事务操作</span><br></pre></td></tr></table></figure>

<h3 id="Hibernate的一级缓存"><a href="#Hibernate的一级缓存" class="headerlink" title="Hibernate的一级缓存"></a>Hibernate的一级缓存</h3><p>Hibernate的缓存分为一级缓存和二级缓存，Hibernate的混村都位于持久化层，存储的是数据库数据的备份，其中一级缓存为Hibernate的内置缓存，不能被卸载。<br>一级缓存：<br>就是指Session缓存，Session缓存是一块内存空间，用来存放相互管理的java对象，在使用Hibernate查询对象的时候，首先会使用对象属性的OID值在Hibernate的一级缓存种进行查找，如果找到，就将对应的对象从一级缓存中去除使用，不会再去查询数据库；如果没有找到，才会去数据库中查找相应数据，当从数据库中查询到所需数据时，该数据信息会被放置到一级缓存中。<br>一级缓存的作用：<br>减少对数据库的访问次数。<br>一级缓存的特点;<br>调用save()、update()、saveOrUpdate()时，如果一级缓存中没有相应对象，就会自动将信息加入一级缓存<br>调用load()、get()、Query接口的list()、iterator()时，会先去一级缓存查看是否存在该对象，没有再去数据库，并添加进一级缓存<br>调用close()时，一级缓存会被清空。</p>
<hr>
<p>😄END</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title>Java入门</title>
    <url>/posts/f7ede91d.html</url>
    <content><![CDATA[<h3 id="基础语法："><a href="#基础语法：" class="headerlink" title="基础语法："></a>基础语法：</h3><h5 id="1、Java源文件与字节码文件："><a href="#1、Java源文件与字节码文件：" class="headerlink" title="1、	Java源文件与字节码文件："></a>1、	Java源文件与字节码文件：</h5><p>源文件.java<br>字节码文件.class<br>注：Java源文件中包含N个类则编译生成N个class文件。</p>
<h5 id="2、java、javac命令、环境变量："><a href="#2、java、javac命令、环境变量：" class="headerlink" title="2、	java、javac命令、环境变量："></a>2、	java、javac命令、环境变量：</h5><p>Cd：下一级文件夹<br>cd…:上一级文件夹<br>编译：javac java的文件<br>运行：java 文件<br>执行：文件名<br>基本命令：javac：Java编译器   java:Java解释器  jdb:java调试器  javap:反编译   javadoc:文档生成器   appletviwer:applet解释器</p>
<h5 id="3、关键字："><a href="#3、关键字：" class="headerlink" title="3、关键字："></a>3、关键字：</h5><p>class、abstract表明是抽象的、package、import导入、extends继承、implements实现接口、static静态的、void无返回值、<br>final最终不可改、interface定义接口、super调用父类、this、return、new、private 私有的、instanceof 判断对象</p>
<h5 id="4、main方法："><a href="#4、main方法：" class="headerlink" title="4、main方法："></a>4、main方法：</h5><p>定义、作用：程序运行的入口</p>
<h5 id="5、标识符命名规则："><a href="#5、标识符命名规则：" class="headerlink" title="5、标识符命名规则："></a>5、标识符命名规则：</h5><p>约定：字母小写、类与接口单词首字母大写、常量大写单词用_隔开、变量与方法第一个单词首字母小写，后面的单词首字母大写<br>规则：第一个字母以字母、下划线、$开头</p>
<h5 id="6、数据类型：基本数据类型与引用数据类型"><a href="#6、数据类型：基本数据类型与引用数据类型" class="headerlink" title="6、数据类型：基本数据类型与引用数据类型"></a>6、数据类型：基本数据类型与引用数据类型</h5><p>（1）基本数据类型对应的封装类型：Byte Short Interger….<br>（2）byte类型的范围[-128,127]   byte b&#x3D;127;  b++为多少？-128<br>（3）boolean（true与false）<br>（4）分类：<br>自动类型转换(小转大）：byte&lt;short、char&lt;int&lt;long&lt;float&lt;double<br>强制类型转换(大转小)：目标类型 变量名&#x3D;(目标类型)值<br>（5）String与数值型的转换</p>
<h5 id="7、运算符："><a href="#7、运算符：" class="headerlink" title="7、	运算符："></a>7、	运算符：</h5><p>（1）	&#x2F; 与 %    1&#x2F;2 、 1.0&#x2F;2、  1%2<br>（2）	a++（先其他后自增）与++a（先自增后其他）a- -（先其他后自减）与- -a（先自减后其他）<br>（3）	&amp;&amp;与&amp;、||与|<br>（4）	优先级别：括号 &gt; 算术 &gt; 关系(&lt;&lt; &gt;&gt; &gt;&gt;&gt; &lt; &gt; &lt;&#x3D; &gt;&#x3D; &#x3D;&#x3D; ¡&#x3D;) &gt; 逻辑(&amp; ^ | &amp;&amp; || ?: ) &gt; 赋值</p>
<h5 id="8、流程控制："><a href="#8、流程控制：" class="headerlink" title="8、	流程控制："></a>8、	流程控制：</h5><p>（1）顺序结构<br>（2）选择结构（分支）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(控制表达式（不能为Boolean类型）)&#123;</span><br><span class="line"><span class="keyword">case</span> 目标值：</span><br><span class="line">    执行语句</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">…</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（3）循环结构</p>
<blockquote>
<p>1.while(条件){执行语句}<br>2.Do {执行语句}while(条件)<br>3.For(初始表达式;循环条件;操作表达式){执行语句}<br>4.For(元素类型 变量名:数组名或集合名)<br>jdk5.0之后的新特性，叫做增强for循环或foreach</p>
</blockquote>
<p>注：if…else…:配对就近原则<br>循环结构中，break与continue的作用：<br>Break:跳出当前循环结构；<br>continue:终止本次循环，执行下一次循环；</p>
<h5 id="9、数组："><a href="#9、数组：" class="headerlink" title="9、	数组："></a>9、	数组：</h5><p>数组是引用数据类型，数组的父类是object<br>Main方法的string[] args数组的作用：接收用户输入的参数，形成数组中元素<br>Object[ ] ：可装任何数据类型的元素<br>常见算法：（面试时可能会用到）：冒泡排序法、选择排序法、二分法查找<br>（1）一维数组的定义与引用、下标从0到length-1（数组下标越界异常）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">类型[] 名=<span class="keyword">new</span> 类型[长度]（动态初始化数组）Int[] arr=<span class="keyword">new</span> <span class="title class_">Int</span>[<span class="number">10</span>]</span><br><span class="line">类型[] 名=<span class="keyword">new</span> 类型[]&#123;元素<span class="number">1</span>,元素<span class="number">2</span>&#125;（静态初始化数组）Int[] arr=<span class="keyword">new</span> <span class="title class_">Int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">类型[] 名=&#123;元素<span class="number">1</span>，元素<span class="number">2</span>&#125;   Int[] arr=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>
<p>（2）数组操作的常用方法：<br>Arrays.方法(数组名)：使用前需导入Arrays类<br>数组的遍历toString()<br>比较相等equals()<br>排序sort()<br>二分查找binarySearch()<br>填充fill()<br>（3）二维数组的定义和引用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">类型[][] 名=<span class="keyword">new</span> 类型[行数][列数]  Int[][] arr=<span class="keyword">new</span> <span class="title class_">Int</span>[<span class="number">2</span>][<span class="number">3</span>]</span><br><span class="line">类型[][] 名=&#123;&#123;数组<span class="number">1</span>&#125;,&#123;数组<span class="number">2</span>&#125;,&#123;数组<span class="number">3</span>&#125;&#125;  Int[][]  arr=&#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5.6</span>&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>（4）数组的优点：<br>检索效率高：内存地址连续、元素类型相同、通过数学表达式计算某个下标上元素的内存地址，从而定位元素。<br>缺点：随机增删元素效率比较低。数组无法存储大数据量</p>
<h5 id="10、字符串"><a href="#10、字符串" class="headerlink" title="10、字符串"></a>10、字符串</h5><p>（1）字符串比较：&#x3D;&#x3D;    equals<br>（2）常用方法：length()、substring(m,n)、split()</p>
<h5 id="11、生成随机数的方法："><a href="#11、生成随机数的方法：" class="headerlink" title="11、生成随机数的方法："></a>11、生成随机数的方法：</h5><p>Math.random()     [0，1)  </p>
<h3 id="二、类与对象"><a href="#二、类与对象" class="headerlink" title="二、类与对象"></a>二、类与对象</h3><h5 id="1、面向对象的三大特征："><a href="#1、面向对象的三大特征：" class="headerlink" title="1、	面向对象的三大特征："></a>1、	面向对象的三大特征：</h5><p>封装、继承、多态</p>
<h5 id="2、类与对象的关系："><a href="#2、类与对象的关系：" class="headerlink" title="2、	类与对象的关系："></a>2、	类与对象的关系：</h5><p>类是对象的抽象,对象是类的具体化。</p>
<h5 id="3、类的基本构成："><a href="#3、类的基本构成：" class="headerlink" title="3、	类的基本构成："></a>3、	类的基本构成：</h5><p>成员方法和成员变量，局部变量（方法体之内）与成员变量（方法体之外，类之内）的区别</p>
<h5 id="4、访问修饰符："><a href="#4、访问修饰符：" class="headerlink" title="4、	访问修饰符："></a>4、	访问修饰符：</h5><p>public(同类同包子类全局)、proctected保护的(同类同包子类)、private私有的(同类)、default缺省(同类同包)<br>访问级别：private  &lt;  default  &lt;  protected  &lt;  public<br>注：类只能用public与default修饰（内部类除外）</p>
<h5 id="5、方法："><a href="#5、方法：" class="headerlink" title="5、	方法："></a>5、	方法：</h5><p>（1）	方法的定义：修饰符 返回值类型 方法名(参数类型){方法体；return 返回值；}<br>（2）构造方法（构造函数、构造器）：<br>作用：创建对象的同时，初始化实例变量（即赋值）<br>特点：方法名与类名相同、没有返回值类型、不能用return返回值，可以return结束方法<br>何时被调用：new构造方法名()<br>（3）方法的重载与重写（覆盖）：与方法的返回值类型和修饰符列表无关 重载的方法与原方法参数列表与方法体不同，其他相同<br>（4）方法的调用：<br>没有static的，叫实例方法，先创建new引用，再引用.方法名(实参)调用<br>静态方法的调用：类名.方法名(实参)</p>
<h5 id="6、final、static、super、this关键字的作用："><a href="#6、final、static、super、this关键字的作用：" class="headerlink" title="6、	final、static、super、this关键字的作用："></a>6、	final、static、super、this关键字的作用：</h5><p>this：<br>代表此时正在实行的对象<br>只能在构造方法使用this调用其他构造方法，不能在成员方法或带有static的方法中使用。<br>This调用语句需要在第一条<br>Static：<br>所有对象都有的属性，可以定义为静态变量。<br>Static只能用来修饰成员变量，不能修饰局部变量<br>使用类名.变量名&#x2F;方法名来调用<br>静态代码块：static{…}<br>在类加载时执行，只执行一次，自上而下依次执行<br>Super：<br>调用父类的成员变量与成员方法<br>调用父类方法：Super.父类方法()<br>调用父类的构造方法：super(参数1,参数2)<br>Final：<br>final修饰的类不能被继承。<br>final修饰的方法不能被子类重写。<br>final修饰的成员变量（声明的同时必须赋值）与局部变量（声明并赋值，声明后赋值）是常量，只能赋值一次</p>
<h5 id="7、继承："><a href="#7、继承：" class="headerlink" title="7、	继承："></a>7、	继承：</h5><p>特点：<br>类只支持单继承，不支持多继承。接口可以多继承。<br>注意：<br>重写的方法只有方法体、访问修饰符与被重写的方法不同<br>重写后，子类无法访问被重写的父类方法<br>重写的方法不能使用比被重写的方法低的访问修饰符等级<br>注：Object类：所有类的父类，当定义一个类时，没有使用extends时，默认继承object类</p>
<h5 id="8、抽象类与接口"><a href="#8、抽象类与接口" class="headerlink" title="8、	抽象类与接口"></a>8、	抽象类与接口</h5><p>（1）均不能使用new实例化<br>（2）接口是特殊的抽象类，JDK8以前版本中，接口只能包含公共常量和抽象方法；之后的版本还可以包含默认方法和静态方法。<br>（3）一个类实现接口就必须实现接口中的所有方法。<br>（4）一个类可以同时实现多个接口。Implements<br>抽象类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 <span class="keyword">abstract</span> class类名&#123;</span><br><span class="line">    抽象方法：修饰符 <span class="keyword">abstract</span> 返回值类型 方法名()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 interface 接口名 [extends 父接口<span class="number">1</span>,父接口<span class="number">2</span>…]&#123;</span><br><span class="line">    公共常量：<span class="type">int</span> 变量名=值:</span><br><span class="line">    抽象方法：<span class="keyword">void</span> 方法名();</span><br><span class="line">    默认方法：<span class="keyword">default</span> <span class="keyword">void</span> 方法名()&#123;&#125;</span><br><span class="line">    静态方法：<span class="keyword">static</span> 数据类型 方法名()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类实现继承与接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 <span class="keyword">class</span> <span class="title class_">extends</span> 父类名 implements 接口<span class="number">1</span>,接口<span class="number">2</span>&#123;</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：当一个类实现接口，若此类是抽象类，只需要实现接口部分抽象方法，其他类则需要实现全部接口的所有抽象方法。</p>
<h5 id="9、多态性："><a href="#9、多态性：" class="headerlink" title="9、	多态性："></a>9、	多态性：</h5><p>（1）向上转型：子转父</p>
<blockquote>
<p>父类 引用&#x3D;new 子类();</p>
</blockquote>
<p>引用.方法名()<br>注：此处调用的方法为子类的方法<br>（2）向下转型：父转子<br>子类 子类的引用&#x3D;(子类) 父类的引用<br>注：关键字instanceof：可判断一个对象是否为某类的实例或子类实例。<br>语法格式：</p>
<blockquote>
<p>对象（或者对象的引用） instanceof 类（或接口）  运行结果为布尔类型</p>
</blockquote>
<p>注意：<br>子类对象可以直接赋值给父类引用<br>父类对象不能直接赋值给子类对象，必须强制还原，并且只是上转型对象才能被还原<br>类型转换的大前提：两种类型之间必须有继承关系</p>
<h5 id="10、内部类："><a href="#10、内部类：" class="headerlink" title="10、内部类："></a>10、内部类：</h5><p>分类：静态内部类、实例内部类、局部内部类</p>
<h5 id="11、异常处理："><a href="#11、异常处理：" class="headerlink" title="11、异常处理："></a>11、异常处理：</h5><p>常见异常：空指针异常、类型转换异常、数组下标越界异常、数字格式化异常<br>（1）try…catch和finally ：可包含多个catch ，捕获处理异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    可能发生异常的语句</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception类或其子类 e)&#123;</span><br><span class="line">    处理语句</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    不管是否发生异常，都执行<span class="keyword">finally</span>的语句，可以用来执行重要的关闭代码（除非<span class="keyword">try</span>…<span class="keyword">catch</span> 中执行了System.exit(<span class="number">0</span>)语句，即退出当前的Java虚拟机，<span class="keyword">finally</span>语句也不执行）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（2）throw ：手动抛出异常，用在方法体内，抛出一个异常类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数类型 参数名)<span class="keyword">throws</span> 抛出的异常类&#123;</span><br><span class="line">    方法体</span><br><span class="line">    Throw <span class="keyword">new</span> <span class="title class_">Exception</span>类或其子类构造方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（3）throws：声明抛出异常,用在方法名的后面，指明方法可能抛出多个异常<br>注意：子类不能比父类抛出更多的异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数类型 参数名)<span class="keyword">throws</span> 抛出的异常类&#123;</span><br><span class="line">    方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（4）自定义异常类：第一步，继承Exception或RuntimeException;第二步，提供一个无参和一个有String参数的构造方法<br>（5）异常对象两个重要方法：<br>String msg&#x3D;exception.getMessage():获取异常的简单的描述信息<br>Exception.printStackTrace():Java后台打印异常堆信息</p>
<h5 id="12、Java的常用类"><a href="#12、Java的常用类" class="headerlink" title="12、Java的常用类"></a>12、Java的常用类</h5><p>（1）Object类：所有类的根类<br> Tostring方法：返回对象的字符串形式，使用时建议重写<br> Equals方法：默认比较两个对象的内存地址是否相等，要比较对象的内容时，必须重写<br> Finalize方法：在对象即将被垃圾回收器回收时执行，垃圾少或小时可能不执行也可能执行<br> GC负责调用finalize方法<br> System.gc();建议启动垃圾回收器<br>（2）	String类：<br>注意：“字符串”.方法()<br>常用方法：使用引用.方法名（）进行调用</p>
<blockquote>
<p>char charAt(int index):返回字符串中index下标的字符<br>int compareTo(string anotherString):按字典顺序比较字符串的大小（0相等、1前大后小、-1前小后大，只比较第一个字符）<br>Boolean contains(CharSequence cs):判断该字符串是否包含指定字符序列<br>Boolean endsWith(String suffix):判断当前字符串是否以某字符串结尾<br>Boolean equalsIgnoreCase(String anotherString):判断两个字符串是否相等，忽略大小写<br>Byte getByte():将字符串转换成字节数组<br>Char[] toCharArray():将字符串转换成char数组<br>Int indexOf(String str):判断某个字符串在当前字符串中第一次出现的下标<br>Boolean isEmpty():判断某个字符串是否为空，length（）为0时返回true<br>Int LastIndexOf(String str):判断某个字符串在当前字符串中最后一次出现的下标<br>String replace(CharSequence target,CharSequence replacement):将字符target替换为replacement<br>String[] split(String regex):以regex为分隔拆分字符串<br>Boolean startsWith(String prefix):判断某个字符串是否以某个字符串开始<br>String substring(int beginIndex，int endindex):从beginindex（包括）开始,endIndex（不包括）结束截取字符串<br>String toLowerCase():转换成小写<br>String toUpperCase():转换成大写<br>String trim():去除字符串前后空白，中间空白不可以</p>
</blockquote>
<p>静态方法：类名.valueOf(非字符串)：将非字符串转换成字符串<br>（3）Stringbuffer类：是线程安全的<br>（4）StringBuilder类：是非线程安全的<br>（5）Number类：是一个抽象类，是数字类型（int、short…）包装类的父类<br> 装箱：基本数据类型—》引用数据类型<br> 拆箱：引用数据类型—》基本数据类型   number的公共方法进行操作<br> 包装类的重要静态方法：包装类名.parseInt(String s)<br>-128~127数值范围的数据在创建数据类型的包装类时，方法区的整数型常量池中已经有了256个对象，因此如果比较是否相等时，是true<br>（6）System类：System.gc():建议启动gc垃圾回收器<br>System.exit():退出jvm<br>System.currentTimeMillis():获取自1970年1月1日00：00：00到当前系统时间的总毫秒数<br>（7）日期类<br>Date()：在Date包，使用前需导包，获取当前系统时间<br>Date(int hms):参数是毫秒数，用于计算从1970加hms的时间<br>SimpleDateFormat:text包下的，专门负责日期格式化   引用.format(Date的引用)<br>特定格式：yyyy年  MM月  dd日  HH时  mm分  ss秒  SSS毫秒<br>日期字符串String转Date:  Date SimpleDateFormat的引用.parse(String s)   格式需一致<br>System.currentTimeMillis():获取自1970年1月1日00：00：00到当前系统时间的总毫秒数    可用于计算一个方法执行的总毫秒数<br>（8）枚举：是引用数据类型，可以作为返回值，并创建多个枚举值</p>
<h5 id="13、集合"><a href="#13、集合" class="headerlink" title="13、集合"></a>13、集合</h5><p>注意：集合类和集合接口都在Java.util包下<br>（1）集合概述：集合实际上是一个容器或一个对象，可以容纳其他类型的数据。集合不能直接储存基本数据类型和Java对象。集合当中存储的是Java对象的内存地址或者说引用。<br>（2）Collection接口：<br>存储元素：<br>在没有使用泛型之前，collection中可以存储object的所有子类型，使用泛型后，只能存储某个具体的类型。<br>泛型：<br>泛型只在程序编译阶段起作用，运行阶段没用，只能存储某个具体的类型<br>泛型的优点：<br>集合的元素类型统一了、取出类型是指定类型，所以不需要进行大量的“向下转型”、调用多个子类的 父类方法时，不需转型<br>泛型的缺点：存储的元素缺乏多样性<br>常见方法：</p>
<blockquote>
<p>Boolean add(Object e) 向集合中添加元素<br>Int size() 获取集合中元素的个数<br>Void clear() 清空集合<br>Boolean contains(Object o) 判断当前集合是否包含o元素<br>Contains在底层string重写了equals方法，比较的是内容<br>Boolean remove(Object o) 删除o元素<br>Remove在底层也调了equals方法，删除的是内容<br>Boolean isEmpty() 判断集合是否为空<br>bject[] toArray() 将集合转换成数组（使用不多）<br>Iterator迭代器（是一个对象）：Iterator it(引用)&#x3D; c(collection对象的引用).iterator()</p>
</blockquote>
<blockquote>
<blockquote>
<p>注意：集合结构一但发生变化，迭代器必须重新获取<br>   迭代过程中，使用迭代的引用来增删元素<br>方法：可使用while循环来迭代</p>
</blockquote>
</blockquote>
<blockquote>
<p>Boolean hasNext() 如果仍有元素可以迭代，则返回true<br>Object next() 返回迭代的下一个元素</p>
</blockquote>
<p>（3）List接口  有序可重复<br>List 的特有常见方法：</p>
<blockquote>
<p>void add(int index,Object element) 在元素的指定下标插入指定元素<br>Object set(int index,Object element) 修改指定下标的元素<br>Object get(int index) 根据下标获取元素<br>Int intdexOf(Object o) 获取指定对象第一次出现的下标<br>Int lastIntdexOf(Object o) 获取指定对象最后一次出现的下标<br>Object remove(int index) 删除指定下标的元素<br>boolean add(E e) 将指定的元素添加到此列表的尾部。<br>void add(int index, E element) 将指定的元素插入此列表中的指定位置。<br>boolean addAll(Collection&lt;? extends E&gt; c) 按照指定 collection 的迭代器所返回的元素顺序，将该 collection 中的所有元素添加到列表的尾部。<br>boolean contains(Object o) 如果此列表中包含指定的元素，则返回 true。<br>void ensureCapacity(int minCapacity) 如有必要，增加此 ArrayList 实例的容量，以确保它至少能够容纳最小容量参数所指定的元素数。<br>E get(int index) 返回此列表中指定位置上的元素。<br>int indexOf(Object o) 返回此列表中首次出现的指定元素的索引，或如果此列表不包含元素，则返回 -1。<br>boolean isEmpty() 如果此列表中没有元素，则返回 true<br>int lastIndexOf(Object o) 返回此列表中最后一次出现的指定元素的索引，或如果此列表不包含索引，则返回 -1。<br>E remove(int index) 移除此列表中指定位置上的元素。<br>E set(int index, E element) 用指定的元素替代此列表中指定位置上的元素。<br>int size() 返回此列表中的元素数。<br>Object[] toArray() 按适当顺序（从第一个到最后一个元素）返回包含此列表中所有元素的数组。<br><T> T[] toArray(T[] a) 按适当顺序（从第一个到最后一个元素）返回包含此列表中所有元素的数组；返回数组的运行时类型是指定数组的运行时&gt;类型。<br>void trimToSize() 将此 ArrayList 实例的容量调整为列表的当前大小。</p>
</blockquote>
<p><em>ArrayList集合</em>：<br>初始化容量为10（先创建一个长度为0的数组，当第一个元素加入时，初始化容量为10）。集合底层是一个Object类型组。扩容增长到原容量的1.5倍。<br><em>Vector集合</em>：<br>初始化容量为10，集合底层是一个Object类型，扩容增长到原容量的2倍。所有方法都是线程同步的（带有syncnronized关键字），但效率较低<br><em>LinkedList集合</em><br>链表：基本单元是节点，节点都有两个属性：存储的数据、下一个节点的内存地址。链表的元素在空间存储上。内存地址不连续<br>分为两类：单向链表和双向链表<br>链表的优点：随机增删元素的效率比较高（因为不涉及大量元素的位移）<br>链表的缺点：查询效率比较低，每次查找都需从头节点开始往下遍历<br>（4）Set接口<br><em>HashSet集合</em>：底层实际上new了一个HashMap集合。向HashSet集合存储元素，实际上是存储到了HashMap集合中	<br><em>TreeSet集合</em>: 继承ShortedSet接口（ShortedSet接口继承Set接口）底层实际上是一个TreeMap。无序不可重复可排序（按字典顺序升序）<br>无法对自定义类型进行排序，因为没有实现Java.lang.Comporable接口<br>要想做到排序包括两种方式：<br>第一，实现Java.lang.Comporable接口（建议当比较规则不会发生改变或只有一个时使用）<br>第二，在构造TreeSet集合的时候给它传一个比较器对象（建议当比较规则多个，并且需要频繁切换比较规则时使用）<br>（5）Map接口<br>Map与Collection没有继承关系。无序不可重复<br>常用方法：<br>V put(K key , V value) 向Map集合中添加键值对<br>V get(Object key) 通过key获取value</p>
<blockquote>
<p>Void clear()  清空Map集合<br>Boolean containsKey(Object key) 判断Map中是否包含某个key<br>Boolean containsValue(Object key) 判断Map中是否包含某个value<br>Boolean isEmpty()  判断Map集合中的元素个数是否为0<br>Set<K> keyset()  获取Map集合所有的key，所有键是一个Set集合<br>V remove(Object key)  通过key删除键值对<br>Int size()  获取Map集合中键值对的个数<br>Collection<V> value()  获取Map集合中所有的value，返回一个Collection类型<br>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() 将Map集合转换成Set集合</p>
<blockquote>
<p>注：Map.Entry&lt;K,V&gt;是一个类型</p>
</blockquote>
</blockquote>
<p><em>HashMap集合</em>：<br>默认初始化容量是16，默认加载因子是0.75（容量达到75%，数组开始扩容，扩容增长到原容量的2倍。）<br>初始化容量必须是2的倍数。非线程安全的<br>常见方法：map.put(k,v)  放   v&#x3D;map.get(k)  取<br><em>Hashtable集合</em>：<br>初始化容量为11，默认加载因子是0.75（容量达到75%，数组开始扩容，扩容增长到（原容量*2）+1）。线程安全的<br><em>Properties集合</em>：<br>一个Map集合，继承Hashtable，因此是线程安全的。Properties的key和value都是String类型。<br>常见方法：引用.setProperty(k,v)  存   引用.getProperty(k)  取<br><em>TreeMap集合</em>：<br>继承SortedMap接口（SortedMap接口继承Map接口，是无序不可重复可自动排序的）<br>哈希表：<br>哈希表是数组和单向链表二者优点的结合体<br>放在HashMap集合key部分的元素，以及放在HashSet集合中的元素，需要同时重写hashCode()和equals()方法<br>Hash值相同放在同一个单向链表里<br>常见方法：map.put(k,v)  放   v&#x3D;map.get(k)  取<br>自平衡二叉树：<br>遵循左小右大原则存放<br>遍历的三种方式：<br>前序遍历：根左右<br>中序遍历：左根右<br>后序遍历：左右根<br>注：前中后指的是根的位置，根也就是交叉的节点</p>
<h5 id="14、IO流"><a href="#14、IO流" class="headerlink" title="14、IO流"></a>14、IO流</h5><p>(1)	概述：I：Input O：Output  通过IO可以完成硬盘文件的读与写<br>(2)	分类：<br>按流的方向：<br>往内存去叫输入&#x2F;读（read）<br>从内存出叫输出&#x2F;写（write）<br>按读取数据方式：<br>万能流：可读文本，图片，声音，视频…<br>字符流：可读纯文本<br>(3)	常见的方法：<br>引用.readline()   读一行，不换行<br>close() 用完流一定要关闭<br>flush() 输出流可以执行该方法清空管道<br>(4)	字节流与字符流：字节流：以Stream结尾   字符流：以Reader&#x2F;writer结尾<br>a)	四个抽象类<br>字节输入流：Java.io.InputStream<br>字节输出流：Java.io.OutputStream<br>字符输入流：Java.io.Reader<br>字符输出流：Java.io.Writer<br>b)	File类：<br>常用方法：</p>
<blockquote>
<p>引用.exists()   判断文件是否存在<br>引用.createNewFile()  以文件形式新建<br>引用.mkdir()   以目录形式新建  引用.mkdirs()   以多重目录形式新建<br>引用.getParent()   获取文件的上级路径<br>引用.getName()   获取文件名	<br>引用.isDirectory()   判断是否是一个目录<br>引用.isFile()   判断是否是一个文件<br>引用.LastModified()  获取文件最后一次修改时间<br>引用.length()   获取文件的大小（字节）<br>引用.ListFiles()   获取当前目录下的所有的子文件</p>
</blockquote>
<p>c)	16个常见的流：（使用前要创建对象）<br>d)	获取一个文件的绝对路径（通用）：<br>直接以流的形式返回：InputStream in&#x3D;Thread.currentThread().getContextClassLoader().getResourceAsStream(“src下的相对路径”)<br>e)	资源绑定器（java.util.ResourceBundle）：ResourceBundle.getBundle(“xxx”)<br>便于获取属性配置文件的内容<br>注：只能绑定xxx.properties文件，且文件必须放在类路径(src)下，括号内路径后的扩展名不能写<br><em>文件专属</em>：<br>FileInputStream类：<br>常用方法：</p>
<blockquote>
<p>int read() 返回一个数据字节，如果以达到文件末尾，则返回-1<br>Int read(byte[] b) 将最多b.length个字节的数据读入一个byte数组中<br>int available() 返回流当中剩余的没有读到的字节数量<br>Long skip(long n) 跳过几个字节不读</p>
</blockquote>
<p>FileOutputStream类:文件字节输出流，从内存到硬盘<br>常见方法：</p>
<blockquote>
<p>FileOutputStream(“文件路径”)  先将原文件清空，再重新写入<br>FileOutputStream(“文件路径”,Boolean append) append为true时在文件末尾写入，不会清空文件。<br>FileReader类：文件字符输入流，只能输出普通文本，word文件不可以<br>FileWriter类：文件字符输出流，只能输出普通文本，word文件不可以</p>
</blockquote>
<p><em>缓冲流专属</em>：<br>BufferedReader类：自带缓冲区的字符输入流，不需要自定义char数组<br>节点流：当一个流的构造方法里传进一个流时，这个传进来的流就是节点流。<br>包装流：外部负责包装的流，就是包装流&#x2F;处理流<br>包装流只需关闭最外层流就行，里面的节点流会自动关闭<br>BufferedWeiter类：自带缓冲区的字符输出流<br><em>转换流</em>：<br>InputStreamReader类：转换流<br>OutputStreamWriterr类：转换流<br><em>数据流专属</em>：<br>DataOutputStream类：将数据连同数据类型一并写入文件。这个文件不是普通文本文件，读的顺序必须与写的顺序一致<br>DataInputStream类<br><em>标准输出流</em>：<br>PrintWreter类<br>PrintStrem类：标准的字节输出流，默认输出到控制台，不需要手动关闭流<br>设置输出方向：System.setOut(new PrintStream(new FileOutputStream(目标文件)))<br><em>对象专属流</em>：<br>ObjectOutputStream类：负责序列化<br>ObjectInputStream类：负责反序列化<br>(5)	序列：<br>序列化：Serialize Java对象存储到文件中，将Java对象的状态保存下来的过程。<br>反序列化：DeSerialize 将硬盘上的数据重新恢复到内存当中，恢复成Java对象<br>Transient关键字表示游离的，不参与序列化<br>注意：参与序列化与反序列化的对象，必须实现Serializable接口<br>Serializable接口：里面没有代码，其标识的作用，jvm在看到这个接口后，<br>会为该类自动生成一个序列化版本号（可用于区分类，建议手动生成）<br>(6)	IO+Properties的联合使用<br>设计理念：经常改变的数据，可以单独写到一个文件中，使用程序动态获取。<br>只需要修改文件的内容，Java代码不需要改变。<br>配置文件：以上机制的这种文件被称为配置文件<br>属性配置文件：当配置文件的内容格式为：key&#x3D;value时，称为属性配置文件<br>建立以.properties作为后缀名，但不是必须的<br>注：#是注释   key重复value自动覆盖<br>Properties：专门存放属性配置文件内容的一个类</p>
<h5 id="15、线程"><a href="#15、线程" class="headerlink" title="15、线程"></a>15、线程</h5><p>（1）	进程与线程<br>进程：是一个应用程序（一个进程是一个软件），一个进程可以启动多个线程<br>线程：是一个进程中的执行场景&#x2F;执行单元<br>（2）Java的线程：堆内存与方法区内存共享，但是栈内存独立，互不干扰，一个线程一个栈，这就是多线程并发（可以提高效率）<br>（3）实现线程：<br>(a)	第一种方式：编写一个类直接继承Thread，并重写run方法<br>步骤：创建线程对象：直接new<br>启动线程：调用线程对象的start方法，启动成功后分支线程会自动调用run方法，并且run方法在栈底部（run与main平级）<br>注：分支线程与主线程并发执行<br>Start方法的作用：启动一个分支线程，在jvm开辟一个新的栈空间<br>单线程：直接在主栈中调用线程对象的run方法的方式就叫单线程<br>(b)	第二种方式：编写一个类实现Runnable接口<br>步骤：<br>定义一个可运行的类（实现Runnable接口）<br>创建线程对象：new Thread(new 可运行类())<br>启动线程<br>上述两种方法的执行结果：主支线程有前有后，有多有少<br>(c)	线程的生命状态<br>新建状态、就绪状态、运行状态、阻塞状态、死亡状态<br>（4）常见方法：<br>设置线程名字：引用.setName()<br>获取线程名字：引用.getNmae()<br>静态方法：<br>获取当前线程对象的名字：Thread.currentThread()<br>睡眠：Thread.sleep(long millis)  参数是毫秒，作用：让当前线程进入休眠（进入阻塞状态），可用于间隔特定的时间，去执行一段特定的代码，每隔多久执行一次<br>终断线程睡眠：引用.interrupt();   干扰睡眠（依赖Java的异常处理机制）<br>在想要终止的线程里，设置一个Boolean变量与if…else来控制<br>线程的终止<br>（5）线程的调度<br>抢占式调度模型：哪个线程的优先级比较高，抢到的cpu时间片的概率就高一些。（Java采用这种方式）<br>均分式调度模型：平均分配cpu时间片，每个线程占有的cpu时间片一样有关方法：<br>实例方法：<br>void setPriority(int newPriority)   设置线程的优先级（最低1，默认5，最高10）<br>Int getPriority()  获取线程优先级<br>Void join()  合并线程，当前线程进入阻塞，调此方法的线程执行，等它结束，当前线程才可重新执行<br>静态方法：<br>static void yield()  让位方法，暂停当前正在执行的线程对象，回到就绪状态，并执行其他线程<br>（6）线程的安全：<br>a)	存在线程安全问题的条件：多线程并发、有共享数据、共享数据有修改行为<br>b）	解决线程安全问题：<br>方案一：尽量使用局部变量代替实例变量和静态变量<br>方案二：如果必须是实例变量，可以考虑创建多个对象，这样对象不共享了，就没有线程安全问题<br>方案三：以上两个方案都不能使用，再选择synchronized，线程<br>同步机制<br>线程排队执行，（不能并发）这种机制被称为：<br>线程同步机制（牺牲了一部分效率）<br>线程同步机制语法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>()&#123;</span><br><span class="line">    线程同步代码块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：<br>如果共享对象就是this，并且需要同步的代码块就是整个方法体可以让Synchronized出现在实例方法上来使用，这样代码简洁<br>执行原理：遇到synchronized后，线程会一个一个排队占有对象锁，占有对象锁的线程执行同步代码块，没占有的线程等候。<br>注：<br>()中填：需要同步的线程的共享对象，这个对象对于别的线程来说不是共享的。<br>Java的任何一个对象都有“一把锁(标记)”，一个对象一把锁</p>
<p>异步编程模型：线程各自执行各自的，这种编程模型叫  做：异步编程模型（其实就是多线程并发，效率较高）<br>同步编程模型：线程之间发生等待关系，这种就是同步编程模型（线程排队执行，效率较低）<br>注：局部变量永远不会有线程安全问题<br>死锁：很难调试，建议不要嵌套使用synchronized<br>（7）守护线程<br>线程的分类：用户线程、守护线程<br>方法：引用.setDaemon(true)   启动线程之前，将线程设置为守护线程，这样当用户线程结束后，守护线程也结束。<br>（8）定时器<br>作用：间隔特定的时间去执行特定的程序<br>Timer类<br>（9）实现线程的第三种方式：实现Collable接口（JDK新特性）<br>优点：可以获取到线程的执行结果<br>缺点；效率比较低，在等待获取另一个线程执行结果的时候，当前线程收到阻塞。<br>（10）wait方法与notify方法（object类中的，任何对象都有）<br>Wait方法：会让当前线程（正在object对象上活动的线程）进入等待状态，并且释放之前占有的object对象的锁<br>Notify方法：唤醒正在object对象上等待的线程<br>NotifyAll方法：唤醒object对象上处于等待的所有线程<br>注：两种方法必须建立在线程同步的基础上<br>（11）生产者与消费者模式<br>目的：为了专门解决某个特定需求的</p>
<h5 id="16、反射"><a href="#16、反射" class="headerlink" title="16、反射"></a>16、反射</h5><p>（1）反射机制：优点：反射机制可以操作字节码文件、使程序更加灵活<br>（2）位置：反射机制的相关类在Java.lang.reflect.*下<br>（3）相关的重要类：<br>Java.lang.Class  代表整个字节码(类)<br>Java.lang.reflect.Method  代表字节码中的方法字节码(方法)<br>Java.lang.reflect.Constructor  代表字节码中的构造方法字节码(构造方法)<br>Java.lang.reflect.Field  代表字节码中的属性字节码(成员变量)<br>（4）获取Class：Class.forName(“完整类名带有包名”)  静态方法<br>注意：如果你只希望一个类的静态代码块执行，其他代码一律不执行，可以使用此方法，这个方法的执行会导致类加载。<br>引用.getClass()  Java中任何一个对象都有此方法，获取引用的类型<br>任何类型.class  直接获取任意类型的字节码<br>（5）Class的newInstance()方法：实例化对象。<br>方法内部实际上调用了无参数构造方法，必须保证无参构造方法的存在才可以<br>（6）反射机制的灵活性：在不改变源代码的基础上，可以做到不同对象的实例化，代码不需要改动，可以修改配置文件，配置文件修改后，可以创建出不同的实例对象<br>（7）类加载器(ClassLoader)：专门负责加载类的命令&#x2F;工具<br>JDK自带三个类加载器：启动类加载器(专门加载rt.jar)  父扩展类加载器(专门加载ext)  母应用类加载器(classpath中的jar包)  子执行代码时，先将所需类全部加载到JVM中，然后通过在类加载器找对应代码文件，找到就加载，找不到就通过启动类加载器找，再找不到就在扩展类加载器找。（双亲委派机制：优先父，加载不到，就母，最后找不到，才轮到子）<br>（8）获取Field<br>获取类中所有public修饰的Field：引用.getFields()   返回一个数组<br>获取类中所有的Field：引用.getDeclaredFields()   返回一个数组<br>获取单个属性：对象引用.getDeclaredField(“属性名”)<br>反射机制调用属性：<br>给属性赋值：属性引用.set(对象)<br>获取属性值：属性引用.get(对象，值)<br>打破封装(可以访问私有变量)：属性引用.setAccessible(true)<br>获取类中所有属性的类型：引用.getType()   返回一个Class<br>获取类中所有的属性的修饰符列表：int i&#x3D;引用.getModifiers()   返回一个数字，每个数字是修饰符的代号<br>Modifier.toString(i)  将数字转换为字符串<br>获取类的简单类名：引用.getSimpleName()<br>（9）获取Method<br>可变长度参数：语法：类型… 名字<br>要求：<br>参数个数是0~N个<br>必须在参数列表中最后一个的位置上，且只能有一个<br>可以当成一个数组来看待<br>获取所有的Method(包括私有的)：引用.getDeclaredMethods()   返回一个数组<br>获取单个的Method：引用.getDeclaredMethod(“方法名”,参数列表)<br>反射机制调用方法（四要素：对象、方法、实参、返回值）：对象引用.invoke(对象,实参)<br>获取修饰符列表：Modifier.toString(引用.getModifiers())<br>获取方法的返回值类型：引用.getReturnType().getSimpleName()<br>获取方法名：引用.getName()<br>获取方法的参数列表：引用.getParameterTypes()  返回一个数组<br>（10）获取Constructor<br>获取所有构造方法：引用.getDeclaredConstructors()<br>获取单个构造方法：对象引用.getDeclaredConstructor(实参)<br>反射机制调用构造方法：Constructor引用.nwInstance(参数)<br>（11）获取类的父类：引用.getSuperclass()<br>获取类实现的接口：引用.getInterfaces()</p>
<h5 id="17、注解（Annotation）"><a href="#17、注解（Annotation）" class="headerlink" title="17、注解（Annotation）"></a>17、注解（Annotation）</h5><p>(1)	注解是一种引用数据类型，编译后生成xxx.class文件<br>注解可以出现在类、属性、方法、变量、注解上，默认下，可以在任意位置<br>(2)	自定义注解的语法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">一、定义</span><br><span class="line"> [修饰符列表] <span class="meta">@interface</span> 注解类型名&#123; </span><br><span class="line">    属性类型 名字();</span><br><span class="line">    属性类型[] 名字();</span><br><span class="line">&#125;</span><br><span class="line">二、 使用</span><br><span class="line"> <span class="meta">@interface</span> 注解类型名</span><br></pre></td></tr></table></figure>
<p>(3)	自定义注解：<br>若自定义注解{}里当中有属性，那么使用注解时必须给属性赋值</p>
<blockquote>
<p>@注解名(属性名&#x3D;属性值,数组属性名&#x3D;{ })    </p>
</blockquote>
<p>注：有默认值就不需要在括号再赋值了<br>当属性名为value时，属性名可以省略<br>当属性数组中只有一个元素时，大括号{}可以省略注解当中的属性可以为：8个基本数据类型、String、Class、枚举、以及以上每种类型的数组类型<br>(4)	元注解：用来标注注解类型的注解。<br>常见元注解：<br>Target注解（用来标注“被标注的注解”可以用在哪些位置）<br>Retention注解（用来标注“被标注的注解”最终保存在哪里）<br>(5)	JDK内置的注解(Java.lang下)：<br>Override注解：只能注解方法。给编译器参考的，与运行阶段无关。带有此注解，编译器会检查，如果这个方法不是重写父类的方法，编译器报错<br>Deprecated注解：表示被注解的程序元素已过时<br>(6)	反射机制判断类上是否有某注解：<br>对象引用.isAnnotationPresent(要判断的注解名.class)<br>获取类上注解：对象引用.getAnnotation(要获取的注解名.class)<br>获取注解上的属性：注解对象引用.属性名()<br>(7)	注解的作用：注解类似一种标记，可以用注解限制某些条件，如果不满足这些条件<br>就报抛出异常。</p>
<hr>
<p>😃END</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL入门</title>
    <url>/posts/c24675b4.html</url>
    <content><![CDATA[<h3 id="什么是数据库？"><a href="#什么是数据库？" class="headerlink" title="什么是数据库？"></a>什么是数据库？</h3><p>概念:<br>指长期存储在计算机内，有组织的、可共享的数据集合<br>构成：<br>数据库可以看成存储数据库对象的容器，MYSQL中，分为系统数据库和用户数据库两大类<br>数据模型:<br>层次模型、网状模型、关系模型(结构简单，常用)<br>数据模型三要素：<br>数据结构、数据操作、完整性约束条件<br>数据库类型：<br>层次模型数据库、网状模型数据库、关系模型数据库<br>数据库系统：<br>硬件、软件、数据库、用户<br>结构化查询语句SQL：<br>DDL、DML、DCL、事务处理语句</p>
<h3 id="关系结构"><a href="#关系结构" class="headerlink" title="关系结构"></a>关系结构</h3><p>关系结构的术语：<br>关系、元组(记录)、属性、域、候选码、主键(主码)、外键(与另一个表的关联)、全码、关系模式<br>关系表必须满足以下条件才能成为关系模式的一部分：<br>信息原则：每个单元只能存储一条数据<br>列唯一性名称：列下的数据必须具有相同数据类型，列没有顺序<br>行的数据唯一：行没有顺序<br>实体完整性：即主键不能为空<br>引用完整性：即外键不能为空</p>
<h3 id="DB、DBMS、SQL的关系"><a href="#DB、DBMS、SQL的关系" class="headerlink" title="DB、DBMS、SQL的关系"></a>DB、DBMS、SQL的关系</h3><p>DB：数据库   DBMS：数据库管理系统   SQL：结构化查询语言<br>DBMS负责执行SQL语句，通过执行SQL语句来操作DB当中的数据</p>
<h3 id="SQL的分类"><a href="#SQL的分类" class="headerlink" title="SQL的分类"></a>SQL的分类</h3><p>DQL（数据查询语言）：查询语句，凡是select语句都是DQL。<br>DML（数据操作语言）：insert 增 delete 删 update 改<br>DDL（数据定义语言）：create drop alter，对表结构的增删改<br>TCL（事务控制语言）：commit提交事务，rollback 回滚事务<br>DCL（数据控制语言）：grant授权，revoke撤销权限等·</p>
<h3 id="常用MySQL命令"><a href="#常用MySQL命令" class="headerlink" title="常用MySQL命令"></a>常用MySQL命令</h3><p>Select database(); 查看当前使用的是哪个数据库<br>Show variables like “%char%”;   查看mysql的本地安装路径<br>Select version();  查看MySQL的版本号<br>Show databases；  查看现有数据库<br>Show create table emp  查看创建表的语句<br>\C   结束一条语句<br>Exit  退出MySQL</p>
<h3 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h3><blockquote>
<p>创建数据库：create database 数据库名;<br>删除数据库：drop database 数据库名;<br>使用数据库：Use 数据库名;</p>
</blockquote>
<h3 id="数据表操作"><a href="#数据表操作" class="headerlink" title="数据表操作"></a>数据表操作</h3><ol>
<li>   操作</li>
</ol>
<blockquote>
<p>创建数据表：create table 数据表名(column_name column_type);<br>删除数据表：drop table 数据表名;<br>表查询：desc 表名;<br>表的复制：</p>
<blockquote>
<p>将查询结果当做表创建出来 ：语法：create table 表名 as select语句<br>将表2的查询结果插入到表1中 ：语法：insert into 表1 select*from 表2</p>
</blockquote>
</blockquote>
<ol start="2">
<li>   常见的数据类型：<br>int<br>bigint：长整型(对应Java中的long)<br>float<br>char：一般在数据长度不发生改变的时候使用  (对应Java中的String)<br>Char(5):指定长度为5个字符<br>varchar：可变长字符串，在数据长度不确定的时候使用(对应Java中的StringBuffer，最多255个)<br>date<br>BLOB  二进制大对象(对应Java中的Object，存储图片、视频等流媒体信息)<br>CLOB  字符大对象(存储较大文本，对应Java中的Object，可以存储4G的字符串)</li>
</ol>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><ol>
<li>操作</li>
</ol>
<blockquote>
<p>insert into 表名(字段名1,字段名2…) values(值1,值2…)<br>insert into 表名values(值1,值2…)  字段名可省，但值需要对应表<br>insert into 表名(字段名1,字段名2…) values(值1,值2…), (值1,值2…)… 一次插入多行数据</p>
</blockquote>
<p>注：<br>字段的数量和值的数量相同，并且数据类型要对应相同<br>当一条insert语句执行之后，表当中必定会多一行记录，后期不能再插入新数据，只能使用update进行更新</p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><ol>
<li>操作</li>
</ol>
<blockquote>
<p>delete from 表名 where 条件；（没条件全部删除）<br>删除大表的数据：truncate table 表名； 表被截断，不可回滚，永久丢失。</p>
</blockquote>
<h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><ol>
<li>操作</li>
</ol>
<blockquote>
<p>update 表名 set 字段名1&#x3D;值1,字段名2&#x3D;值2…where 条件；（没条件全部更新）</p>
</blockquote>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><ol>
<li>   简单查询</li>
</ol>
<blockquote>
<p>select 字段名1,字段名2,…from 表名</p>
</blockquote>
<p>重命名字段名：字段名后加as（可省略）名称（如果名称是字符串，得加单引号）</p>
<ol start="2">
<li>   条件查询</li>
</ol>
<blockquote>
<p>select 字段名1,字段名2,…from 表名 where 条件</p>
</blockquote>
<p>执行顺序：先from，然后where，再select<br>优先级：（）&gt; and &gt; or<br>注：In(值，值):相当于or</p>
<ol start="3">
<li>   模糊查询</li>
</ol>
<blockquote>
<p>select 字段名1,字段名2,…from 表名 Like ‘%查询的数据%’，支持%或下划线_匹配</p>
</blockquote>
<p>注：<br>数据库中null不是一个值，不能用等号，必须使用is null或is not bull只要有Null参与了运算，最后得出得结果一定为null<br>CRUD操作：增删改查的术语，Create、Retrieve、Update、Delete</p>
<ol start="4">
<li>   连续查询<br>(一)	分类：<br>根据语法出现的年代来划分：SQL92、SQL99（比较新）<br>根据表的连接方式来划分：<br>内连接：等值连接、非等值连接、自连接<br>等值连接：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select 表1.字段，表2.字段 </span><br><span class="line">from 表1 </span><br><span class="line">inner(可省) join表2 </span><br><span class="line">on 表1.字段 = 表2.字段</span><br><span class="line">			非等值连接：</span><br><span class="line">select 表1.字段，表2.字段 </span><br><span class="line">from 表1 </span><br><span class="line">inner(可省) join表2 </span><br><span class="line">on 连接条件</span><br></pre></td></tr></table></figure>
自连接<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select a.表名，b.表名</span><br><span class="line">from 表名 a </span><br><span class="line">inner(可省) join表名 b </span><br><span class="line">on 连接条件</span><br></pre></td></tr></table></figure>
外连接：左外连接（左连接,左表为主表）、右外连接（右连接，右表为主表）<br>左外连接：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select a.表名，b.表名</span><br><span class="line">from 表名 a </span><br><span class="line">left outer(可省) join表名 b   a 为主表</span><br><span class="line">on 连接条件</span><br></pre></td></tr></table></figure>
右外连接：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select a.表名，b.表名</span><br><span class="line">from 表名 b </span><br><span class="line">right outer(可省) join表名 a   b 为主表</span><br><span class="line">on 连接条件</span><br></pre></td></tr></table></figure>
内连接与外连接的区别：内连接表之间平等，外连接有主副之分<br>全连接<br>(二)笛卡尔积现象：当两张表进行连接查询的时候，没有任何条件进行限制，最终的查<br>询结果条数是两张表记录条数的乘积。<br>(三)多表查询：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select 表1.字段，表2.字段 ，…</span><br><span class="line">from 表1 </span><br><span class="line">join表2 </span><br><span class="line">on 连接条件</span><br><span class="line">join表3 </span><br><span class="line">on 连接条件</span><br><span class="line">left join表4      表1与表4进行连接，表1为主表</span><br><span class="line">on 连接条件</span><br></pre></td></tr></table></figure>
(四)子查询：select语句当中嵌套select语句，被嵌套的select语句是子查询<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Select</span><br><span class="line">…(select语句)</span><br><span class="line">from </span><br><span class="line">…(select语句)      select语句的查询结果当成一张临时表</span><br><span class="line">Where</span><br><span class="line">…(select语句) </span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><blockquote>
<p>select 字段名1,字段名2,…from 表名 order by 要排序的字段名</p>
</blockquote>
<p>默认是升序，字段名后加asc是升序，字段名后加desc是降序</p>
<h3 id="分组函数（多行处理函数）"><a href="#分组函数（多行处理函数）" class="headerlink" title="分组函数（多行处理函数）"></a>分组函数（多行处理函数）</h3><p>a)	5个函数：count 计数、sum求和、avg 平均值、max、min<br>b)	语法：select 函数名(目标字段名) from 表名<br>c)	特点：输入多行，最终输出一行。自动忽略null。分组函数不能直接使用于where后面<br>d)	单行处理函数：特点:输入一行，输出一行<br>e)	空处理函数：Ifnull(可能为null的数据，做什么处理) 属于单行处理函数<br>f)	Count（*）：统计总记录条数，null会计入总数  Count（某字段）：统计不为null的数据总数量<br>g)	Group by 和having<br>Group by：按照某个字段或某些字段进行分组。<br>Having：对分组后的数据进行再次过滤。<br>分组函数一般都会和group by联合使用，并且分组函数在group by 语句执行结束之后才会执行，而group by 是在where执行后才执行。</p>
<h3 id="去除重复记录"><a href="#去除重复记录" class="headerlink" title="去除重复记录"></a>去除重复记录</h3><p>Distinct关键字去除重复记录<br>特点：distinct只能出现在所有字段的前面，表示所有字段联合去重</p>
<h3 id="Union"><a href="#Union" class="headerlink" title="Union"></a>Union</h3><p>可以将查询结果集相加（表之间的列数要一致）</p>
<h3 id="Limit（MySQL特有，常用于分页查询）"><a href="#Limit（MySQL特有，常用于分页查询）" class="headerlink" title="Limit（MySQL特有，常用于分页查询）"></a>Limit（MySQL特有，常用于分页查询）</h3><p>语法:limit starIndex , length  starIndex 表示起始位置（从0开始）length 表示取几个<br>分页查询：<br>每页显示pageSize条记录：第pageNo页：（pageNo-1）*pageSize，pageSize</p>
<h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><p>添加约束的目的：<br>为了保证表中数据的合法性、有效性、完整性<br>常见的约束：<br>非空约束（not null）约束的字段不能为null<br>唯一约束（unique）约束的字段不能重复，但可以有存在多个null<br>主键约束（primary key，简称PK）约束的字段既不能为null，也不能重复，一张表的主键约束只能有一个外键约束（foreign key，简称FK）外键可以为null，被引用的字段不一定是主键，但必须具有唯一性（既具有unique约束）<br>检查约束（check）：Oracle数据库有check约束，但MySQL没有。</p>
<p>非空约束：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table 表名(</span><br><span class="line">	字段名1 数据类型not null,	（列级约束）</span><br><span class="line">    字段名2 数据类型，</span><br><span class="line">….</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>唯一约束（unique）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table 表名(</span><br><span class="line">	字段名1 数据类型 unique， 字段名1唯一不可重复（列级约束）</span><br><span class="line">    字段名2 数据类型，</span><br><span class="line">….</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table 表名(</span><br><span class="line">	字段名1 数据类型，</span><br><span class="line">字段名2 数据类型，</span><br><span class="line">Unique(字段名1,字段名2…) 多字段联合起来唯一不可重复（表级约束）</span><br><span class="line">….</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>主键约束（primary key）:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table 表名(</span><br><span class="line">	字段名1 数据类型primary key,		（列级约束）</span><br><span class="line">字段名2 数据类型，</span><br><span class="line">….</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table 表名(</span><br><span class="line">	字段名1 数据类型，</span><br><span class="line">字段名2 数据类型，</span><br><span class="line">primary key(字段名1)       （表级约束）</span><br><span class="line">….</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>(一)主键的相关术语：<br>主键字段：被主键约束后的字段叫主键字段<br>主键值：主键字段中的每一个值都是主键值<br>(二)主键的作用：主键值是这行记录在表中的唯一标识<br>(三)主键的分类：<br>根据主键字段的字段数量来划分：单一主键（常用）、复合主键（不常用，违背三范式）<br>根据主键性质来划分：自然主键（常用）、业务主键：主键值与业务挂钩（不常用）<br>(四)主键值自增（MySQL特有）：字段自动维护（生成）一个自增的数字，从1开始，以1递增</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table 表名(</span><br><span class="line">	字段名1 数据类型 primary key atuo_increment, </span><br><span class="line">字段名2 数据类型，</span><br><span class="line">….</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>注：Oracle的自增机制，叫做序列（sequence）<br>外键约束（foreign key）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table 父表(</span><br><span class="line">	字段名1 数据类型，</span><br><span class="line">字段名2 数据类型，</span><br><span class="line">primary key(字段名1)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table 子表(</span><br><span class="line">	字段名1 数据类型，</span><br><span class="line">字段名2 数据类型，</span><br><span class="line">Foreign key(子表的字段名) references 父表(父表的字段名1)</span><br><span class="line">References：表示引用  </span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>(一)外键的相关术语：<br>外键字段：添加有外键约束的字段<br>外键值：外键字段中的每一个外键值<br>(二)顺序要求：<br>删除数据与表时：先子表，再父表<br>添加数据和创建表时：先父表，后子表<br>子表与父表：表1引用了表2中的某字段，此时表1为子表，表2为父表</p>
<h3 id="存储引擎（MySQL特有）"><a href="#存储引擎（MySQL特有）" class="headerlink" title="存储引擎（MySQL特有）"></a>存储引擎（MySQL特有）</h3><p>（一）完整的建表语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table 表名(</span><br><span class="line">			字段名1 数据类型，</span><br><span class="line">字段名2 数据类型，</span><br><span class="line">….</span><br><span class="line">)engine=InnoDB default charsef=utf8;</span><br></pre></td></tr></table></figure>
<p>（二）存储引擎：<br>MySQL支持多个存储引擎，每一种存储引擎都对应一种存储方式<br>（三）查看当前MySQL支持的存储引擎：show engines \G<br>（四）常见的存储引擎：<br>MyISAM存储引擎：不支持事务<br>特征：<br>1.使用三个文件来表示每个表<br>（mytable.frm存储表结构的定义、mytable.MYD存储表行的内容、mytable.MYI存储表上的索引）<br>2.灵活的表自增字段处理<br>3.可被转换为压缩，只读表来节省空间<br>InnoDB存储引擎：支持事务，行级锁，外键等，安全性高，建表时默认采用。<br>特征：<br>1.表的结构存储在mytable.frm文件中，数据存储在table space（逻辑概念）中，无法被压缩，无法被切换成只读<br>2.数据库崩溃后提供自动恢复机制<br>3.支持级联删除和级联更新<br>MEMORY存储引擎：不支持事务，查询速度最快，因为所有数<br>据以及索引存储在内存中。</p>
<h3 id="事务-Transaction"><a href="#事务-Transaction" class="headerlink" title="事务(Transaction)"></a>事务(Transaction)</h3><p>1.概念：<br>一个事务是一个完整的业务逻辑单元，不可再分，事务通常需要多条DML语句共同完成，确保多条DML语句同时成功，或同时失败。<br>注：事务保证数据的完整性，安全性。与事务相关的语句只有DML语句<br>2.事务包括四大特性：ACID<br>A：原子性，事务是最小的工作单元，不可再分。<br>C：一致性，事务必须保证多条DML语句同时成功或者同时失败。<br>I：隔离性，事务A与事务B之间具有隔离<br>D：持久性，最终必须持久化到硬盘文件中，事务才算成功的结束。<br>事务之间的隔离性：<br>a)4个隔离级别：<br>第一级别：<br>读未提交（read uncommitted）<br>对方事务未提交，我方当前事务就可以读取到数据<br>存在脏读（dirty read）现象<br>第二级别：<br>读已提交（read committed）<br>对方事务提交之后，我方事务才可以读取到数据<br>存在不可重复读问题，解决脏读问题<br>第三级别：<br>可重复读（repeatable read）<br>我方事务只可以重复读取到对方开始事务时数据<br>存在读取的数据是幻象问题，解决不可重复读问题<br>第四级别：<br>序列化读&#x2F;串行化读<br>解决了所有问题，但效率低，需要事务排队<br>b)	设置事务的全局隔离级别：<br>Set global transaction isolation level 隔离级别(例,read uncommitted);<br>查看事务的全局隔离级别：Select @@global.tx_isolation;<br>c)	Oracle默认隔离级别：第二级别<br>MySQL默认隔离级别：第三级别<br>3.MySQL的事务是自动提交的：只要执行一条DML，则提交一次<br>可使用start transaction；关闭自动提交机制<br>commit提交事务，rollback 回滚事务</p>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>1.概念：<br>索引就相当于目录，通过目录可以快速的找到对应的数据<br>注：添加索引是给某一个字段或者某些字段添加索引<br>2.数据库检索：<br>有两种方式：全表扫描、根据索引检查(效率很高，根本原因是缩小了扫描范围)<br>3.创建索引对象：create index 索引名称 on 表名(字段名);<br>4.删除索引对象：drop index 索引名称 on 表名;<br>5.添加索引的条件：数据量庞大。（根据客户需求和线上环境而定）<br>该字段很少的DML操作。（因为字段修改时，索引也需要维护，可能导致效率低，维护成本过高等问题）该字段经常出现在where子句中<br>6.查看sql语句的执行计划：<br>explain select语句<br>注：主键和unique约束的字段自动会添加索引。根据主键查询效率较高，尽量使用主键检索<br>7.索引的实现原理：<br>通过B Tree缩小扫描范围，底层索引进行了排序，分区，索引携带数据在表中的“物理地址“，最终通过索引检索到数据之后，获取到关联的物理地址，再通过物理地址定位表中的数据，效率是最高的。<br>注：物理地址：表的每一行在硬盘中真实存在的内存地址<br>检索到匹配的数据后，select … where 条件 会通过索引转换为：<br>select … where物理地址&#x3D;数据的物理地址<br>索引的底层采用的数据结构是：B+Tree<br>8.索引的分类：<br>单一索引：给单个字段添加索引<br>复合索引：给多个字段联合起来添加1个索引<br>主键索引：主键上自动添加索引<br>唯一索引：有unique约束的字段会自动添加索引<br>9.索引的失效：<br>当Where后的使用模糊查询‘%A%’等，索引无法分区时，索引失效</p>
<h3 id="视图（view）"><a href="#视图（view）" class="headerlink" title="视图（view）"></a>视图（view）</h3><p>1.概念：站在不同的角度去看数据<br>2.创建视图：Create view 视图名 as sql语句;<br>注：只能DQL语句才能创建视图<br>3.删除视图：Drop view 视图名<br>4.视图的作用：<br>视图可以隐藏表的数据细节。保密级别较高的系统，要外包或者交互时，可使用视图，这样，程序员只能对视图对象进行CRUD。</p>
<h3 id="DBA命令"><a href="#DBA命令" class="headerlink" title="DBA命令"></a>DBA命令</h3><p>导出整个数据库（dos命令窗口中执行）：<br>Mysqldump 数据库文件&gt;数据库文件路径 -u用户名 -p密码<br>导出指定数据库当中的指定表：<br>Mysqldump 数据库文件 表名&gt;数据库文件路径 -u用户名 -p密码<br>导入数据：<br>create database 数据库文件；<br>use 数据库文件;<br>source 数据库文件路径;</p>
<h3 id="设计三范式"><a href="#设计三范式" class="headerlink" title="设计三范式"></a>设计三范式</h3><p>1.概念：<br>设计表的依据。按照三范式设计的表不会出现数据冗余。<br>2.分类：<br>第一范式：任何一张表都应该有主键，并且每一个字段原子性不可再分。<br>第二范式：建立在第一范式的基础上，所有非主键字段完全依赖主键，不能产生部份依赖。<br>口诀：多对多，三张表，关系表两外键。<br>第三范式：建立在第二范式的基础上，所有非主键字段直接依赖主键，不能产生传递依赖。<br>口诀：一对多，两张表，多的表加外键。<br>注：在实际开发中，以满足客户需求为主，有的时候会拿冗余换执行速度。</p>
<hr>
<p>😂END</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaEE</title>
    <url>/posts/9daba997.html</url>
    <content><![CDATA[<h3 id="类："><a href="#类：" class="headerlink" title="类："></a>类：</h3><p>​	类中有且仅有五大成分：成员变量、成员方法、构造器、代码块、内部类<br>​	创建对象时：new的是构造器</p>
<h3 id="this"><a href="#this" class="headerlink" title="this:"></a>this:</h3><p>​	作用：<br>​			this代表当前对象的引用<br>​			this可以用在实例方法和构造器中</p>
<h3 id="封装："><a href="#封装：" class="headerlink" title="封装："></a>封装：</h3><p>​	作用：为了安全，可以实现代码的组件化<br>​	核心思想：合理隐藏，合理暴露</p>
<h3 id="static"><a href="#static" class="headerlink" title="static:"></a>static:</h3><p>​	注意：在同一个类中访问静态成员可以省略类名不写<br>​		静态方法不可以直接访问实例变量&#x2F;方法</p>
<h3 id="继承："><a href="#继承：" class="headerlink" title="继承："></a>继承：</h3><p>​	作用：可以提高代码的复用<br>​	特点：<br>​			单继承：一个类只能继承一个直接父类，可以多层继承<br>​					为什么？因为会出现二义性。当被继承的两个父类有同名方法时，无法确定调用的是哪一个<br>​	继承后的构造器：<br>​			子类的构造器的第一行默认有一个 super() 调用了父类的无参数构造器，用于初始化父类信息<br>​			可以在子类构造器长通过super(形参)指定调用父类的某个构造器（必须在第一行）<br>​	注意：<br>​			子类不能继承父类的构造器<br>​			子类能继承父类的私有成员（但是不能直接访问）<br>​			子类不能继承父类的静态成员（但是可以访问）<br>​			this(参数)与super(参数)必须放在构造器的第一行，否则报错</p>
<h3 id="重写："><a href="#重写：" class="headerlink" title="重写："></a>重写：</h3><p>​	方法重写的校验注解：@Override   加上这个注解就必须是重写父类的方法，否则报错<br>​	注意：<br>​			子类不能重写父类的私有成员<br>​			子类不能重写父类的静态成员</p>
<h3 id="抽象类：abstract"><a href="#抽象类：abstract" class="headerlink" title="抽象类：abstract"></a>抽象类：abstract</h3><p>​	特征：<br>​			抽象类虽然有构造器但是不能创建对象<br>​	存在的意义：<br>​			抽象类就是为了被子类继承<br>​			抽象类体现的是模板思想：部分实现，部分抽象<br>​	注意：<br>​			拥有抽象方法必须定义成抽象类<br>​			抽象方法没有方法体，只有方法签名<br>​			抽象类除了抽象方法，也可以具备其他类能具有的成分<br>​			抽象类一定有构造器，以供子类创建对象时，初始化父类成员使用<br>​			抽象类不一定包含抽象方法<br>​			抽象类的子类必须重写父抽象类的所有抽象方法</p>
<h3 id="接口："><a href="#接口：" class="headerlink" title="接口："></a>接口：</h3><p>​		常量的标准定义：public static final 类型 名称&#x3D;值<br>​		注意：<br>​			接口中的抽象方法可以省略public abstract，默认会加上<br>​			接口中的抽象方法可以省略public static final，默认会加上<br>​			java1.8之前接口中只能是抽象方法和常量。1.8之后新增了默认方法(用default修饰)，静态方法，私有方法<br>​			默认方法相当于实例方法，只能用接口的实现类的对象来调用<br>​			接口的静态方法只能用接口名来调用<br>​			接口的私有方法其实是JDK1.9开始支持<br>​			接口可以多实现（逗号隔开）<br>​			接口与接口可以多继承<br>​			一个类既继承一个父类，又实现若干个接口时，父类的成员方法与接口的默认方法崇明，子类会执行父类的成员方法。<br>​			接口没有构造器，不能创建对象</p>
<h3 id="代码块："><a href="#代码块：" class="headerlink" title="代码块："></a>代码块：</h3><p>​		静态代码块：</p>
<p>​			触发一次，与类一起优先加载</p>
<p>​			可以用于执行静态资源的初始化操作</p>
<p>​		实例代码块：（很少用）</p>
<p>​			创建对象时执行一次</p>
<h3 id="final"><a href="#final" class="headerlink" title="final:"></a>final:</h3><p>​		final修饰类：类不能被继承了</p>
<p>​		final修饰方法：方法不能被重写了</p>
<p>​		final修饰变量：变量只能被赋值一次（起保护作用，防止值被修改）</p>
<p>​				final修饰静态变量：变量就变成常量了</p>
<p>​		注意：</p>
<p>​			abstract与final是互斥关系，不能同时出现修饰成员</p>
<h3 id="枚举类："><a href="#枚举类：" class="headerlink" title="枚举类："></a>枚举类：</h3><p>​		作用：枚举类用于做信息标志和信息分类</p>
<p>​		注意：枚举类是多例设计模式</p>
<h3 id="多态："><a href="#多态：" class="headerlink" title="多态："></a>多态：</h3><p>​		形式：</p>
<p>​				父类类型 对象名称&#x3D;new 子类构造器;</p>
<p>​				接口 对象名称&#x3D;new 实现类构造器;</p>
<p>​		概念：同一类型的对象，执行同一行为，在不同的状态下会表现出不同的行为特征</p>
<p>​		多态的识别：</p>
<p>​				对方法的调用：编译看左边，运行看右边</p>
<p>​				对变量的调用：编译看左边，运行看左边</p>
<p>​		使用前提：</p>
<p>​				必须存在继承或实现关系</p>
<p>​				必须存在父类类型的变量引用子类类型的对象</p>
<p>​				需要存在方法的重写</p>
<p>​		优势：</p>
<p>​				右边对象可以实现组件化切换，以便于扩展和维护，可以实现类与类之间的解耦</p>
<p>​				父类类型作为方法形式参数，传递子类对象给方法</p>
<p>​		劣势：</p>
<p>​				多态形式下，不能直接调用子类特有的功能</p>
<p>​		类型判断： 变量 instanceof 类型     判断前面的变量是否是后面的类型，是则返回true</p>
<h3 id="内部类："><a href="#内部类：" class="headerlink" title="内部类："></a>内部类：</h3><p>​		作用：可以提供更好的封装性，内部类有更多权限修饰符，封装性有更多的控制</p>
<p>​		分类：</p>
<p>​				静态内部类：创建对象：外部类.内部类 对象名称&#x3D;new 外部类.内部类构造器</p>
<p>​				实例内部类：创建对象：外部类.内部类 对象名称&#x3D;new 外部类构造器.new 内部类构造器</p>
<p>​						注意：不能在实例内部类中定义静态成员，但可以定义常量</p>
<p>​				局部内部类</p>
<p>​				匿名内部类：</p>
<p>​						格式：new 类名|抽象类|接口(形参){方法重写}</p>
<h3 id="权限修饰符："><a href="#权限修饰符：" class="headerlink" title="权限修饰符："></a>权限修饰符：</h3><p>​		private只能在本类中访问</p>
<p>​		缺省只能在本包或本类中访问</p>
<p>​		protected只能在本类，本包以及其他包的子类中访问</p>
<p>​		public可以在任何地方访问</p>
<h3 id="Objects类："><a href="#Objects类：" class="headerlink" title="Objects类："></a>Objects类：</h3><p>​		Object类的子类，JDK1.7开始之后才有</p>
<p>​		两个方法：equals()  比较两个对象（不会出现空指针异常）</p>
<p>​							isNull() 判断是否为null</p>
<h3 id="Date类："><a href="#Date类：" class="headerlink" title="Date类："></a>Date类：</h3><p>​		构造器：Date()       Date(long time)</p>
<p>​		方法：getTime() 获取当前时间戳</p>
<p>​	SimpleDateFormat类：</p>
<p>​			.format() 用来格式化日期对象&#x2F;时间戳</p>
<p>​			.parse() 格式化字符串</p>
<p>​	Calender抽象类：可以快速的计算多少天后的日期</p>
<h3 id="Math类："><a href="#Math类：" class="headerlink" title="Math类："></a>Math类：</h3><p>​		绝对值：Math.abs()   向上取整：Math.ceil()   向下取整：Math.floor()</p>
<p>​		求指数次方：Math.pow()   四舍五入：Math.round()</p>
<h3 id="System系统类："><a href="#System系统类：" class="headerlink" title="System系统类："></a>System系统类：</h3><p>​		终止当前虚拟机：System.exit(0)</p>
<h3 id="BigDicimal类：解决浮点型精度问题"><a href="#BigDicimal类：解决浮点型精度问题" class="headerlink" title="BigDicimal类：解决浮点型精度问题"></a>BigDicimal类：解决浮点型精度问题</h3><p>​		BigDicimal.valueOf()  包装浮点数为大数据对象</p>
<p>​		.doubleValue()  把BigDicimal转换成double类型</p>
<h3 id="包装类："><a href="#包装类：" class="headerlink" title="包装类："></a>包装类：</h3><p>​		自动装箱：基本类型的值或变量赋值给包装类</p>
<p>​		自动拆箱：包装类的值或变量赋值基本类型</p>
<p>​		注意：也可以手动装箱，手动拆箱</p>
<p>​		特殊功能：把字符串类型的数值转换成对应的基本数据类型</p>
<p>​				Integer.parseInt()       Integer.valueOf()</p>
<h3 id="正则表达式：Regex"><a href="#正则表达式：Regex" class="headerlink" title="正则表达式：Regex"></a>正则表达式：Regex</h3><p>​		用于校验：”str”.matches(“校验规则”)</p>
<p>​		用于分割：”str”.split(“校验规则”)   按校验规则进行分割</p>
<p>​		用于替换：”str”.replaceAll(“校验规则”,”替换内容”)   将校验规则所对应的字符替换掉</p>
<p>​		用于爬取内容信息：</p>
<p>​				String rs&#x3D;”爬取内容”</p>
<p>​				1.定义爬取规则：String regex&#x3D;””</p>
<p>​				2.编译正则表达式成为匹配对象 Pattern pattern &#x3D;Pattern.compile(regex)</p>
<p>​				3.通过匹配规则对象得到一个匹配数据内容的匹配器对象：</p>
<p>​						Matcher matcher&#x3D;pattern.matcher(rs)</p>
<p>​				4.通过匹配器取出信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">​						<span class="keyword">while</span>(matcher.find())&#123;</span><br><span class="line"></span><br><span class="line">​							System.out.println(matcher.group())</span><br><span class="line"></span><br><span class="line">​						&#125;</span><br></pre></td></tr></table></figure>

<h3 id="泛型："><a href="#泛型：" class="headerlink" title="泛型："></a>泛型：</h3><p>​		作用：在编译阶段约束只能操作指定数据类型</p>
<p>​		自定义：自定义泛型类，自定义泛型方法，自定义泛型接口</p>
<p>​		泛型通配符：</p>
<p>​					？在使用泛型时代表一切类型</p>
<p>​					E,T,K,V是在定义泛型时代表一切类型</p>
<p>​		泛型的上下限：</p>
<p>​					？extends 类 ：说明？必须是此类或者其子类</p>
<p>​					？supper 类 ：说明？必须是此类或者其父类</p>
<p>​		注意：</p>
<p>​				泛型和集合都只支持引用数据类型，不支持基本数据类型</p>
<p>​				泛型没有继承关系</p>
<h3 id="Collection集合："><a href="#Collection集合：" class="headerlink" title="Collection集合："></a>Collection集合：</h3><p>​		体系：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">				   Collection&lt;E&gt;</span><br><span class="line">			/	      		        \</span><br><span class="line">		Set&lt;E&gt;				        List&lt;E&gt;</span><br><span class="line">	/	  \			/             \             \</span><br><span class="line">HashSet&lt;E&gt;	TreeSet&lt;E&gt;		ArrayList&lt;E&gt;  LinkedList&lt;E&gt;  Vector</span><br><span class="line">	/</span><br><span class="line">LinkedHashSet&lt;&gt;</span><br></pre></td></tr></table></figure>

<p>​		Set集合：无序，不重复，无索引</p>
<p>​				– HashSet：无序，不重复，无索引</p>
<p>​						– LinkedHashSet：有序，不重复，无索引</p>
<p>​				– TreeSet：升序排序，不重复，无索引</p>
<p>​		List集合：有序，可重复，有索引</p>
<p>​				– ArrayList：有序，可重复，有索引</p>
<p>​				– LinkedList：有序，可重复，有索引  （可以实现队列与栈）</p>
<p>​				– Vector：线程安全，速度慢</p>
<h3 id="Set："><a href="#Set：" class="headerlink" title="Set："></a>Set：</h3><p>​		怎么判断是否重复？<br>​				让两个对象调用自己的hashCode()方法得到彼此的哈希值进行比较，若不同则不重复，若相同，则继续<br>​				让两个对象进行equals比较内容是否相同，相同则重复<br>​		无序的根本原因：<br>​				因为底层采用了哈希表存储元素</p>
<h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet:"></a>TreeSet:</h3><p>​		对于自定义的引用数据类型：TreeSet默认无法排序</p>
<p>​				解决方案1：实现Comparable类，并重写比较方法compareTo</p>
<p>​				解决方案2：直接为集合设置比较器Comparator对象，重写比较方法</p>
<h3 id="Collections工具类："><a href="#Collections工具类：" class="headerlink" title="Collections工具类："></a>Collections工具类：</h3><p>​		方法：</p>
<p>​				.addAll(被添加元素的集合,可变参数)   </p>
<p>​				.shuffle(要打乱顺序的集合)</p>
<p>​				.sort(要排序的集合)</p>
<h3 id="可变参数："><a href="#可变参数：" class="headerlink" title="可变参数："></a>可变参数：</h3><p>​		作用：可以在形参中接受任意个，可变参数在方法内部本质上就是一个数组</p>
<p>​		格式：类型… name</p>
<p>​		注意：</p>
<p>​				一个形参列表中可变参数只能有一个</p>
<p>​				可变参数必须在形参列表的最后面</p>
<h3 id="遍历："><a href="#遍历：" class="headerlink" title="遍历："></a>遍历：</h3><h4 id="for循环：只适用于有索引的集合"><a href="#for循环：只适用于有索引的集合" class="headerlink" title="for循环：只适用于有索引的集合"></a>for循环：只适用于有索引的集合</h4><h4 id="迭代器："><a href="#迭代器：" class="headerlink" title="迭代器："></a>迭代器：</h4><p>​		创建迭代器对象：集合名称.Iterator()</p>
<p>​		方法：.next()     .hasNext()</p>
<h4 id="foreach"><a href="#foreach" class="headerlink" title="foreach:"></a>foreach:</h4><p>​		格式：for(元素类型 name：集合名称){}</p>
<h4 id="Lamda表达式：（JDK1-8）"><a href="#Lamda表达式：（JDK1-8）" class="headerlink" title="Lamda表达式：（JDK1.8）"></a>Lamda表达式：（JDK1.8）</h4><p>​		格式：集合名称.forEach(s-&gt;{  System.out.println(s);}  )</p>
<p>​				简化：集合名称.forEach(  s-&gt;System.out.println(s)  )</p>
<p>​				再简化：集合名称.forEach(  System.out :: println  )</p>
<h3 id="Map集合："><a href="#Map集合：" class="headerlink" title="Map集合："></a>Map集合：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">		Map&lt;K,V&gt;</span><br><span class="line">	/             \</span><br><span class="line">TreeMap&lt;K,V&gt;      HashMap&lt;K,V&gt;</span><br><span class="line">			\</span><br><span class="line">					LinkedHashMap&lt;K,V&gt;</span><br></pre></td></tr></table></figure>

<p>​		Map：键是无序，不重复，无索引</p>
<p>​				–TreeMap：升序排序，不重复，无索引</p>
<p>​				–HashMap：无序，不重复，无索引</p>
<p>​				–LinkedHashMap：有序，不重复，无索引</p>
<p>​		注意：</p>
<p>​				HashSet集合底层是基于HashMap的</p>
<p>​				TreeSet集合底层是基于TreeMap的</p>
<p>​				浮点型的大小比较：Double.compare(one,two);</p>
<p>​		遍历：</p>
<p>​					“键找值遍历”：先获取Map集合全部的键，再根据键找值</p>
<p>​					“键值对遍历”：.entrySet()将Map集合转Set集合，再遍历</p>
<p>​						获取map集合的元素实体类型：Set&lt;Map.Entry&lt;K,V&gt;&gt; entries&#x3D;maps.entrySet();</p>
<p>​					lamada：</p>
<p>​							maps.foreach({  (k,v) -&gt; {}  })</p>
<h3 id="异常："><a href="#异常：" class="headerlink" title="异常："></a>异常：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	Throwable</span><br><span class="line">	/		\</span><br><span class="line">Error			Exception</span><br><span class="line">				/        \</span><br><span class="line">			编译时异常	 RuntimeException</span><br></pre></td></tr></table></figure>

<p>​		Error：无法处理的错误，系统级错误</p>
<p>​		常见运行时异常：</p>
<p>​				数组索引越界异常</p>
<p>​				空指针异常</p>
<p>​				类型转换异常</p>
<p>​				数学操作异常</p>
<p>​				数字转换异常</p>
<p>​		异常的产生默认的处理过程：</p>
<p>​				1.在出现异常的代码那里自动创建一个异常对象</p>
<p>​				2.异常会从方法，抛给调用者，最终再抛给JVM</p>
<p>​				3.JVM接受到异常对象后，在控制台输出异常栈信息，并结束程序</p>
<p>​		异常处理：最佳处理方案：将异常抛出到最外层，再在最外层用try进行异常处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">​				<span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">​				&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line"></span><br><span class="line">​					e.printStackTrace()</span><br><span class="line"></span><br><span class="line">​				&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"></span><br><span class="line">​				&#125;</span><br></pre></td></tr></table></figure>
<p>​				注意：不建议在finally中写return，因为会覆盖前面所有的return值；</p>
<p>​		抛出异常：</p>
<p>​				throws：用在方法上</p>
<p>​				throw：用在方法体，创建异常类并抛出</p>
<h3 id="多线程："><a href="#多线程：" class="headerlink" title="多线程："></a>多线程：</h3><p>​		进程：</p>
<p>​			特征：动态性，独立性，开发性</p>
<p>​		线程：线程属于进程，一个进程可以有多个线程</p>
<p>​			Thread类的API：</p>
<p>​					设置线程名称：引用.setName()     </p>
<p>​							可以通过创建有参构造器为线程起名字，调用Thread类里的有参构造器</p>
<p>​					获取线程名称：引用.getName()     </p>
<p>​							获取当前所在线程的名称：Thread.currentThread()</p>
<p>​					让当前线程休眠：Thread.sleep()</p>
<p>​					等待线程执行完：引用.join()</p>
<p>​			创建线程：</p>
<p>​					1.定义线程类，继承Thread类，并重写run()    启动：引用.start()</p>
<p>​					2.定义线程任务类，实现Runnable接口，并重写run()，再把线程任务对象包装成线程对象</p>
<p>​							优点：可以继承其他类，用一个线程任务对象可以被包装成多个线程对象</p>
<p>​										适合多个线程去共享同一个资源</p>
<p>​					3.定义线程任务类，实现Callable接口，并重写call()，再把线程任务对象包装成未来任务对象，再把未</p>
<p>​					   来任务对象包装为线程对象</p>
<p>​							优点：具有实现Runnable接口的所有优点，此外，还能直接得到线程执行的结果  .get()</p>
<p>​			线程安全问题：多个线程同时操作同一个共享资源时可能会存在线程安全</p>
<p>​			线程同步：为了解决线程安全</p>
<p>​					三种方式：</p>
<p>​						同步代码块：synchronized(唯一锁对象){共享资源代码}</p>
<p>​								实例方法可以用this作为锁对象，静态方法可以用类名.class作为锁对象</p>
<p>​						同步方法：在方法上加上synchronized关键字</p>
<p>​						lock显示锁(同步锁)：java.util.concurrent.locks.Lock</p>
<p>​								创建同步锁：private final Lock lock&#x3D;new ReentrantLock();</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">lock.lock();<span class="comment">//加锁</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">       共享资源代码</span><br><span class="line">   &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">   &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">       lock.unlock();<span class="comment">//解锁</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>​				线程通信： </p>
<p>​						锁对象.wait() 让当前线程进入等待</p>
<p>​						锁对象.notify() 唤醒当前锁对象上等待状态的某个线程</p>
<p>​						锁对象.wait() 唤醒当前锁对象上等待状态的所有线程</p>
<p>​				线程状态：</p>
<p>​						new、runnable(就绪状态，运行状态)、blocked、timed_waiting、terminated </p>
<p>​			线程池：ExecutorService</p>
<p>​					作用：降低资源消耗、提高响应速度、提高线程的可管理性</p>
<p>​					创建线程池：ExecutorService pools&#x3D;Executors.newFixedThreadPool(线程数量)</p>
<p>​					提交任务：pools.submit(线程任务类的引用)</p>
<p>​					关闭线程池：pools.shutdown()</p>
<p>​			死锁：</p>
<p>​					产生的四个必要条件：</p>
<p>​							1.互斥使用：当资源被占用时，其他线程不能使用</p>
<p>​							2.不可抢占：资源请求者不能强制从资源占有者手中夺取资源</p>
<p>​							3.请求和保持：当资源请求者在请求其他资源的同时保持对原有资源的占有</p>
<p>​							4.循环等待：存在一个等待循环队列</p>
<h3 id="volatile："><a href="#volatile：" class="headerlink" title="volatile："></a>volatile：</h3><p>​		问题：并发编程下，多线程修改共享变量会出现变量修改值后的不可见性</p>
<p>​				原因：每个线程都有自己的工作内存，线程都是从主内存拷贝共享变量的副本值</p>
<p>​							每个线程是在自己的工作内存操作共享变量的</p>
<p>​				解决方案：</p>
<p>​							加锁（加锁会清空工作内存，读取主内存中最新的共享变量）</p>
<p>​							给共享变量加上volatile关键字（一旦有一个线程修改了voaltile修饰的变量，其他线程会更新）</p>
<p>​		java内存模型JMM：JVM规范中定义的一种内存模型，描述了java程序中各种变量的访问规则</p>
<p>​		原子性：指一批操作是一个整体，要么同时成功，要么同时失败，不能被干扰</p>
<p>​						volatile只能保证线程间变量的可见性，但是不能保证变量操作的原子性</p>
<p>​				保证原子性方案：</p>
<p>​							加锁</p>
<p>​							使用原子类</p>
<h3 id="原子类：Atomic"><a href="#原子类：Atomic" class="headerlink" title="原子类：Atomic"></a>原子类：Atomic</h3><p>​			原子类：java.util.concurrent.atomic，性能高效，线程安全，可以保证原子性			</p>
<p>​			原理：CAS机制（先比较再交换）</p>
<p>​			乐观锁与悲观锁： CAS，总是假设最好的情况被称为乐观锁</p>
<p>​											Synchronized，总是假设最坏情况被称为悲观锁</p>
<h3 id="并发包："><a href="#并发包：" class="headerlink" title="并发包："></a>并发包：</h3><p>​			ConcurrentHashMap：线程安全，效率高，性能好，最新最好用的线程安全的Map集合</p>
<p>​					对比：</p>
<p>​							HashMap：线程不安全，性能好</p>
<p>​							HashTable：线程安全，性能较差，被淘汰</p>
<p>​					高效的原因：CAS机制+局部锁定(分段式锁)</p>
<p>​			CountDownLatch：可以控制一个或多个线程等待其他线程执行完，再执行自己</p>
<p>​						构造器：CountDownLatch(int count)  初始化唤醒需要countDown几步</p>
<p>​						方法：await() 让当前线程等待</p>
<p>​									countDown()   计数器减一</p>
<p>​			CyclicBarrier循环屏障：某个线程任务必须等待其他线程执行完毕以后才能最终触发自己执行</p>
<p>​						作用：可以实现多线程中，某个任务在等待其他线程执行完后触发</p>
<p>​						构造器：CyclicBarrier(int parties,Runnable barrierAction)  在线程到达屏障时，优先执行任务</p>
<p>​						方法：await() 回收当前线程</p>
<p>​			Semaphore信号量：控制访问特定资源的线程数目</p>
<p>​						作用：控制线程并发占锁的数量</p>
<p>​						构造器：Semaphore(int permits)  permits表示许可线程的数量</p>
<p>​								Semaphore(int permits,boolean fair)  fair表示公平性，若为true,下次执行的线程会等待最久</p>
<p>​						方法：acquire() 获取许可</p>
<p>​									release() 释放许可</p>
<p>​			Exchanger交换者：进行线程间的数据交换,一个线程如果等不到对方的数据交换就会一致等待</p>
<p>​						构造器：Exchanger()  </p>
<p>​						方法：exchang() 交换 ，可以设置等待时间</p>
<h3 id="Lambda表达式："><a href="#Lambda表达式：" class="headerlink" title="Lambda表达式："></a>Lambda表达式：</h3><p>​			使用前提：</p>
<p>​						lambda表达式只能简化接口中只有一个抽象方法的匿名内部类形式</p>
<p>​						一旦某个接口加上了@FunctionalInterface注解，则可以使用lambda简化</p>
<p>​			省略写法：方法体只有一行时，可省略大括号以及分号（return语句，还需要省略return）</p>
<p>​							   参数类型可以省略，若只有一个参数，还可以省略()</p>
<h3 id="方法引用："><a href="#方法引用：" class="headerlink" title="方法引用："></a>方法引用：</h3><p>​			作用：可以进一步简化lambda表达式</p>
<p>​			格式：</p>
<p>​						类型或者对象::引用的方法</p>
<p>​						类::静态方法   (o1,o2)-&gt;类.静态方法(o1,o2);  简化为：类::静态方法</p>
<p>​						特定类型::方法  </p>
<p>​						类型::new    String[]::new 转换为数组类型</p>
<p>​			例子1：lists.forEach(s-&gt;System.out.println(s));</p>
<p>​						简化为：lists.forEach(System.out::println);</p>
<h3 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流:"></a>Stream流:</h3><p>​			作用：用来简化集合类库或者数组API的弊端</p>
<p>​			格式：lists.stream().filter(s-&gt;{}).forEach()…</p>
<p>​			获取流：</p>
<p>​					Collection集合：集合.stream()</p>
<p>​					Map集合：集合.keySet().stream()  或  集合.values().stream() 或 集合.entrySet().stream()</p>
<p>​					数组：Arrays.stream(数组名)  或  Stream.of(数组名)</p>
<p>​			常用API：</p>
<p>​					forEach() 遍历      count()计数  </p>
<p>​					filter()过滤             limit() 取前几个元素</p>
<p>​					skip()跳过前几个    map()加工方法</p>
<p>​					concat()  合并两个流</p>
<p>​			终结方法与非终结方法：</p>
<p>​					终结方法有：forEach()  count()</p>
<p>​					非终结方法：除上面之外的其他方法</p>
<p>​			收集流：把流的数据转回到集合中</p>
<p>​					转换为Set集合：流.collect(Collectors.toSet())</p>
<p>​					转换为List集合：流.collect(Collectors.toList())</p>
<p>​					转换为数组：流.toArray()</p>
<h3 id="File类："><a href="#File类：" class="headerlink" title="File类："></a>File类：</h3><p>​		创建文件对象：</p>
<p>​				使用绝对路径：</p>
<p>​					File f1&#x3D;new File(“D:&#x2F;a.jpg”)</p>
<p>​					路径分隔符： &#x2F;  或者 \ \ 或者  File.separator</p>
<p>​				使用相对路径：从当前工程寻找</p>
<p>​					File f2&#x3D;new File(“文件对象&#x2F;文件夹对象”)</p>
<p>​		常见API：</p>
<p>​				.getAbsolutePath()    获取相对路径</p>
<p>​				.getPath()   获取定义时的路径</p>
<p>​				.getName()  获取文件的名称</p>
<p>​				.length()  获取文件大小(字节数)</p>
<p>​				.exists()  判断文件路径是否存在</p>
<p>​				.isFile()  判断文件对象是否是文件</p>
<p>​				.isDirectory()  判断文件对象是否是文件夹</p>
<p>​				.delete()  删除文件或空文件夹</p>
<p>​				.mkdirs()  创建多级文件夹</p>
<p>​			目录遍历</p>
<p>​					dir1.list()</p>
<p>​					dir1.listFiles()  获取当前目录对象的全部一级文件对象</p>
<p>​					f1.lastModified()  最后修改时间</p>
<p>​			递归搜索文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">searchFiles</span><span class="params">(File dir,String fileName)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dir.exists()&amp;&amp;dir.isDirectory())&#123;</span><br><span class="line">        File[] files=dir.listFiles();</span><br><span class="line">        <span class="keyword">if</span>(files!=<span class="literal">null</span>&amp;&amp;files.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(File f:files)&#123;</span><br><span class="line">                <span class="keyword">if</span>(f.isFile())&#123;</span><br><span class="line">                    <span class="keyword">if</span>(f.getName().contains(fileName))&#123;</span><br><span class="line">                        System.out.println(f.getAbsolutePath());</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        searchFiles(f,fileName);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="I-x2F-O流："><a href="#I-x2F-O流：" class="headerlink" title="I&#x2F;O流："></a>I&#x2F;O流：</h3><p>​		分类：输入流，输出流（以内存为基准，读到内存是输入流，从内存写入磁盘是输出流）</p>
<p>​		字节输入流：InputStream</p>
<p>​		字节输出流：OutputStream</p>
<p>​		字符输入流：Reader	</p>
<p>​		字符输出流：Writer</p>
<h3 id="文件流："><a href="#文件流：" class="headerlink" title="文件流："></a>文件流：</h3><p>​		FileInputStream：</p>
<p>​					创建字节输入流：new FileInputStream(“文件路径”)</p>
<p>​					.read() 读一个字节，若读不到就返回-1   注意：读中文时必会乱码，因为会截断中文字节</p>
<p>​					.read(byte[] buffer)读一个字节数组，若读不到就返回-1  注意：读中文时可能会乱码		</p>
<p>​		FileOutputStream：	</p>
<p>​					创建字节输出流：new FileOutputStream(“文件路径”)  每次创建都会清空文件</p>
<p>​					.write() 输出一个字节</p>
<p>​					.write(byte[] buffer)读一个字节数组</p>
<p>​						换行：os.write(“\r\n”.getBytes())</p>
<p>​		文件复制：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStream is=<span class="literal">null</span>;</span><br><span class="line">OutputStream os=<span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    is=<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line">    os=<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line">    <span class="type">byte</span>[] buffer=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="keyword">while</span>((len=is.read(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">        os.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;复制成功&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(is!=<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            is.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    		e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(os!=<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">           os.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    		e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		FileReader：</p>
<p>​					创建文件字符输入流：new FileReader(“path”);</p>
<p>​					.read() 读一个字符，返回该字符的编码，若读不到就返回-1</p>
<p>​					.read(char[] buffer)读一个字节数组</p>
<p>​		FileWriter：</p>
<p>​					创建文件字符输出流：new FileWriter(“path”);</p>
<p>​					.write() 输出一个字符</p>
<p>​					.write(char[] buffer) 输出一个字节数组</p>
<h3 id="缓冲流："><a href="#缓冲流：" class="headerlink" title="缓冲流："></a>缓冲流：</h3><p>​		BudderedInputStream：</p>
<p>​				将一个文件字节输入流包装成缓冲字节输入流：new BudderedInputStream(文件字节输入流);</p>
<p>​				原理：缓冲字节输入流自带8KB的缓冲池</p>
<p>​		BudderedOutputStream：</p>
<p>​				将一个文件字节输出流包装成缓冲字节输入流：new BudderedOutputStream(文件字节输出流)  </p>
<p>​		BudderedReader：</p>
<p>​					创建缓冲字符输入流：new BudderedReader(Reader reader);</p>
<p>​					.read() 读一个字符，返回该字符的机器码，若读不到就返回-1</p>
<p>​					.read(char[] buffer)读一个字节数组</p>
<p>​					.readLine() 读一行，返回字符串</p>
<p>​			读文本文件标准代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Reader fr=<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line">BudderedReader br=<span class="keyword">new</span> <span class="title class_">BudderedReader</span>(fr);</span><br><span class="line">String line;</span><br><span class="line"><span class="keyword">while</span>((line=br.readLine())!=<span class="literal">null</span>)&#123;</span><br><span class="line">    System.out.println(line);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		BudderedWriter：</p>
<p>​					创建缓冲字符输出流：new FileWriter(“path”);</p>
<p>​					.write() 输出一个字符</p>
<p>​					.write(char[] buffer) 输出一个字节数组</p>
<p>​					.newLine() 换行</p>
<p>​		字符输入转换流：InputStreamReader</p>
<p>​			作用：解决字符流读取不同编码乱码的问题，将字节流转换为字符流</p>
<p>​			new InputStreamReader(文件字节输入流,”编码格式”);</p>
<p>​		字符输出转换流：OutputStreamwriter</p>
<p>​			作用：指定编码将字节输出流转换成字符输出流</p>
<p>​			new OutputStreamwriter(字节输出流,”编码格式”);</p>
<h3 id="序列化：ObjectOutputStream-x2F-ObjectInputStream"><a href="#序列化：ObjectOutputStream-x2F-ObjectInputStream" class="headerlink" title="序列化：ObjectOutputStream&#x2F;ObjectInputStream"></a>序列化：ObjectOutputStream&#x2F;ObjectInputStream</h3><p>​		序列化：	   对象字节输出流：ObjectOutputStream</p>
<p>​				将一个文件字节输出流包装成对象字节输出流：new ObjectOutputStream(文件字节输出流);</p>
<p>​				将对象序列化：.writeObject(对象)</p>
<p>​				注意：对象如果想参与序列化，对象必须实现序列化接口Serializable</p>
<p>​							成员变量前使用treanient修饰，将不参与序列化</p>
<p>​		反序列化：	对象字节输入流：ObjectInputStream</p>
<p>​				将一个文件字节输入流包装成对象字节输入流：new ObjectInputStream(文件字节输出流);</p>
<p>​				将对象序列化：.readObject(对象)</p>
<p>​		序列化版本号：</p>
<p>​				加入序列版本号：private static final long serialVersionUID&#x3D;1L</p>
<h3 id="打印流：PrintStream-x2F-PrintWriter"><a href="#打印流：PrintStream-x2F-PrintWriter" class="headerlink" title="打印流：PrintStream&#x2F;PrintWriter"></a>打印流：PrintStream&#x2F;PrintWriter</h3><p>​		作用：方便高效的打印各种数据</p>
<p>​		创建打印流：new PrintStream(“path”);</p>
<p>​		改变输出流向：System.setOut(打印流对象)</p>
<h3 id="网络编程："><a href="#网络编程：" class="headerlink" title="网络编程："></a>网络编程：</h3><h4 id="InetAddress类"><a href="#InetAddress类" class="headerlink" title="InetAddress类"></a>InetAddress类</h4><p>​				方法：.getHostHame()域名    .getHostAddress()地址</p>
<h4 id="UDP通信："><a href="#UDP通信：" class="headerlink" title="UDP通信："></a>UDP通信：</h4><p>​				DatagramPacket数据包对象：用来封装要发送或接收的数据包</p>
<p>​						构造器：</p>
<p>​									发送端：DatagramPacket(byte[] buf,int length,InetAddress address,int port)</p>
<p>​									接收端：DatagramPacket(byte[] buf,int length)</p>
<p>​						方法：</p>
<p>​									.getLength()</p>
<p>​				DatagramSocket发送对象：用来发送或接收数据包</p>
<p>​						构造器：</p>
<p>​									DatagramSocket()</p>
<p>​									DatagramPacket(int port)</p>
<p>​						方法：</p>
<p>​									.send()发送数据包  .receive()接收数据包</p>
<h4 id="TCP通信："><a href="#TCP通信：" class="headerlink" title="TCP通信："></a>TCP通信：</h4><p>​				模拟通信：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">服务端：</span><br><span class="line">    ServerSocket ss=<span class="keyword">new</span> <span class="title class_">ServerSocket</span>(端口);</span><br><span class="line">	Socket socket=ss.accept();</span><br><span class="line">	InputStream is=socket.getInputStream();</span><br><span class="line">	Reader isr=<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(is);</span><br><span class="line">	BufferedReader br=<span class="keyword">new</span> <span class="title class_">BufferedReader</span>(isr);</span><br><span class="line">	String msg;</span><br><span class="line">	<span class="keyword">if</span>((msg=br.readLine())!=<span class="literal">null</span>)&#123;</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">    &#125;</span><br><span class="line">客户端：</span><br><span class="line">    Socket socket=<span class="keyword">new</span> <span class="title class_">Socket</span>(ip，端口);</span><br><span class="line">    OutputStream os=socket.getOutputStream();</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        Scanner sc=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.print(<span class="string">&quot;请说：&quot;</span>);</span><br><span class="line">        ps.println(sc.nextLine());</span><br><span class="line">        ps.flush();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​				图片上传：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">服务端：</span><br><span class="line">   	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEDT_File=<span class="string">&quot;服务器文件路径&quot;</span>;</span><br><span class="line">    ServerSocket ss=<span class="keyword">new</span> <span class="title class_">ServerSocket</span>(端口);</span><br><span class="line">	Socket socket=ss.accept();</span><br><span class="line">	InputStream is=socket.getInputStream();</span><br><span class="line">	BufferedInputStream bis=<span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(DEDT_File+UUID.randomUUID().toString()+<span class="string">&quot;.jpg&quot;</span>));</span><br><span class="line">	<span class="type">byte</span>[] buffer=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="keyword">while</span>((len=bis.rea(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">        bos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">    &#125;</span><br><span class="line">	bos.flush();</span><br><span class="line">    bis.close();</span><br><span class="line">	PrintStream ps=<span class="keyword">new</span> <span class="title class_">PrintStream</span>(socket.getOutputStream());</span><br><span class="line">	ps.println(<span class="string">&quot;收到&quot;</span>);</span><br><span class="line">	ps.flush();</span><br><span class="line">客户端：</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SRC_IMAGE=<span class="string">&quot;本地图片路径&quot;</span>;</span><br><span class="line">    Socket socket=<span class="keyword">new</span> <span class="title class_">Socket</span>(ip，端口);</span><br><span class="line">    OutputStream os=socket.getOutputStream();</span><br><span class="line">    BufferedOutputStream bos=<span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(os);</span><br><span class="line">    BufferedInputStream bis=<span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(SRC_IMAGE));</span><br><span class="line">    <span class="type">byte</span>[] buffer=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="keyword">while</span>((len=bis.rea(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">        bos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">    &#125;</span><br><span class="line">    bos.flush();</span><br><span class="line">    bis.close();</span><br><span class="line">	socket.shutdownOutput();</span><br><span class="line">    BufferedReader br=<span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(socket.getInputStream()));</span><br><span class="line">    System.out.println(br.readLine());</span><br></pre></td></tr></table></figure>

<h4 id="通信模型："><a href="#通信模型：" class="headerlink" title="通信模型："></a>通信模型：</h4><p>​					BIO通信模式：同步阻塞式通信，性能极差，大量线程，大量阻塞</p>
<p>​					伪异步通信：引入线程池</p>
<p>​					NIO通信模式：同步非阻塞，轮询所有客户端，有数据才开启线程来处理</p>
<p>​					AIO通信模式：异步非阻塞，io通信交给操作系统</p>
<h3 id="单元测试："><a href="#单元测试：" class="headerlink" title="单元测试："></a>单元测试：</h3><p>​		测试方法的要求：</p>
<p>​			1.必须public修饰  2.没有返回值没有参数  3.必须使用@Test注解</p>
<p>​			@Test</p>
<p>​			public void XXXTest(){}</p>
<h3 id="反射："><a href="#反射：" class="headerlink" title="反射："></a>反射：</h3><p>​		作用：做高级框架，能设计一些通用技术功能</p>
<p>​		关键：编译以后的class文件对象，反射是工作在运行时的技术，反射工作在运行阶段</p>
<p>​		获取类对象：1.类名.class：Class&lt;?&gt; c1&#x3D;Student.class;</p>
<p>​								2.对象.getClass()</p>
<p>​								3.Class.forName(“类的全限定名”)</p>
<p>​		获取构造器：1.类对象.getDeclaredConstructors();全部构造器</p>
<p>​								2.类对象.getConstructor();某个构造器，只能是public的</p>
<p>​								3.类对象.getDeclaredConstructor();某个构造器</p>
<p>​				API： 创建实例：.newInstance();</p>
<p>​							暴力打开私有构造器的访问：.setAccessible(true)</p>
<p>​		获取成员变量：1.类对象.getDeclaredFields();全部成员变量</p>
<p>​									2.类对象.getDeclaredField();某个成员变量</p>
<p>​				API：.set(被赋值的对象,value) 给对象注入某个成员变量数据</p>
<p>​						  .get(对象)获取对象的值</p>
<p>​		获取方法：1.类对象.getDeclaredMethods()所有方法</p>
<p>​							2.类对象.getDeclaredMethod(String name)某个方法</p>
<p>​				API：.invoke(方法对象)触发方法对象</p>
<h3 id="注解："><a href="#注解：" class="headerlink" title="注解："></a>注解：</h3><p>​		自定义注解： </p>
<p>​				修饰符 @interface 注解名{</p>
<p>​						类型 属性名();</p>
<p>​				}</p>
<p>​		元注解：</p>
<p>​				@Target()注解可以使用的位置</p>
<p>​				@Retention注解的生命周期</p>
<p>​		</p>
<h3 id="动态代理："><a href="#动态代理：" class="headerlink" title="动态代理："></a>动态代理：</h3><h3 id="算法："><a href="#算法：" class="headerlink" title="算法："></a>算法：</h3><p>​		冒泡排序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] bubbleSort(<span class="type">int</span>[] arr)&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;arr.length-i-<span class="number">1</span>;j++)&#123;</span><br><span class="line">               <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                   <span class="type">int</span> temp=arr[j+<span class="number">1</span>];</span><br><span class="line">                   arr[j+<span class="number">1</span>]=arr[j];</span><br><span class="line">                   arr[j]=temp;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; </span><br><span class="line">       <span class="keyword">return</span> arr;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>​		选择排序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] selectSort(<span class="type">int</span>[] arr)&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;arr.length-<span class="number">1</span>;j++)&#123;</span><br><span class="line">               <span class="keyword">if</span>(arr[j]&lt;arr[i])&#123;</span><br><span class="line">                   <span class="type">int</span> temp=arr[i];</span><br><span class="line">                   arr[i]=arr[j];</span><br><span class="line">                   arr[j]=temp;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; </span><br><span class="line">       <span class="keyword">return</span> arr;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>​		二分查找：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySerach</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> num)</span>&#123;</span><br><span class="line">       <span class="type">int</span> left=<span class="number">0</span>;</span><br><span class="line">       <span class="type">int</span> right=arr.length-<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span>(left&lt;=end)&#123;</span><br><span class="line">           <span class="type">int</span> index=(left+right)/<span class="number">2</span>;</span><br><span class="line">       	<span class="keyword">if</span>(num&lt;arr[index])&#123;</span><br><span class="line">           	right=index-<span class="number">1</span>;</span><br><span class="line">       	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(num&gt;arr[index])&#123;</span><br><span class="line">           	left=index+<span class="number">1</span>;</span><br><span class="line">       	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(num=arr[index])&#123;</span><br><span class="line">               <span class="keyword">return</span> index;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="数据结构："><a href="#数据结构：" class="headerlink" title="数据结构："></a>数据结构：</h3><p>​		二叉排序树：</p>
<p>​				优点：查找和增删都很优秀</p>
<p>​				缺点：“瘸子现象” 只有左节点或右节点</p>
<p>​		平衡二叉树：</p>
<p>​				规定：左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一颗平衡二叉树</p>
<p>​				调整平衡：左高往右提，右高往左提，不行就换方向提</p>
<p>​		红黑树：另一种算法规则的平衡二叉树</p>
<h3 id="设计模式："><a href="#设计模式：" class="headerlink" title="设计模式："></a>设计模式：</h3><p>​		1.模板设计模式：</p>
<p>​					作用：优化代码架构，提高代码的复用性，可以做到部分实现，部分抽象，抽象的东西交给使用</p>
<p>​								模板的子类重写实现</p>
<p>​		2.单例设计模式：</p>
<p>​					单例：指一个类只存在一个对象</p>
<p>​					单例的实现方式：（8种）</p>
<p>​							(1) 饿汉单例设计模式：通过类获取单例对象时，对象已经准备好了</p>
<p>​									实现步骤：</p>
<p>​											1.将构造器私有</p>
<p>​											2.定义静态成员变量存储一个对象</p>
<p>​											3.定义一个方法返回单例对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingleIntance</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingleIntance ins=<span class="keyword">new</span> <span class="title class_">SingleIntance</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingleIntance</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingleIntance <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ins</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​							(2) 懒汉单例设计模式：通过类获取单例对象时，才去创建对象</p>
<p>​									实现步骤：</p>
<p>​											1.将构造器私有</p>
<p>​											2.定义静态成员变量</p>
<p>​											3.定义一个方法返回单例对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingleIntance</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingleIntance ins;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingleIntance</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingleIntance <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ins==<span class="literal">null</span>)&#123;ins = <span class="keyword">new</span> <span class="title class_">SingleIntance</span>();&#125;</span><br><span class="line">        <span class="keyword">return</span> ins</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​				3.工厂模式：可以实现类与类之间的解耦	</p>
<p>​				4.装饰模式：不改变原类，不使用继承，动态扩展一个类的功能</p>
<hr>
<p>😆END</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis入门</title>
    <url>/posts/64e66de7.html</url>
    <content><![CDATA[<h3 id="Redis-简介"><a href="#Redis-简介" class="headerlink" title="Redis 简介"></a>Redis 简介</h3><h4 id="1-问题："><a href="#1-问题：" class="headerlink" title="1.问题："></a>1.问题：</h4><p>在涉及大数据量的需求，比如一些商品抢购的情景，或者是主页访问量瞬间较大的时候，单一使用数据库来保存数据的系统会因为面向磁盘，磁盘读&#x2F;写速度比较慢的问题而存在严重的性能弊端，一瞬间成千上万的请求到来，需要系统在极短的时间内完成成千上万次的读&#x2F;写操作，这个时候往往不是数据库能够承受的，极其容易造成数据库系统瘫痪，最终导致服务宕机的严重生产问题。</p>
<h4 id="2-NoSQL-技术"><a href="#2-NoSQL-技术" class="headerlink" title="2.NoSQL 技术"></a>2.NoSQL 技术</h4><p>为了克服上述的问题，Java Web项目通常会引入NoSQL技术，这是一种基于内存的数据库，并且提供一定的持久化功能。<br>Redis和MongoDB是当前使用最广泛的NoSQL，而就Redis技术而言，它的性能十分优越，可以支持每秒十几万此的读&#x2F;写操作，其性能远超数据库，并且还支持集群、分布式、主从同步等配置，原则上可以无限扩展，让更多的数据存储在内存中，更让人欣慰的是它还支持一定的事务能力，这保证了高并发的场景下数据的安全和一致性。</p>
<h4 id="3-使用场景"><a href="#3-使用场景" class="headerlink" title="3.使用场景"></a>3.使用场景</h4><p>一般我们只是使用 Redis 存储一些常用和主要的数据，比如用户登录的信息等。<br>从这几个方面来考虑：<br>业务数据常用吗？命中率如何？如果命中率很低，就没有必要写入缓存；<br>该业务数据是读操作多，还是写操作多？如果写操作多，频繁需要写入数据库，也没有必要使用缓存；<br>业务数据大小如何？如果要存储几百兆字节的文件，会给缓存带来很大的压力，这样也没有必要；</p>
<h4 id="4-redis定义"><a href="#4-redis定义" class="headerlink" title="4.redis定义"></a>4.redis定义</h4><p>REmote DIctionary Server(Redis) 是一个由 Salvatore Sanfilippo 写的 key-value 存储系统，是跨平台的非关系型数据库。<br>Redis 是一个开源的使用 ANSI C 语言编写、遵守 BSD 协议、支持网络、可基于内存、分布式、可选持久性的键值对(Key-Value)存储数据库，并提供多种语言的 API。<br>Redis 通常被称为数据结构服务器，因为值（value）可以是字符串(String)、哈希(Hash)、列表(list)、集合(sets)和有序集合(sorted sets)等类型。</p>
<h3 id="redis数据类型"><a href="#redis数据类型" class="headerlink" title="redis数据类型"></a>redis数据类型</h3><h4 id="1-String字符串"><a href="#1-String字符串" class="headerlink" title="1.String字符串"></a>1.String字符串</h4><p>特点：<br>一个 key 对应一个 value。<br>二进制安全的， string 可以包含任何数据。比如jpg图片或者序列化的对象<br>值最大能存储 512MB<br>命令：</p>
<blockquote>
<p>SET runoob “菜鸟教程”<br>GET runoob<br>DEL runoob</p>
</blockquote>
<h4 id="2-Hash哈希"><a href="#2-Hash哈希" class="headerlink" title="2.Hash哈希"></a>2.Hash哈希</h4><p>特点：<br>一个键值(key&#x3D;&gt;value)对集合<br>一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象<br>命令：</p>
<blockquote>
<p>HMSET runoob field1 “Hello” field2 “World”<br>HGET runoob field1</p>
</blockquote>
<h4 id="3-List列表"><a href="#3-List列表" class="headerlink" title="3.List列表"></a>3.List列表</h4><p>特点：<br>简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）<br>命令：</p>
<blockquote>
<p>lpush runoob redis<br>lrange runoob 0 10</p>
</blockquote>
<h4 id="4-Set集合"><a href="#4-Set集合" class="headerlink" title="4.Set集合"></a>4.Set集合</h4><p>特点：<br>Set 是 string 类型的无序集合<br>集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)<br>命令：</p>
<blockquote>
<p>sadd runoob redis<br>smembers runoob</p>
</blockquote>
<h4 id="5-zset-sorted-set：有序集合"><a href="#5-zset-sorted-set：有序集合" class="headerlink" title="5.zset(sorted set：有序集合)"></a>5.zset(sorted set：有序集合)</h4><p>特点：<br>zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。<br>不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。<br>zset的成员是唯一的,但分数(score)却可以重复。<br>命令：</p>
<blockquote>
<p>zadd runoob 0 redis<br>ZRANGEBYSCORE runoob 0 1000</p>
</blockquote>
<h4 id="6-各个数据类型的应用场景"><a href="#6-各个数据类型的应用场景" class="headerlink" title="6.各个数据类型的应用场景"></a>6.各个数据类型的应用场景</h4><p>String 大多数场景<br>Hash 存储、读取、修改用户属性<br>List 1,最新消息排行等功能(比如朋友圈的时间线) 2,消息队列<br>Set 1、共同好友 2、利用唯一性,统计访问网站的所有独立ip 3、好友推荐时,根据tag求交集,大于某个阈值就可以推荐<br>Sorted Set 1、排行榜 2、带权重的消息队列</p>
<h3 id="redis命令"><a href="#redis命令" class="headerlink" title="redis命令"></a>redis命令</h3><h4 id="1-启动命令"><a href="#1-启动命令" class="headerlink" title="1.启动命令"></a>1.启动命令</h4><p>启动 redis 客户端：</p>
<blockquote>
<p>$ redis-cli</p>
</blockquote>
<p>注：可能出现中文乱码。<br>要在 redis-cli 后面加上 –raw<br>检测 redis 服务是否启动：</p>
<blockquote>
<p>PING</p>
</blockquote>
<p>远程 redis 服务上执行命令：</p>
<blockquote>
<p>$ redis-cli -h host -p port -a password</p>
</blockquote>
<h4 id="2-key命令"><a href="#2-key命令" class="headerlink" title="2.key命令"></a>2.key命令</h4><blockquote>
<p>DEL key<br>该命令用于在 key 存在时删除 key。<br>DUMP key<br>序列化给定 key ，并返回被序列化的值。<br>EXISTS key<br>检查给定 key 是否存在。<br>EXPIRE key seconds<br>为给定 key 设置过期时间，以秒计。<br>EXPIREAT key timestamp<br>EXPIREAT的作用和 EXPIRE 类似，都用于为 key 设置过期时间。 不同在于 EXPIREAT 命令接受的时间参数是 UNIX 时间戳(unix timestamp)。<br>PEXPIRE key milliseconds<br>设置 key 的过期时间以毫秒计。<br>PEXPIREAT key milliseconds-timestamp<br>设置 key 过期时间的时间戳(unix timestamp) 以毫秒计<br>KEYS pattern<br>查找所有符合给定模式( pattern)的 key 。<br>MOVE key db<br>将当前数据库的 key 移动到给定的数据库 db 当中。<br>PERSIST key<br>移除 key 的过期时间，key 将持久保持。<br>PTTL key<br>以毫秒为单位返回 key 的剩余的过期时间。<br>TTL key<br>以秒为单位，返回给定 key 的剩余生存时间(TTL, time to live)。<br>RANDOMKEY<br>从当前数据库中随机返回一个 key 。<br>RENAME key newkey<br>修改 key 的名称<br>RENAMENX key newkey<br>仅当 newkey 不存在时，将 key 改名为 newkey 。<br>SCAN cursor [MATCH pattern] [COUNT count]<br>迭代数据库中的数据库键。<br>TYPE key<br>返回 key 所储存的值的类型。</p>
</blockquote>
<h4 id="3-String命令"><a href="#3-String命令" class="headerlink" title="3.String命令"></a>3.String命令</h4><blockquote>
<p>SET key value<br>设置指定 key 的值。<br>GET key<br>获取指定 key 的值。<br>GETRANGE key start end<br>返回 key 中字符串值的子字符<br>GETSET key value<br>将给定 key 的值设为 value ，并返回 key 的旧值(old value)。<br>GETBIT key offset<br>对 key 所储存的字符串值，获取指定偏移量上的位(bit)。<br>MGET key1 [key2..]<br>获取所有(一个或多个)给定 key 的值。<br>SETBIT key offset value<br>对 key 所储存的字符串值，设置或清除指定偏移量上的位(bit)。<br>SETEX key seconds value<br>将值 value 关联到 key ，并将 key 的过期时间设为 seconds (以秒为单位)。<br>SETNX key value<br>只有在 key 不存在时设置 key 的值。<br>SETRANGE key offset value<br>用 value 参数覆写给定 key 所储存的字符串值，从偏移量 offset 开始。<br>STRLEN key<br>返回 key 所储存的字符串值的长度。<br>MSET key value [key value …]<br>同时设置一个或多个 key-value 对。<br>MSETNX key value [key value …]<br>同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。<br>PSETEX key milliseconds value<br>这个命令和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间，而不是像 SETEX 命令那样，以秒为单位。<br>INCR key<br>将 key 中储存的数字值增一。<br>INCRBY key increment<br>将 key 所储存的值加上给定的增量值（increment） 。<br>INCRBYFLOAT key increment<br>将 key 所储存的值加上给定的浮点增量值（increment） 。<br>DECR key<br>将 key 中储存的数字值减一。<br>DECRBY key decrement<br>key 所储存的值减去给定的减量值（decrement） 。<br>APPEND key value<br>如果 key 已经存在并且是一个字符串， APPEND 命令将指定的 value 追加到该 key 原来值（value）的末尾。</p>
</blockquote>
<h4 id="4-hash命令"><a href="#4-hash命令" class="headerlink" title="4.hash命令"></a>4.hash命令</h4><blockquote>
<p>HDEL key field1 [field2]<br>删除一个或多个哈希表字段<br>HEXISTS key field<br>查看哈希表 key 中，指定的字段是否存在。<br>HGET key field<br>获取存储在哈希表中指定字段的值。<br>HGETALL key<br>获取在哈希表中指定 key 的所有字段和值<br>HINCRBY key field increment<br>为哈希表 key 中的指定字段的整数值加上增量 increment 。<br>HINCRBYFLOAT key field increment<br>为哈希表 key 中的指定字段的浮点数值加上增量 increment 。<br>HKEYS key<br>获取哈希表中的所有字段<br>HLEN key<br>获取哈希表中字段的数量<br>HMGET key field1 [field2]<br>获取所有给定字段的值<br>HMSET key field1 value1 [field2 value2 ]<br>同时将多个 field-value (域-值)对设置到哈希表 key 中。<br>HSET key field value<br>将哈希表 key 中的字段 field 的值设为 value 。<br>HSETNX key field value<br>只有在字段 field 不存在时，设置哈希表字段的值。<br>HVALS key<br>获取哈希表中所有值。<br>HSCAN key cursor [MATCH pattern] [COUNT count]<br>迭代哈希表中的键值对。</p>
</blockquote>
<h4 id="5-List命令"><a href="#5-List命令" class="headerlink" title="5.List命令"></a>5.List命令</h4><blockquote>
<p>BLPOP key1 [key2 ] timeout<br>移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。<br>BRPOP key1 [key2 ] timeout<br>移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。<br>BRPOPLPUSH source destination timeout<br>从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。<br>LINDEX key index<br>通过索引获取列表中的元素<br>LINSERT key BEFORE|AFTER pivot value<br>在列表的元素前或者后插入元素<br>LLEN key<br>获取列表长度<br>LPOP key<br>移出并获取列表的第一个元素<br>LPUSH key value1 [value2]<br>将一个或多个值插入到列表头部<br>LPUSHX key value<br>将一个值插入到已存在的列表头部<br>LRANGE key start stop<br>获取列表指定范围内的元素<br>LREM key count value<br>移除列表元素<br>LSET key index value<br>通过索引设置列表元素的值<br>LTRIM key start stop<br>对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。<br>RPOP key<br>移除列表的最后一个元素，返回值为移除的元素。<br>RPOPLPUSH source destination<br>移除列表的最后一个元素，并将该元素添加到另一个列表并返回<br>RPUSH key value1 [value2]<br>在列表中添加一个或多个值到列表尾部<br>RPUSHX key value<br>为已存在的列表添加值</p>
</blockquote>
<h4 id="6-set命令"><a href="#6-set命令" class="headerlink" title="6.set命令"></a>6.set命令</h4><blockquote>
<p>SADD key member1 [member2]<br>向集合添加一个或多个成员<br>SCARD key<br>获取集合的成员数<br>SDIFF key1 [key2]<br>返回第一个集合与其他集合之间的差异。<br>SDIFFSTORE destination key1 [key2]<br>返回给定所有集合的差集并存储在 destination 中<br>SINTER key1 [key2]<br>返回给定所有集合的交集<br>SINTERSTORE destination key1 [key2]<br>返回给定所有集合的交集并存储在 destination 中<br>SISMEMBER key member<br>判断 member 元素是否是集合 key 的成员<br>SMEMBERS key<br>返回集合中的所有成员<br>SMOVE source destination member<br>将 member 元素从 source 集合移动到 destination 集合<br>SPOP key<br>移除并返回集合中的一个随机元素<br>SRANDMEMBER key [count]<br>返回集合中一个或多个随机数<br>SREM key member1 [member2]<br>移除集合中一个或多个成员<br>SUNION key1 [key2]<br>返回所有给定集合的并集<br>SUNIONSTORE destination key1 [key2]<br>所有给定集合的并集存储在 destination 集合中<br>SSCAN key cursor [MATCH pattern] [COUNT count]<br>迭代集合中的元素</p>
</blockquote>
<h4 id="7-sorted-set命令"><a href="#7-sorted-set命令" class="headerlink" title="7. sorted set命令"></a>7. sorted set命令</h4><blockquote>
<p>ZADD key score1 member1 [score2 member2]<br>向有序集合添加一个或多个成员，或者更新已存在成员的分数<br>ZCARD key<br>获取有序集合的成员数<br>ZCOUNT key min max<br>计算在有序集合中指定区间分数的成员数<br>ZINCRBY key increment member<br>有序集合中对指定成员的分数加上增量 increment<br>ZINTERSTORE destination numkeys key [key …]<br>计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 destination 中<br>ZLEXCOUNT key min max<br>在有序集合中计算指定字典区间内成员数量<br>ZRANGE key start stop [WITHSCORES]<br>通过索引区间返回有序集合指定区间内的成员<br>ZRANGEBYLEX key min max [LIMIT offset count]<br>通过字典区间返回有序集合的成员<br>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT]<br>通过分数返回有序集合指定区间内的成员<br>ZRANK key member<br>返回有序集合中指定成员的索引<br>ZREM key member [member …]<br>移除有序集合中的一个或多个成员<br>ZREMRANGEBYLEX key min max<br>移除有序集合中给定的字典区间的所有成员<br>ZREMRANGEBYRANK key start stop<br>移除有序集合中给定的排名区间的所有成员<br>ZREMRANGEBYSCORE key min max<br>移除有序集合中给定的分数区间的所有成员<br>ZREVRANGE key start stop [WITHSCORES]<br>返回有序集中指定区间内的成员，通过索引，分数从高到低<br>ZREVRANGEBYSCORE key max min [WITHSCORES]<br>返回有序集中指定分数区间内的成员，分数从高到低排序<br>ZREVRANK key member<br>返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序<br>ZSCORE key member<br>返回有序集中，成员的分数值<br>ZUNIONSTORE destination numkeys key [key …]<br>计算给定的一个或多个有序集的并集，并存储在新的 key 中<br>ZSCAN key cursor [MATCH pattern] [COUNT count]<br>迭代有序集合中的元素（包括元素成员和元素分值）</p>
</blockquote>
<h4 id="8-HyperLogLog-命令"><a href="#8-HyperLogLog-命令" class="headerlink" title="8. HyperLogLog 命令"></a>8. HyperLogLog 命令</h4><blockquote>
<p>PFADD key element [element …]<br>添加指定元素到 HyperLogLog 中。<br>PFCOUNT key [key …]<br>返回给定 HyperLogLog 的基数估算值。<br>PFMERGE destkey sourcekey [sourcekey …]<br>将多个 HyperLogLog 合并为一个 HyperLogLog</p>
</blockquote>
<h3 id="redis发布订阅"><a href="#redis发布订阅" class="headerlink" title="redis发布订阅"></a>redis发布订阅</h3><p>Redis 发布订阅 (pub&#x2F;sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。<br>Redis 客户端可以订阅任意数量的频道。<br>发布订阅命令：</p>
<blockquote>
<p>PSUBSCRIBE pattern [pattern …]<br>订阅一个或多个符合给定模式的频道。<br>PUBSUB subcommand [argument [argument …]]<br>查看订阅与发布系统状态。<br>PUBLISH channel message<br>将信息发送到指定的频道。<br>PUNSUBSCRIBE [pattern [pattern …]]<br>退订所有给定模式的频道。<br>SUBSCRIBE channel [channel …]<br>订阅给定的一个或多个频道的信息。<br>UNSUBSCRIBE [channel [channel …]]<br>指退订给定的频道。</p>
</blockquote>
<h3 id="redis事务"><a href="#redis事务" class="headerlink" title="redis事务"></a>redis事务</h3><p>Redis 事务可以一次执行多个命令， 并且带有以下三个重要的保证：<br>批量操作在发送 EXEC 命令前被放入队列缓存。<br>收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。<br>在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。<br>一个事务从开始到执行会经历以下三个阶段：<br>开始事务。<br>命令入队。<br>执行事务。<br>事务命令：</p>
<blockquote>
<p>DISCARD<br>取消事务，放弃执行事务块内的所有命令。<br>EXEC<br>执行所有事务块内的命令。<br>MULTI<br>标记一个事务块的开始。<br>UNWATCH<br>取消 WATCH 命令对所有 key 的监视。<br>WATCH key [key …]<br>监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。</p>
</blockquote>
<h3 id="redis脚本"><a href="#redis脚本" class="headerlink" title="redis脚本"></a>redis脚本</h3><p>Redis 脚本使用 Lua 解释器来执行脚本.<br>脚本命令：</p>
<blockquote>
<p>EVAL script numkeys key [key …] arg [arg …]<br>执行 Lua 脚本。<br>EVALSHA sha1 numkeys key [key …] arg [arg …]<br>执行 Lua 脚本。<br>SCRIPT EXISTS script [script …]<br>查看指定的脚本是否已经被保存在缓存当中。<br>SCRIPT FLUSH<br>从脚本缓存中移除所有脚本。<br>SCRIPT KILL<br>杀死当前正在运行的 Lua 脚本。<br>SCRIPT LOAD script<br>将脚本 script 添加到脚本缓存中，但并不立即执行这个脚本。</p>
</blockquote>
<h3 id="redis连接"><a href="#redis连接" class="headerlink" title="redis连接"></a>redis连接</h3><p>连接命令：</p>
<blockquote>
<p>AUTH password<br>验证密码是否正确<br>ECHO message<br>打印字符串<br>PING<br>查看服务是否运行<br>QUIT<br>关闭当前连接<br>SELECT index<br>切换到指定的数据库</p>
</blockquote>
<h3 id="redis服务器"><a href="#redis服务器" class="headerlink" title="redis服务器"></a>redis服务器</h3><p>服务器命令:</p>
<blockquote>
<p>BGREWRITEAOF<br>异步执行一个 AOF（AppendOnly File） 文件重写操作<br>BGSAVE<br>在后台异步保存当前数据库的数据到磁盘<br>CLIENT KILL [ip:port] [ID client-id]<br>关闭客户端连接<br>CLIENT LIST<br>获取连接到服务器的客户端连接列表<br>CLIENT GETNAME<br>获取连接的名称<br>CLIENT PAUSE timeout<br>在指定时间内终止运行来自客户端的命令<br>CLIENT SETNAME connection-name<br>设置当前连接的名称<br>CLUSTER SLOTS<br>获取集群节点的映射数组<br>COMMAND<br>获取 Redis 命令详情数组<br>COMMAND COUNT<br>获取 Redis 命令总数<br>COMMAND GETKEYS<br>获取给定命令的所有键<br>TIME<br>返回当前服务器时间<br>COMMAND INFO command-name [command-name …]<br>获取指定 Redis 命令描述的数组<br>CONFIG GET parameter<br>获取指定配置参数的值<br>CONFIG REWRITE<br>对启动 Redis 服务器时所指定的 redis.conf 配置文件进行改写<br>CONFIG SET parameter value<br>修改 redis 配置参数，无需重启<br>CONFIG RESETSTAT<br>重置 INFO 命令中的某些统计数据<br>DBSIZE<br>返回当前数据库的 key 的数量<br>DEBUG OBJECT key<br>获取 key 的调试信息<br>DEBUG SEGFAULT<br>让 Redis 服务崩溃<br>FLUSHALL<br>删除所有数据库的所有key<br>FLUSHDB<br>删除当前数据库的所有key<br>INFO [section]<br>获取 Redis 服务器的各种信息和统计数值<br>LASTSAVE<br>返回最近一次 Redis 成功将数据保存到磁盘上的时间，以 UNIX 时间戳格式表示<br>MONITOR<br>实时打印出 Redis 服务器接收到的命令，调试用<br>ROLE<br>返回主从实例所属的角色<br>SAVE<br>同步保存数据到硬盘<br>SHUTDOWN [NOSAVE] [SAVE]<br>异步保存数据到硬盘，并关闭服务器<br>SLAVEOF host port<br>将当前服务器转变为指定服务器的从属服务器(slave server)<br>SLOWLOG subcommand [argument]<br>管理 redis 的慢日志</p>
</blockquote>
<h3 id="redis-Stream"><a href="#redis-Stream" class="headerlink" title="redis Stream"></a>redis Stream</h3><p>Redis 5.0 版本新增加的数据结构。<br>Redis Stream 主要用于消息队列（MQ，Message Queue），Redis 本身是有一个 Redis 发布订阅 (pub&#x2F;sub) 来实现消息队列的功能，但它有个缺点就是消息无法持久化，如果出现网络断开、Redis 宕机等，消息就会被丢弃。<br>简单来说发布订阅 (pub&#x2F;sub) 可以分发消息，但无法记录历史消息。<br>而 Redis Stream 提供了消息的持久化和主备复制功能，可以让任何客户端访问任何时刻的数据，并且能记住每一个客户端的访问位置，还能保证消息不丢失。</p>
<hr>
<p>😛END</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB入门</title>
    <url>/posts/661780e7.html</url>
    <content><![CDATA[<h3 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h3><h4 id="1-分布式计算的优点："><a href="#1-分布式计算的优点：" class="headerlink" title="1.分布式计算的优点："></a>1.分布式计算的优点：</h4><p>可靠性（容错） ：<br>分布式计算系统中的一个重要的优点是可靠性。一台服务器的系统崩溃并不影响到其余的服务器。<br>可扩展性：<br>在分布式计算系统可以根据需要增加更多的机器。<br>资源共享：<br>共享数据是必不可少的应用，如银行，预订系统。<br>灵活性：<br>由于该系统是非常灵活的，它很容易安装，实施和调试新的服务。<br>更快的速度：<br>分布式计算系统可以有多台计算机的计算能力，使得它比其他系统有更快的处理速度。<br>开放系统：<br>由于它是开放的系统，本地或者远程都可以访问到该服务。<br>更高的性能：<br>相较于集中式计算机网络集群可以提供更高的性能（及更好的性价比）。</p>
<h4 id="2-分布式计算的缺点："><a href="#2-分布式计算的缺点：" class="headerlink" title="2.分布式计算的缺点："></a>2.分布式计算的缺点：</h4><p>故障排除：<br>故障排除和诊断问题。<br>软件：<br>更少的软件支持是分布式计算系统的主要缺点。<br>网络：<br>网络基础设施的问题，包括：传输问题，高负载，信息丢失等。<br>安全性：<br>开放系统的特性让分布式计算系统存在着数据的安全性和共享的风险等问题。</p>
<h3 id="NoSQL简介"><a href="#NoSQL简介" class="headerlink" title="NoSQL简介"></a>NoSQL简介</h3><h4 id="1-定义："><a href="#1-定义：" class="headerlink" title="1.定义："></a>1.定义：</h4><p>NoSQL(NoSQL &#x3D; Not Only SQL )，意即”不仅仅是SQL”。</p>
<h4 id="2-什么是NoSQL"><a href="#2-什么是NoSQL" class="headerlink" title="2.什么是NoSQL?"></a>2.什么是NoSQL?</h4><p>NoSQL，指的是非关系型的数据库。NoSQL有时也称作Not Only SQL的缩写，是对不同于传统的关系型数据库的数据库管理系统的统称。<br>NoSQL用于超大规模数据的存储。（例如谷歌或Facebook每天为他们的用户收集万亿比特的数据）。这些类型的数据存储不需要固定的模式，无需多余操作就可以横向扩展。</p>
<h4 id="3-为什么使用NoSQL"><a href="#3-为什么使用NoSQL" class="headerlink" title="3.为什么使用NoSQL ?"></a>3.为什么使用NoSQL ?</h4><p>今天我们可以通过第三方平台（如：Google,Facebook等）可以很容易的访问和抓取数据。用户的个人信息，社交网络，地理位置，用户生成的数据和用户操作日志已经成倍的增加。我们如果要对这些用户数据进行挖掘，那SQL数据库已经不适合这些应用了, NoSQL 数据库的发展却能很好的处理这些大的数据。</p>
<h4 id="4-RDBMS-vs-NoSQL"><a href="#4-RDBMS-vs-NoSQL" class="headerlink" title="4.RDBMS vs NoSQL"></a>4.RDBMS vs NoSQL</h4><p>RDBMS<br>-高度组织化结构化数据<br>-结构化查询语言（SQL） (SQL)<br>-数据和关系都存储在单独的表中。<br>-数据操纵语言，数据定义语言<br>-严格的一致性<br>-基础事务<br>NoSQL<br>-代表着不仅仅是SQL<br>-没有声明性查询语言<br>-没有预定义的模式<br>-键-值对存储，列存储，文档存储，图形数据库<br>-最终一致性，而非ACID属性<br>-非结构化和不可预知的数据<br>-CAP定理<br>-高性能，高可用性和可伸缩性</p>
<h4 id="5-NoSQL的优点-x2F-缺点"><a href="#5-NoSQL的优点-x2F-缺点" class="headerlink" title="5.NoSQL的优点&#x2F;缺点"></a>5.NoSQL的优点&#x2F;缺点</h4><p>优点:<br>-高可扩展性<br>-分布式计算<br>-低成本<br>-架构的灵活性，半结构化数据<br>-没有复杂的关系<br>缺点:<br>-没有标准化<br>-有限的查询功能（到目前为止）<br>-最终一致是不直观的程序</p>
<h4 id="6-BASE"><a href="#6-BASE" class="headerlink" title="6.BASE"></a>6.BASE</h4><p>BASE：Basically Available, Soft-state, Eventually Consistent。 由 Eric Brewer 定义。<br>CAP理论的核心是：一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求，最多只能同时较好的满足两个。<br>BASE是NoSQL数据库通常对可用性及一致性的弱要求原则:<br>Basically Available –基本可用<br>Soft-state –软状态&#x2F;柔性事务。 “Soft state” 可以理解为”无连接”的, 而 “Hard state” 是”面向连接”的<br>Eventually Consistency – 最终一致性， 也是 ACID 的最终目的。</p>
<h3 id="MongoDB简介"><a href="#MongoDB简介" class="headerlink" title="MongoDB简介"></a>MongoDB简介</h3><h4 id="1-概念："><a href="#1-概念：" class="headerlink" title="1.概念："></a>1.概念：</h4><p>MongoDB 是由C++语言编写的，是一个基于分布式文件存储的开源数据库系统。<br>在高负载的情况下，添加更多的节点，可以保证服务器性能。<br>MongoDB 旨在为WEB应用提供可扩展的高性能数据存储解决方案。<br>MongoDB 将数据存储为一个文档，数据结构由键值(key&#x3D;&gt;value)对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。</p>
<h4 id="2-主要特点"><a href="#2-主要特点" class="headerlink" title="2.主要特点"></a>2.主要特点</h4><p>MongoDB 是一个面向文档存储的数据库，操作起来比较简单和容易。<br>你可以在MongoDB记录中设置任何属性的索引 (如：FirstName&#x3D;”Sameer”,Address&#x3D;”8 Gandhi Road”)来实现更快的排序。<br>你可以通过本地或者网络创建数据镜像，这使得MongoDB有更强的扩展性。<br>如果负载的增加（需要更多的存储空间和更强的处理能力） ，它可以分布在计算机网络中的其他节点上这就是所谓的分片。<br>Mongo支持丰富的查询表达式。查询指令使用JSON形式的标记，可轻易查询文档中内嵌的对象及数组。<br>MongoDb 使用update()命令可以实现替换完成的文档（数据）或者一些指定的数据字段 。<br>Mongodb中的Map&#x2F;reduce主要是用来对数据进行批量处理和聚合操作。<br>Map和Reduce。Map函数调用emit(key,value)遍历集合中所有的记录，将key与value传给Reduce函数进行处理。<br>Map函数和Reduce函数是使用Javascript编写的，并可以通过db.runCommand或mapreduce命令来执行MapReduce操作。<br>GridFS是MongoDB中的一个内置功能，可以用于存放大量小文件。<br>MongoDB允许在服务端执行脚本，可以用Javascript编写某个函数，直接在服务端执行，也可以把函数的定义存储在服务端，下次直接调用即可。<br>MongoDB支持各种编程语言:RUBY，PYTHON，JAVA，C++，PHP，C#等多种语言。<br>MongoDB安装简单。</p>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p>显示所有数据的列表：show dbs<br>显示当前数据库对象或集合：db<br>连接到一个指定的数据库：use 库名 </p>
<h3 id="常见概念"><a href="#常见概念" class="headerlink" title="常见概念"></a>常见概念</h3><h4 id="1-数据库命名规则"><a href="#1-数据库命名规则" class="headerlink" title="1.数据库命名规则"></a>1.数据库命名规则</h4><p>不能是空字符串（””)。<br>不得含有’ ‘（空格)、.、$、&#x2F;、\和\0 (空字符)。<br>应全部小写。<br>最多64字节。</p>
<h4 id="2-RDBMS-与-MongoDB-对应的术语"><a href="#2-RDBMS-与-MongoDB-对应的术语" class="headerlink" title="2.RDBMS 与 MongoDB 对应的术语"></a>2.RDBMS 与 MongoDB 对应的术语</h4><p>数据库	数据库<br>表格	集合<br>行	文档<br>列	字段<br>表联合	嵌入文档<br>主键	主键 (MongoDB 提供了 key 为 _id )</p>
<h4 id="3-文档键命名规则"><a href="#3-文档键命名规则" class="headerlink" title="3.文档键命名规则"></a>3.文档键命名规则</h4><p>键不能含有\0 (空字符)。这个字符用来表示键的结尾。<br>.和$有特别的意义，只有在特定环境下才能使用。<br>以下划线”_”开头的键是保留的(不是严格要求的)。<br>注：<br>文档中的键&#x2F;值对是有序的。<br>文档中的值不仅可以是在双引号里面的字符串，还可以是其他几种数据类型（甚至可以是整个嵌入的文档)。<br>MongoDB区分类型和大小写。<br>MongoDB的文档不能有重复的键。<br>文档的键是字符串。除了少数例外情况，键可以使用任意UTF-8字符。</p>
<h4 id="4-集合命名规则"><a href="#4-集合命名规则" class="headerlink" title="4.集合命名规则"></a>4.集合命名规则</h4><p>集合名不能是空字符串””。<br>集合名不能含有\0字符（空字符)，这个字符表示集合名的结尾。<br>集合名不能以”system.”开头，这是为系统集合保留的前缀。<br>用户创建的集合名字不能含有保留字符。有些驱动程序的确支持在集合名里面包含，这是因为某些系统生成的集合中包含该字符。除非你要访问这种系统创建的集合，否则千万不要在名字里出现$。　</p>
<h4 id="5-MongoDB-数据类型"><a href="#5-MongoDB-数据类型" class="headerlink" title="5.MongoDB 数据类型"></a>5.MongoDB 数据类型</h4><p>String	字符串。存储数据常用的数据类型。在 MongoDB 中，UTF-8 编码的字符串才是合法的。<br>Integer	整型数值。用于存储数值。根据你所采用的服务器，可分为 32 位或 64 位。<br>Boolean	布尔值。用于存储布尔值（真&#x2F;假）。<br>Double	双精度浮点值。用于存储浮点值。<br>Min&#x2F;Max keys	将一个值与 BSON（二进制的 JSON）元素的最低值和最高值相对比。<br>Array	用于将数组或列表或多个值存储为一个键。<br>Timestamp	时间戳。记录文档修改或添加的具体时间。<br>Object	用于内嵌文档。<br>Null	用于创建空值。<br>Symbol	符号。该数据类型基本上等同于字符串类型，但不同的是，它一般用于采用特殊符号类型的语言。<br>Date	日期时间。用 UNIX 时间格式来存储当前日期或时间。你可以指定自己的日期时间：创建 Date 对象，传入年月日信息。<br>Object ID	对象 ID。用于创建文档的 ID。<br>Binary Data	二进制数据。用于存储二进制数据。<br>Code	代码类型。用于在文档中存储 JavaScript 代码。<br>Regular expression	正则表达式类型。用于存储正则表达式。</p>
<h4 id="6-元数据"><a href="#6-元数据" class="headerlink" title="6.元数据"></a>6.元数据</h4><p>数据库的信息是存储在集合中，它们使用了系统的命名空间：dbname.system.*</p>
<h3 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h3><blockquote>
<p>创建数据库：use DATABASE_NAME</p>
<blockquote>
<p>注：在 MongoDB 中，集合只有在内容插入后才会创建! 就是说，创建集合(数据表)后要再插入一个文档(记录)，集合才会真正创建。</p>
</blockquote>
</blockquote>
<blockquote>
<p>查看所有数据库：show dbs<br>删除数据库：db.dropDatabase()</p>
</blockquote>
<h3 id="集合操作"><a href="#集合操作" class="headerlink" title="集合操作"></a>集合操作</h3><blockquote>
<p>创建集合：db.createCollection(“name”, {options}) </p>
<blockquote>
<p>options: capped	autoIndexId	 size	max	</p>
</blockquote>
</blockquote>
<blockquote>
<p>查看当前集合：show collections 或  show tables<br>删除集合：db.collection.drop()</p>
</blockquote>
<p>注：在 MongoDB 中，你不需要创建集合。当你插入一些文档时，MongoDB 会自动创建集合。</p>
<h3 id="文档操作"><a href="#文档操作" class="headerlink" title="文档操作"></a>文档操作</h3><h4 id="1-插入文档："><a href="#1-插入文档：" class="headerlink" title="1.插入文档："></a>1.插入文档：</h4><blockquote>
<p>方式一：db.COLLECTION_NAME.insert(document)<br>方式二：db.COLLECTION_NAME.save(document)</p>
</blockquote>
<p>save()：如果 _id 主键存在则更新数据，如果不存在就插入数据。该方法新版本中已废弃，可以使用 db.collection.insertOne() 或 db.collection.replaceOne() 来代替。<br>insert(): 若插入的数据主键已经存在，则会抛 org.springframework.dao.DuplicateKeyException 异常，提示主键重复，不保存当前数据。<br>3.2 版本之后：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方式三：</span><br><span class="line">db.collection.insertOne(</span><br><span class="line">   &lt;document&gt;,</span><br><span class="line">   &#123;</span><br><span class="line">      writeConcern: &lt;document&gt;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br><span class="line">方式四：</span><br><span class="line">db.collection.insertMany(</span><br><span class="line">   [ &lt;document 1&gt; , &lt;document 2&gt;, ... ],</span><br><span class="line">   &#123;</span><br><span class="line">      writeConcern: &lt;document&gt;,</span><br><span class="line">      ordered: &lt;boolean&gt;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h4 id="2-更新文档"><a href="#2-更新文档" class="headerlink" title="2.更新文档"></a>2.更新文档</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方式一：</span><br><span class="line">db.collection.update(</span><br><span class="line">   &lt;query&gt;,</span><br><span class="line">   &lt;update&gt;,</span><br><span class="line">   &#123;</span><br><span class="line">     upsert: &lt;boolean&gt;,</span><br><span class="line">     multi: &lt;boolean&gt;,</span><br><span class="line">     writeConcern: &lt;document&gt;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>参数说明：<br>query : update的查询条件，类似sql update查询内where后面的。<br>update : update的对象和一些更新的操作符（如$,$inc…）等，也可以理解为sql update查询内set后面的<br>upsert : 可选，这个参数的意思是，如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入。<br>multi : 可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。<br>writeConcern :可选，抛出异常的级别。</p>
<blockquote>
<p>方式二：使用save()方法，并指定要替换的文档主键_id</p>
</blockquote>
<h4 id="3-删除文档"><a href="#3-删除文档" class="headerlink" title="3.删除文档"></a>3.删除文档</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方式一：</span><br><span class="line">db.collection.remove(</span><br><span class="line">   &lt;query&gt;,</span><br><span class="line">   &lt;justOne&gt;</span><br><span class="line">)</span><br><span class="line">MongoDB 是 2.6 版本以后：</span><br><span class="line">db.collection.remove(</span><br><span class="line">   &lt;query&gt;,</span><br><span class="line">   &#123;</span><br><span class="line">     justOne: &lt;boolean&gt;,</span><br><span class="line">     writeConcern: &lt;document&gt;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>参数说明：<br>query :（可选）删除的文档的条件。<br>justOne : （可选）如果设为 true 或 1，则只删除一个文档，如果不设置该参数，或使用默认值 false，则删除所有匹配条件的文档。<br>writeConcern :（可选）抛出异常的级别。</p>
<p>删除所有数据: db.collection.remove({}) （类似常规 SQL 的 truncate 命令）</p>
<h4 id="4-查看文档"><a href="#4-查看文档" class="headerlink" title="4.查看文档"></a>4.查看文档</h4><p>查询文档: db.collection.find(query, projection)<br>查询一个文档：db.collection.findOne()<br>以格式化的方式来显示所有文档: db.collection.find().pretty()</p>
<h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><h4 id="1-MongoDB-与-RDBMS-Where-语句比较"><a href="#1-MongoDB-与-RDBMS-Where-语句比较" class="headerlink" title="1.MongoDB 与 RDBMS Where 语句比较"></a>1.MongoDB 与 RDBMS Where 语句比较</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">等于	&#123;&lt;key&gt;:&lt;value&gt;&#125;	db.col.find(&#123;&quot;by&quot;:&quot;菜鸟教程&quot;&#125;).pretty()	where by = &#x27;菜鸟教程&#x27;</span><br><span class="line">小于	&#123;&lt;key&gt;:&#123;$lt:&lt;value&gt;&#125;&#125;	db.col.find(&#123;&quot;likes&quot;:&#123;$lt:50&#125;&#125;).pretty()	where likes &lt; 50</span><br><span class="line">小于或等于	&#123;&lt;key&gt;:&#123;$lte:&lt;value&gt;&#125;&#125;	db.col.find(&#123;&quot;likes&quot;:&#123;$lte:50&#125;&#125;).pretty()	where likes &lt;= 50</span><br><span class="line">大于	&#123;&lt;key&gt;:&#123;$gt:&lt;value&gt;&#125;&#125;	db.col.find(&#123;&quot;likes&quot;:&#123;$gt:50&#125;&#125;).pretty()	where likes &gt; 50</span><br><span class="line">大于或等于	&#123;&lt;key&gt;:&#123;$gte:&lt;value&gt;&#125;&#125;	db.col.find(&#123;&quot;likes&quot;:&#123;$gte:50&#125;&#125;).pretty()	where likes &gt;= 50</span><br><span class="line">不等于	&#123;&lt;key&gt;:&#123;$ne:&lt;value&gt;&#125;&#125;	db.col.find(&#123;&quot;likes&quot;:&#123;$ne:50&#125;&#125;).pretty()	where likes != 50</span><br></pre></td></tr></table></figure>
<h4 id="2-MongoDB-AND-条件"><a href="#2-MongoDB-AND-条件" class="headerlink" title="2.MongoDB AND 条件"></a>2.MongoDB AND 条件</h4><p>MongoDB 的 find() 方法可以传入多个键(key)，每个键(key)以逗号隔开，即常规 SQL 的 AND 条件</p>
<blockquote>
<p>db.col.find({key1:value1, key2:value2}).pretty()</p>
</blockquote>
<h4 id="3-MongoDB-OR-条件"><a href="#3-MongoDB-OR-条件" class="headerlink" title="3.MongoDB OR 条件"></a>3.MongoDB OR 条件</h4><p>MongoDB OR 条件语句使用了关键字 $or</p>
<blockquote>
<p>db.col.find({$or: [{key1: value1}, {key2:value2}]}).pretty()</p>
</blockquote>
<h3 id="type-操作符"><a href="#type-操作符" class="headerlink" title="$type 操作符"></a>$type 操作符</h3><blockquote>
<p>Double	1	<br>String	2	<br>Object	3	<br>Array	4	<br>Binary data	5	<br>Undefined	6	已废弃。<br>Object id	7	<br>Boolean	8	<br>Date	9	<br>Null	10	<br>Regular Expression	11	<br>JavaScript	13	<br>Symbol	14	<br>JavaScript (with scope)	15	<br>32-bit integer	16	<br>Timestamp	17	<br>64-bit integer	18	<br>Min key	255	Query with -1.<br>Max key	127</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">想获取 &quot;col&quot; 集合中 title 为 String 的数据:</span><br><span class="line">db.col.find(&#123;&quot;title&quot; : &#123;$type : 2&#125;&#125;)</span><br><span class="line">或</span><br><span class="line">db.col.find(&#123;&quot;title&quot; : &#123;$type : &#x27;string&#x27;&#125;&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="Limit与Skip方法"><a href="#Limit与Skip方法" class="headerlink" title="Limit与Skip方法"></a>Limit与Skip方法</h3><h4 id="1-Limit-：读取指定数量的数据记录"><a href="#1-Limit-：读取指定数量的数据记录" class="headerlink" title="1.Limit()：读取指定数量的数据记录"></a>1.Limit()：读取指定数量的数据记录</h4><blockquote>
<p>db.COLLECTION_NAME.find().limit(NUMBER)</p>
</blockquote>
<h4 id="2-Skip-方法：跳过指定数量的数据"><a href="#2-Skip-方法：跳过指定数量的数据" class="headerlink" title="2.Skip() 方法：跳过指定数量的数据"></a>2.Skip() 方法：跳过指定数量的数据</h4><blockquote>
<p>db.COLLECTION_NAME.find().limit(NUMBER).skip(NUMBER)</p>
</blockquote>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>使用 sort() 方法对数据进行排序，sort() 方法可以通过参数指定排序的字段，并使用 1 和 -1 来指定排序的方式，其中 1 为升序排列，而 -1 是用于降序排列。</p>
<blockquote>
<p>db.COLLECTION_NAME.find().sort({KEY:1})</p>
</blockquote>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><blockquote>
<p>创建索引：db.collection.createIndex(keys, options)<br>查看集合索引：db.col.getIndexes()<br>查看集合索引大小：db.col.totalIndexSize()<br>删除集合所有索引：db.col.dropIndexes()<br>删除集合指定索引：db.col.dropIndex(“索引名称”)</p>
</blockquote>
<p>Key 值为你要创建的索引字段，1 为指定按升序创建索引，如果你想按降序来创建索引指定为 -1<br>注：<br>在 3.0.0 版本前创建索引方法为 db.collection.ensureIndex()，之后的版本使用了 db.collection.createIndex() 方法，ensureIndex() 还能用，但只是 createIndex() 的别名。</p>
<p>参数说明：<br>background	Boolean	建索引过程会阻塞其它数据库操作，background可指定以后台方式创建索引，即增加 “background” 可选参数。 “background” 默认值为false。<br>unique	Boolean	建立的索引是否唯一。指定为true创建唯一索引。默认值为false.<br>name	string	索引的名称。如果未指定，MongoDB的通过连接索引的字段名和排序顺序生成一个索引名称。<br>dropDups	Boolean	3.0+版本已废弃。在建立唯一索引时是否删除重复记录,指定 true 创建唯一索引。默认值为 false.<br>sparse	Boolean	对文档中不存在的字段数据不启用索引；这个参数需要特别注意，如果设置为true的话，在索引字段中不会查询出不包含对应字段的文档.。默认值为 false.<br>expireAfterSeconds	integer	指定一个以秒为单位的数值，完成 TTL设定，设定集合的生存时间。<br>v	index version	索引的版本号。默认的索引版本取决于mongod创建索引时运行的版本。<br>weights	document	索引权重值，数值在 1 到 99,999 之间，表示该索引相对于其他索引字段的得分权重。<br>default_language	string	对于文本索引，该参数决定了停用词及词干和词器的规则的列表。 默认为英语<br>language_override	string	对于文本索引，该参数指定了包含在文档中的字段名，语言覆盖默认的language，默认值为 language.</p>
<h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><p>MongoDB中聚合的方法使用aggregate()，类似 SQL 语句中的 count(*)</p>
<blockquote>
<p>db.COLLECTION_NAME.aggregate(AGGREGATE_OPERATION)</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$sum	计算总和。	db.mycol.aggregate([&#123;$group : &#123;_id : &quot;$by_user&quot;, num_tutorial : &#123;$sum : &quot;$likes&quot;&#125;&#125;&#125;])</span><br><span class="line">$avg	计算平均值	db.mycol.aggregate([&#123;$group : &#123;_id : &quot;$by_user&quot;, num_tutorial : &#123;$avg : &quot;$likes&quot;&#125;&#125;&#125;])</span><br><span class="line">$min	获取集合中所有文档对应值得最小值。	db.mycol.aggregate([&#123;$group : &#123;_id : &quot;$by_user&quot;, num_tutorial : &#123;$min : &quot;$likes&quot;&#125;&#125;&#125;])</span><br><span class="line">$max	获取集合中所有文档对应值得最大值。	db.mycol.aggregate([&#123;$group : &#123;_id : &quot;$by_user&quot;, num_tutorial : &#123;$max : &quot;$likes&quot;&#125;&#125;&#125;])</span><br><span class="line">$push	将值加入一个数组中，不会判断是否有重复的值。	db.mycol.aggregate([&#123;$group : &#123;_id : &quot;$by_user&quot;, url : &#123;$push: &quot;$url&quot;&#125;&#125;&#125;])</span><br><span class="line">$addToSet	将值加入一个数组中，会判断是否有重复的值，若相同的值在数组中已经存在了，则不加入。	db.mycol.aggregate([&#123;$group : &#123;_id : &quot;$by_user&quot;, url : &#123;$addToSet : &quot;$url&quot;&#125;&#125;&#125;])</span><br><span class="line">$first	根据资源文档的排序获取第一个文档数据。	db.mycol.aggregate([&#123;$group : &#123;_id : &quot;$by_user&quot;, first_url : &#123;$first : &quot;$url&quot;&#125;&#125;&#125;])</span><br><span class="line">$last	根据资源文档的排序获取最后一个文档数据</span><br></pre></td></tr></table></figure>

<h3 id="复制-副本集"><a href="#复制-副本集" class="headerlink" title="复制(副本集)"></a>复制(副本集)</h3><h4 id="1-复制原理："><a href="#1-复制原理：" class="headerlink" title="1.复制原理："></a>1.复制原理：</h4><p>mongodb的复制至少需要两个节点。其中一个是主节点，负责处理客户端请求，其余的都是从节点，负责复制主节点上的数据。<br>mongodb各个节点常见的搭配方式为：一主一从、一主多从。<br>主节点记录在其上的所有操作oplog，从节点定期轮询主节点获取这些操作，然后对自己的数据副本执行这些操作，从而保证从节点的数据与主节点一致。</p>
<h4 id="2-副本集设置"><a href="#2-副本集设置" class="headerlink" title="2.副本集设置"></a>2.副本集设置</h4><p>关闭正在运行的MongoDB服务器：mongod –port “PORT” –dbpath “YOUR_DB_DATA_PATH” –replSet “REPLICA_SET_INSTANCE_NAME”</p>
<blockquote>
<p>启动一个新的副本集：rs.initiate()<br>查看副本集的配置：rs.conf()<br>查看副本集状态： rs.status()<br>添加成员：rs.add(HOST_NAME:PORT)<br>判断当前运行的Mongo服务是否为主节点：db.isMaster() </p>
</blockquote>
<p>注：MongoDB的副本集与我们常见的主从有所不同，主从在主机宕机后所有服务将停止，而副本集在主机宕机后，副本会接管主节点成为主节点，不会出现宕机的情况。</p>
<h3 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h3><h4 id="1-为什么使用分片？"><a href="#1-为什么使用分片？" class="headerlink" title="1.为什么使用分片？"></a>1.为什么使用分片？</h4><p>复制所有的写入操作到主节点<br>延迟的敏感数据会在主节点查询<br>单个副本集限制在12个节点<br>当请求量巨大时会出现内存不足。<br>本地磁盘不足<br>垂直扩展价格昂贵</p>
<h4 id="2-分片的主要组件"><a href="#2-分片的主要组件" class="headerlink" title="2.分片的主要组件"></a>2.分片的主要组件</h4><p>Shard:<br>用于存储实际的数据块，实际生产环境中一个shard server角色可由几台机器组个一个replica set承担，防止主机单点故障<br>Config Server:<br>mongod实例，存储了整个 ClusterMetadata，其中包括 chunk信息。<br>Query Routers:<br>前端路由，客户端由此接入，且让整个集群看上去像单一数据库，前端应用可以透明使用。</p>
<h3 id="备份-mongodump-与恢复-mongorestore"><a href="#备份-mongodump-与恢复-mongorestore" class="headerlink" title="备份(mongodump)与恢复(mongorestore)"></a>备份(mongodump)与恢复(mongorestore)</h3><h4 id="1-数据备份"><a href="#1-数据备份" class="headerlink" title="1.数据备份"></a>1.数据备份</h4><p>使用mongodump命令来备份MongoDB数据。该命令可以导出所有数据到指定目录中。<br>mongodump命令可以通过参数指定导出的数据量级转存的服务器。</p>
<blockquote>
<p>mongodump -h dbhost -d dbname -o dbdirectory</p>
</blockquote>
<p>参数说明：<br>-h：<br>MongoDB 所在服务器地址，例如：127.0.0.1，当然也可以指定端口号：127.0.0.1:27017<br>-d：<br>需要备份的数据库实例，例如：test<br>-o：<br>备份的数据存放位置，例如：c:\data\dump，当然该目录需要提前建立，在备份完成后，系统自动在dump目录下建立一个test目录，这个目录里面存放该数据库实例的备份数据。</p>
<h4 id="2-数据恢复"><a href="#2-数据恢复" class="headerlink" title="2.数据恢复"></a>2.数据恢复</h4><p>使用 mongorestore 命令来恢复备份的数据。</p>
<blockquote>
<p>mongorestore -h &lt;hostname&gt;&lt;:port&gt; -d dbname &lt;path&gt;</p>
</blockquote>
<p>参数说明：<br>-host &lt;:port&gt;, -h &lt;:port&gt;：<br>MongoDB所在服务器地址，默认为： localhost:27017<br>–db , -d ：<br>需要恢复的数据库实例，例如：test，当然这个名称也可以和备份时候的不一样，比如test2<br>–drop：<br>恢复的时候，先删除当前数据，然后恢复备份的数据。就是说，恢复后，备份后添加修改的数据都会被删除，慎用哦！<br>&lt;path&gt;：<br>mongorestore 最后的一个参数，设置备份数据所在位置，例如：c:\data\dump\test。<br>你不能同时指定 &lt;path&gt; 和 –dir 选项，–dir也可以设置备份目录。<br>–dir：<br>指定备份的目录<br>你不能同时指定 &lt;path&gt; 和 –dir 选项。</p>
<h3 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h3><p>MongoDB中提供了mongostat 和 mongotop 两个命令来监控MongoDB的运行情况。</p>
<p>mongostat是mongodb自带的状态检测工具，在命令行下使用。它会间隔固定时间获取mongodb的当前运行状态，并输出。如果你发现数据库突然变慢或者有其他问题的话，你第一手的操作就考虑采用mongostat来查看mongo的状态。<br>启动你的Mongod服务，进入到你安装的MongoDB目录下的bin目录， 然后输入mongostat命令，如下所示：</p>
<blockquote>
<p>$ D:\set up\mongodb\bin&gt;mongostat</p>
</blockquote>
<p>mongotop也是mongodb下的一个内置工具，mongotop提供了一个方法，用来跟踪一个MongoDB的实例，查看哪些大量的时间花费在读取和写入数据。 mongotop提供每个集合的水平的统计数据。默认情况下，mongotop返回值的每一秒。<br>启动你的Mongod服务，进入到你安装的MongoDB目录下的bin目录， 然后输入mongotop命令，如下所示：</p>
<blockquote>
<p>$ D:\set up\mongodb\bin&gt;mongotop</p>
</blockquote>
<hr>
<p>😊END</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库调优策略</title>
    <url>/posts/77699b9e.html</url>
    <content><![CDATA[<h3 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h3><h4 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h4><p>explain可用来分析SQL的执行计划</p>
<h4 id="用法："><a href="#用法：" class="headerlink" title="用法："></a>用法：</h4><p>explain sql语句<br>explain extended sql语句<br>-会在 explain 的基础上额外提供一些查询优化的信息。紧随其后通过 show warnings 命令可以得到优化后的查询语句，从而看出优化器优化了什么<br>explain partitions sql语句<br>-相比 explain 多了个 partitions 字段，如果查询是基于分区表的话，会显示查询将访问的分区。</p>
<h4 id="explain字段含义"><a href="#explain字段含义" class="headerlink" title="explain字段含义:"></a>explain字段含义:</h4><h5 id="10个字段："><a href="#10个字段：" class="headerlink" title="10个字段："></a>10个字段：</h5><p>id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |</p>
<h5 id="id"><a href="#id" class="headerlink" title="id"></a>id</h5><p>该语句的唯一标识。如果explain的结果包括多个id值，则数字越大越先执行；而对于相同id的行，则表示从上往下依次执行。</p>
<h5 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h5><p>表示对应行是是简单还是复杂的查询，如果是复杂的查询，又是上述三种复杂查询中的哪一种。<br>1）simple：简单查询。查询不包含子查询和union<br>2）primary：复杂查询中最外层的 select<br>3）subquery：包含在 select 中的子查询（不在 from 子句中）<br>4）derived：包含在 from 子句中的子查询。MySQL会将结果存放在一个临时表中，也称为派生表（derived的英文含义）<br>5）union：在 union 中的第二个和随后的 select<br>6）union result：从 union 临时表检索结果的 select</p>
<h5 id="table"><a href="#table" class="headerlink" title="table"></a>table</h5><p>表示 explain 的这一行正在访问哪个表。<br>当 from 子句中有子查询时，table列是 <derivenN> 格式，表示当前查询依赖 id&#x3D;N 的查询，于是先执行 id&#x3D;N 的查询。<br>当有 union 时，UNION RESULT 的 table 列的值为 &lt;union1,2&gt;，1和2表示参与 union 的 select 行id。</p>
<h5 id="type"><a href="#type" class="headerlink" title="type"></a>type</h5><p>表示关联类型或访问类型，即MySQL决定如何查找表中的行。<br>依次从最优到最差分别为：<br>system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</p>
<h5 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h5><p>显示查询可能使用哪些索引来查找。<br>explain 时可能出现 possible_keys 有列，而 key 显示 NULL 的情况，这种情况是因为表中数据不多，mysql认为索引对此查询帮助不大，选择了全表查询。<br>如果该列是NULL，则没有相关的索引。在这种情况下，可以通过检查 where 子句看是否可以创造一个适当的索引来提高查询性能，然后用 explain 查看效果。</p>
<h5 id="key"><a href="#key" class="headerlink" title="key"></a>key</h5><p>显示mysql实际采用哪个索引来优化对该表的访问。<br>如果没有使用索引，则该列是 NULL。如果想强制mysql使用或忽视possible_keys列中的索引，在查询中使用 force index、ignore index。</p>
<h5 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h5><p>显示了mysql在索引里使用的字节数，通过这个值可以算出具体使用了索引中的哪些列。</p>
<h5 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h5><p>显示了在key列记录的索引中，表查找值所用到的列或常量，常见的有：const（常量），func，NULL，字段名（例：film.id）</p>
<h5 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h5><p>mysql估计要读取并检测的行数，注意这个不是结果集里的行数。</p>
<h5 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h5><p>展示的是额外信息。常见的重要值如下：<br>distinct: 一旦mysql找到了与行相联合匹配的行，就不再搜索了<br>Using index：这发生在对表的请求列都是同一索引的部分的时候，返回的列数据只使用了索引中的信息，而没有再去访问表中的行记录。是性能高的表现。<br>Using where：mysql服务器将在存储引擎检索行后再进行过滤。就是先读取整行数据，再按 where 条件进行检查，符合就留下，不符合就丢弃。<br>Using temporary：mysql需要创建一张临时表来处理查询。出现这种情况一般是要进行优化的，首先是想到用索引来优化。<br>Using filesort：mysql 会对结果使用一个外部索引排序，而不是按索引次序从表里读取行。此时mysql会根据联接类型浏览所有符合条件的记录，并保存排序关键字和行指针，然后排序关键字并按顺序检索行信息。这种情况下一般也是要考虑使用索引来优化的。</p>
<h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>定义：<br>只需要在一棵索引树上就能获取SQL所需的所有列数据，无需回表，速度更快。mysql执行计划explain结果里的key有使用索引，如果select后面查询的字段都可以从这个索引的树中获取，这种情况一般可以说是用到了覆盖索引，<em>extra里一般都有using index</em>；覆盖索引一般针对的是辅助索引，整个查询结果只通过辅助索引就能拿到结果，不需要通过辅助索引树找到主键，再通过主键去主键索引树里获取其它字段值。<br>实现：<br>将被查询的字段，建立到联合索引里去。</p>
<h3 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h3><p>定义：<br>ALTER TABLE <code>table_name</code> ADD INDEX (<code>col1</code>,<code>col2</code>,<code>col3</code>);<br>注：当创建(col1,col2,col3)联合索引时，相当于创建了(col)单列索引，(clo1,clo2)联合索引以及(col1,col2,col3)联合索引想要索引生效，只能使用col1和col1,col2和col1,col2,col3三种组合；当然，col1,col3组合也可以，但实际上只用到了col1的索引，col3并没有用到！</p>
<h3 id="最左匹配原则"><a href="#最左匹配原则" class="headerlink" title="最左匹配原则"></a>最左匹配原则</h3><p>定义：<br>在MySQL建立联合索引时会遵守最左前缀匹配原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。</p>
<h3 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h3><p>定义：<br>索引下推的下推其实就是指将部分上层（服务层）负责的事情，交给了下层（引擎层）去处理。<br>注：索引下推是MySQL 5.6版本的新特性<br>使用条件：<br>只能用于range、 ref、 eq_ref、ref_or_null访问方法；<br>只能用于InnoDB和 MyISAM存储引擎及其分区表；<br>对InnoDB存储引擎来说，索引下推只适用于二级索引（也叫辅助索引）;</p>
<h3 id="唯一索引普通索引选择难题"><a href="#唯一索引普通索引选择难题" class="headerlink" title="唯一索引普通索引选择难题"></a>唯一索引普通索引选择难题</h3><p>change buffer的作用：<br>对非唯一的二级索引进行DML（删除行、写入行、修改行）操作时作出的优化逻辑<br>change buffer的主要目的：<br>将记录的变更动作缓存下来，所以在一个数据页做merge之前，change buffer记录的变更越多（也就是这个页面上要更新的次数越多），收益就越大。<br>因此，对于写多读少的业务来说，页面在写完以后马上被访问到的概率比较小，此时change buffer的使用效果最好，这种业务模型常见的就是账单类、日志类的系统。</p>
<h3 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h3><p>我们存在邮箱作为用户名的情况，每个人的邮箱都是不一样的，那我们是不是可以在邮箱上建立索引，但是邮箱这么长，我们怎么去建立索引呢？<br>MySQL是支持前缀索引的，也就是说，你可以定义字符串的一部分作为索引。默认地，如果你创建索引的语句不指定前缀长度，那么索引就会包含整个字符串。<br>❓很长的字段，想做索引我们怎么去优化他呢？<br>答：建立一个区分度很高的前缀索引</p>
<h3 id="条件字段函数操作"><a href="#条件字段函数操作" class="headerlink" title="条件字段函数操作"></a>条件字段函数操作</h3><p>对索引字段做函数操作，可能会破坏索引值的有序性，因此优化器就决定放弃走树搜索功能。</p>
<h3 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h3><p>select * from t where id &#x3D; 1<br>如果id是字符类型的，1是数字类型的，你用explain会发现走了全表扫描，根本用不上索引，为啥呢？<br>因为MySQL底层会对你的比较进行转换，相当于加了 CAST( id AS signed int) 这样的一个函数，上面说过函数会导致走不上索引。</p>
<h3 id="隐式字符编码转换"><a href="#隐式字符编码转换" class="headerlink" title="隐式字符编码转换"></a>隐式字符编码转换</h3><p>如果两个表的字符集不一样，一个是utf8mb4，一个是utf8，因为utf8mb4是utf8的超集，所以一旦两个字符比较，就会转换为utf8mb4再比较。<br>转换的过程相当于加了CONVERT(id USING utf8mb4)函数，那又回到上面的问题了，用到函数就用不上索引了。</p>
<h3 id="flush"><a href="#flush" class="headerlink" title="flush"></a>flush</h3><p>定义：<br>redo log总会找个时间去更新到磁盘，这个操作就是flush。<br>在更新之前，当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为“脏页”。<br>内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为“干净页“。<br>什么时候会flush：<br>InnoDB的redo log写满了，这时候系统会停止所有更新操作，把checkpoint往前推进，redo log留出空间可以继续写。<br>系统内存不足，当需要新的内存页，而内存不够用的时候，就要淘汰一些数据页，空出内存给别的数据页使用。如果淘汰的是“脏页”，就要先将脏页写到磁盘。<br>把握flush的时机：<br>正确地告诉InnoDB所在主机的IO能力，这样InnoDB才能知道需要全力刷脏页的时候，可以刷多快。要用到innodb_io_capacity这个参数了，它会告诉InnoDB你的磁盘能力，这个值建议设置成磁盘的IOPS，磁盘的IOPS可以通过fio这个工具来测试。</p>
<hr>
<p>🥰END</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库调优</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring入门</title>
    <url>/posts/421a3e14.html</url>
    <content><![CDATA[<h3 id="Spring简介"><a href="#Spring简介" class="headerlink" title="Spring简介"></a>Spring简介</h3><p>Spring是一个分层的Java SE&#x2F;EE应用一站式的轻量级开源框架。Spring核心是IOC和AOP<br>Spring主要优点包括：<br>方便解耦，简化开发，通过Spring提供的IoC容器，我们可以将对象之间的依赖关系交由Spring进行控制，避免硬编码造成的程序耦合度高。<br>AOP编程的支持，通过Spring提供的AOP功能，方便进行面向切面编程。<br>声明式事务的支持，在Spring中，我们可以从单调烦闷的事务管理代码中解脱出来，通过声明式方式灵活地进行事务的管理，提高开发效率和质量。<br>方便程序的测试，可以用非容器依赖的编程方式进行几乎所有的测试工作。<br>方便集成各种优秀框架，Spring提供了对各种优秀框架的直接支持。</p>
<h3 id="Spring体系结构"><a href="#Spring体系结构" class="headerlink" title="Spring体系结构"></a>Spring体系结构</h3><p>Spring 框架是一个分层架构，整个spring框架按其所属功能可以划分为五个主要模块。<br>这些模块分为<br>Rore Container ： Beans Core Context Expression Language<br>Date Access&#x2F;Integration ：JDBC ORM OXM JMS Transactions<br>Web ：Web Servlet Portlet Struts<br>AOP(Aspect Oriented Programming)<br>Instrumentation<br>test</p>
<h4 id="核心模块-Core-Container"><a href="#核心模块-Core-Container" class="headerlink" title="核心模块(Core Container)"></a>核心模块(Core Container)</h4><p>Spring的核心模块实现了IoC的功能，它将类和类之间的依赖从代码中脱离出来，用配置的方式进行依赖关系描述。由IoC容器负责类的创建，管理，获取等。BeanFactory接口是Spring框架的核心接口，实现了容器很多核心的功能。<br>Context模块构建于核心模块之上，扩展了BeanFactory的功能，包括国际化，资源加载，邮件服务，任务调度等多项功能。ApplicationContext是Context模块的核心接口。<br>表达式语言(Expression Language)是统一表达式语言(EL)的一个扩展，支持设置和获取对象属性，调用对象方法，操作数组、集合等。使用它可以很方便的通过表达式和Spring IoC容器进行交互。</p>
<h4 id="AOP模块"><a href="#AOP模块" class="headerlink" title="AOP模块"></a>AOP模块</h4><p>Spring AOP模块提供了满足AOP Alliance规范的实现，还整合了AspectJ这种AOP语言级的框架。通过AOP能降低耦合。</p>
<h4 id="数据访问集成模块（Data-Access-x2F-Integration-）"><a href="#数据访问集成模块（Data-Access-x2F-Integration-）" class="headerlink" title="数据访问集成模块（Data Access&#x2F;Integration ）"></a>数据访问集成模块（Data Access&#x2F;Integration ）</h4><p>该模块包括了JDBC、ORM、OXM、JMS和事务管理：<br>事务模块：该模块用于Spring管理事务，只要是Spring管理对象都能得到Spring管理事务的好处，无需在代码中进行事务控制了，而且支持编程和声明性的事务管理。<br>JDBC模块：提供了一个JBDC的样例模板，使用这些模板能消除传统冗长的JDBC编码还有必须的事务控制，而且能享受到Spring管理事务的好处。<br>ORM模块：提供与流行的“对象-关系”映射框架的无缝集成，包括hibernate、JPA、MyBatis等。而且可以使用Spring事务管理，无需额外控制事务。<br>OXM模块：提供了一个对Object&#x2F;XML映射实现，将Java对象映射成XML数据，或者将XML数据映射成java对象，Object&#x2F;XML映射实现包括JAXB、Castor、XMLBeans和XStream。<br>JMS模块：用于JMS(Java Messaging Service)，提供一套“消息生产者、消息消费者”模板用于更加简单的使用JMS，JMS用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。</p>
<h4 id="Web模块"><a href="#Web模块" class="headerlink" title="Web模块"></a>Web模块</h4><p>该模块建立在ApplicationContext模块之上，提供了Web应用的功能，如文件上传、FreeMarker等。Spring可以整合Struts2等MVC框架。此外，Spring自己提供了MVC框架Spring MVC。</p>
<h4 id="测试模块"><a href="#测试模块" class="headerlink" title="测试模块"></a>测试模块</h4><p>Spring可以用非容器依赖的编程方式进行几乎所有的测试工作，支持JUnit和TestNG等测试框架。</p>
<h3 id="初识IOC与DI"><a href="#初识IOC与DI" class="headerlink" title="初识IOC与DI"></a>初识IOC与DI</h3><h4 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h4><p>IoC(控制反转:Inverse of Control)是Spring容器的核心<br>DI（依赖注入：Dependency Injection）</p>
<h4 id="控制反转与依赖注入："><a href="#控制反转与依赖注入：" class="headerlink" title="控制反转与依赖注入："></a>控制反转与依赖注入：</h4><p>传统程序设计中，我们需要使用某个对象的方法，需要先通过new创建一个该对象，我们这时是主动行为；而IoC是我们将创建对象的控制权交给IoC容器，这时是由容器帮忙创建及注入依赖对象，我们的程序被动的接受IoC容器创建的对象，控制权反转，所以叫控制反转。<br>IoC是目的，DI是手段，创建对象的过程往往意味着依赖的注入。我们为了实现IoC，让生成对象的方式由传统方式(new)反转过来，需要创建相关对象时由IoC容器帮我们注入(DI)。<br>简单的说，就是我们类里需要另一个类，只需要让Spring帮我们创建 ，这叫做控制反转；然后Spring帮我们将需要的对象设置到我们的类中，这叫做依赖注入。</p>
<h4 id="常见的几种注入方法："><a href="#常见的几种注入方法：" class="headerlink" title="常见的几种注入方法："></a>常见的几种注入方法：</h4><p>使用有参构造方法注入<br>使用属性注入<br>使用接口注入<br>通过容器完成依赖关系的注入<br>Spring就是这样的容器，一个第三方容器能帮助我们完成类的实例化，以及依赖关系的装配，那么我们只需要专注于业务逻辑的开发即可。它通过配置文件或注解描述类和类之间的依赖关系，自动完成类的初始化和依赖注入的工作。</p>
<h3 id="资源访问Resource接口"><a href="#资源访问Resource接口" class="headerlink" title="资源访问Resource接口"></a>资源访问Resource接口</h3><p>Spring设计了一个Resource接口，为应用提供了更强的访问底层资源的能力，该接口拥有对应不同资源类型的实现类。</p>
<h4 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h4><p>boolean exists()：资源是否存在<br>boolean isOpen()：资源是否打开<br>URL getURL()：返回对应资源的URL<br>File getFile()：返回对应的文件对象<br>InputStream getInputStream()：返回对应资源的输入流</p>
<h4 id="具体实现类"><a href="#具体实现类" class="headerlink" title="具体实现类"></a>具体实现类</h4><p>ByteArrayResource：二进制数组表示的资源<br>ClassPathResource：类路径下的资源 ，资源以相对于类路径的方式表示<br>FileSystemResource：文件系统资源，资源以文件系统路径方式表示，如d:&#x2F;a&#x2F;b.txt<br>InputStreamResource：对应一个InputStream的资源<br>ServletContextResource：为访问容器上下文中的资源而设计的类。负责以相对于web应用根目录的路径加载资源<br>UrlResource：封装了java.net.URL。用户能够访问任何可以通过URL表示的资源，如Http资源，Ftp资源等</p>
<h4 id="资源加载机制"><a href="#资源加载机制" class="headerlink" title="资源加载机制"></a>资源加载机制</h4><p>为了访问不同类型的资源，必须使用相应的Resource实现类，这是比较麻烦的。Spring提供了一个强大的加载资源的机制，仅通过资源地址的特殊标识就可以加载相应的资源。<br>首先，我们了解一下Spring支持哪些资源类型的地址前缀:<br>classpath：例如classpath:com&#x2F;cad&#x2F;domain&#x2F;bean.xml。从类路径中加载资源<br>file：例如 file:com&#x2F;cad&#x2F;domain&#x2F;bean.xml.使用UrlResource从文件系统目录中加载资源。<br>http：&#x2F;&#x2F; 例如<a href="http://www.baidu.com/resource/bean.xml">http://www.baidu.com/resource/bean.xml</a> 使用UrlResource从web服务器加载资源<br>ftp：&#x2F;&#x2F; 例如frp:&#x2F;&#x2F;10.22.10.11&#x2F;bean.xml 使用UrlResource从ftp服务器加载资源<br>Spring定义了一套资源加载的接口。ResourceLoader接口仅有一个getResource(String location)的方法，可以根据资源地址加载文件资源。资源地址仅支持带资源类型前缀的地址，不支持Ant风格的资源路径表达式。ResourcePatternResolver扩展ResourceLoader接口，定义新的接口方法getResources(String locationPattern)，该方法支持带资源类型前缀以及Ant风格的资源路径的表达式。PathMatchingResourcePatternResolver是Spring提供的标准实现类。</p>
<h3 id="详解Ioc容器"><a href="#详解Ioc容器" class="headerlink" title="详解Ioc容器"></a>详解Ioc容器</h3><h4 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h4><p>BeanFactory是一个类工厂，和传统的类工厂不同，传统的类工厂仅负责构造一个类或几个类的实例；而BeanFactory可以创建并管理各种类的对象，Spring称这些被创建和管理的Java对象为Bean。<br>BeanFactory是一个接口，Spring为BeanFactory提供了多种实现，最常用的就是XmlBeanFactory。其中，BeanFactory接口最主要的方法就是getBean(String beanName)，该方法从容器中返回指定名称的Bean。此外，BeanFactory接口的功能可以通过实现它的接口进行扩展(比如ApplicationContext)。</p>
<h4 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h4><p>ApplicationContext由BeanFactory派生而来，提供了更多面向实际应用的功能。在BeanFactory中，很多功能需要编程方式来实现，而ApplicationContext中可以通过配置的方式来实现。ApplicationContext的主要实现类是ClassPathXmlApplicationContext和FileSystemXmlApplicationContext，前者默认从类路径加载配置文件，后者默认从文件系统中加载配置文件<br>ApplicationContext的初始化和BeanFactory初始化有一个重大的区别：<br>BeanFactory初始化容器时并未初始化Bean，只有第一次访问Bean时才创建；而ApplicationContext则在初始化时就实例化所有的单实例的Bean。因此，ApplicationContext的初始化时间会稍长一点。</p>
<h4 id="WebApplicationContext"><a href="#WebApplicationContext" class="headerlink" title="WebApplicationContext"></a>WebApplicationContext</h4><p>WebApplicationContext是专门为Web应用准备的，它允许以相对于Web根目录的路径中加载配置文件完成初始化工作。从WebApplicationContext中可以获取ServletContext的引用，整个WebApplicationContext对象作为属性放置到ServletContext中，以便Web应用环境中可以访问Spring应用上下文。ConfigurableWebApplicationContext扩展了WebApplicationContext,允许通过配置方式实例化WebApplicationContext，定义了两个重要方法。<br>setServletContext(ServletContext servletcontext)：为Spring设置ServletContext<br>setConfigLocation(String[] configLocations)：设置Spring配置文件地址。<br>WebApplicationContext初始化的时机和方式是：利用Spring提供的ContextLoaderListener监听器去监听ServletContext对象的创建，当ServletContext对象创建时，创建并初始化WebApplicationContext对象。因此，我们只需要在web.xml配置监听器即可。</p>
<h4 id="BeanFactory、ApplicationContext和WebApplicationContext的联系与区别"><a href="#BeanFactory、ApplicationContext和WebApplicationContext的联系与区别" class="headerlink" title="BeanFactory、ApplicationContext和WebApplicationContext的联系与区别"></a>BeanFactory、ApplicationContext和WebApplicationContext的联系与区别</h4><p>Spring通过一个配置文件描述Bean与Bean之间的依赖关系，通过Java语言的反射技术能实例化Bean并建立Bean之间的依赖关系。Spring的IoC容器在完成这些底层工作的基础上，还提供了bean实例缓存、生命周期管理、事件发布，资源装载等高级服务。<br>BeanFactory是Spring最核心的接口，提供了高级IoC的配置机制。ApplicationContext建立在BeanFactory的基础上，是BeanFactory的子接口，提供了更多面向应用的功能。我们一般称BeanFactory为IoC容器，ApplicationContext为应用上下文，也称为Spring容器。WebApplicationContext是专门为Web应用准备的，它允许以相对于Web根目录的路径中加载配置文件完成初始化工作，是ApplicationContext接口的子接口。<br>BeanFactory是Spring框架的基础，面向Spring本身；ApplicationContext面向使用Spring框架的开发者，几乎所有的应用我们都直接使用ApplicationContext而非底层的BeanFactory；WebApplicationContext是专门用于Web应用。</p>
<h4 id="父子容器"><a href="#父子容器" class="headerlink" title="父子容器"></a>父子容器</h4><p>通过HierarchicalBeanFactory接口，Spring的IoC容器可以建立父子层级关联的体系：子容器可以访问父容器的Bean，父容器不能访问子容器的Bean。<br>Spring使用父子容器实现了很多功能，比如在Spring MVC中，控制器Bean位于子容器中，业务层和持久层Bean位于父容器中。但即使这样，控制器Bean也可以引用持久层和业务层的Bean，而业务层和持久层就看不到控制器Bean。</p>
<h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><p>面向切面的编程 (AOP) </p>
<h4 id="AOP-术语："><a href="#AOP-术语：" class="headerlink" title="AOP 术语："></a>AOP 术语：</h4><p>Aspect<br>这是一个模块，它具有一组提供横切要求的 API。 例如，日志记录模块将被称为 AOP 切面的日志记录。 根据要求，应用程序可以具有任意数量的切面。<br>Join point<br>这代表了您的应用程序中的一个点，您可以在其中插入 AOP 切面。 您也可以说，它是应用程序中使用 Spring AOP 框架执行操作的实际位置。	<br>Advice<br>这是在方法执行之前或之后要采取的实际操作。 这是一段由 Spring AOP 框架在程序执行期间调用的实际代码。	<br>Pointcut<br>这是应该执行通知的一组一个或多个连接点。 正如我们将在 AOP 示例中看到的那样，您可以使用表达式或模式指定切入点<br>Introduction<br>Introduction 允许您向现有类添加新方法或属性。<br>Target object<br>一个或多个切面所通知的对象。 此对象将始终是代理对象，也称为通知对象。<br>Weaving<br>Weaving 是将切面与其他应用程序类型或对象链接以创建通知对象的过程。 这可以在编译时、加载时或运行时完成。</p>
<h4 id="通知类型："><a href="#通知类型：" class="headerlink" title="通知类型："></a>通知类型：</h4><p>before<br>在方法执行之前运行通知。<br>after<br>在方法执行后运行通知，无论其结果如何。<br>after-returning<br>仅当方法成功完成时，才在方法执行后运行通知。	<br>after-throwing<br>仅当方法因抛出异常而退出时，才在方法执行后运行通知。<br>around<br>在调用建议方法之前和之后运行通知。</p>
<h4 id="自定义切面实现"><a href="#自定义切面实现" class="headerlink" title="自定义切面实现"></a>自定义切面实现</h4><p>Spring 支持 @AspectJ annotation style 方法和 schema-based 方法来实现自定义切面<br>基于 XML 模式<br>切面是使用常规类和基于 XML 的配置来实现的。<br>基于@AspectJ<br>@AspectJ 指的是一种将切面声明为使用 Java 5 注解进行注解的常规 Java 类的风格。</p>
<h3 id="Bean"><a href="#Bean" class="headerlink" title="Bean"></a>Bean</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>构成应用程序主干并由 Spring IoC 容器管理的对象称为 beans。bean 是由 Spring IoC 容器实例化、组装和管理的对象。 这些 bean 使用您提供给容器的配置元数据创建。 例如，以 XML &lt;bean&#x2F;&gt; 的形式</p>
<h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>在定义 &lt;bean&gt; 时，您可以选择为该 bean 声明一个作用域。 例如，要强制 Spring 在每次需要时生成一个新的 bean 实例，您应该将 bean 的 scope 属性声明为 prototype。 同样，如果您希望 Spring 在每次需要时返回相同的 bean 实例，您应该将 bean 的 scope 属性声明为 singleton。<br>五个作用域：<br>singleton<br>这将 bean 定义范围限定为每个 Spring IoC 容器的单个实例（默认）。<br>prototype<br>这将单个 bean 定义的范围限定为具有任意数量的对象实例。<br>request<br>这将 bean 定义的范围限定为 HTTP 请求。 仅在 Web 感知 Spring ApplicationContext 的上下文中有效。<br>session<br>这将 bean 定义范围限定为 HTTP 会话。 仅在 Web 感知 Spring ApplicationContext 的上下文中有效。<br>global-session<br>这将 bean 定义范围限定为全局 HTTP 会话。 仅在 Web 感知 Spring ApplicationContext 的上下文中有效。</p>
<h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>实例化 bean 时，可能需要执行一些初始化以使其进入可用状态。 同样，当不再需要 bean 并将其从容器中取出时，可能需要进行一些清理。<br>要为 bean 定义设置和销毁，我们只需使用 initmethod 和&#x2F;或 destroy-method 参数声明 &lt;bean&gt;。 init-method 属性指定了在实例化时立即在 bean 上调用的方法。 类似地，destroymethod 指定了一个在从容器中删除 bean 之前调用的方法。</p>
<h4 id="回调方法"><a href="#回调方法" class="headerlink" title="回调方法"></a>回调方法</h4><p>BeanPostProcessor 接口定义了回调方法，你可以实现这些方法来提供你自己的实例化逻辑、依赖解析逻辑等。你也可以在Spring容器完成实例化、配置和初始化一个 bean 通过插入一个或多个 BeanPostProcessor 实现。<br>您可以配置多个 BeanPostProcessor 接口，并且您可以通过设置 order 属性来控制这些 BeanPostProcessor 接口的执行顺序，前提是 BeanPostProcessor 实现了 Ordered 接口。<br>BeanPostProcessor 对 bean（或对象）实例进行操作，这意味着 Spring IoC 容器实例化一个 bean 实例，然后 BeanPostProcessor 接口完成它们的工作。<br>ApplicationContext 会自动检测任何通过 BeanPostProcessor 接口的实现定义的 bean，并将这些 bean 注册为 postprocessors，然后在 bean 创建时由容器适当地调用。</p>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>一个 bean 定义可以包含很多配置信息，包括构造函数参数、属性值以及容器特定的信息，例如初始化方法、static factory 方法名称等。<br>子 bean 定义继承父定义的配置数据。 子定义可以根据需要覆盖某些值或添加其他值。<br>Spring Bean 定义继承与 Java 类继承无关，但继承概念是相同的。 您可以将父 bean 定义定义为模板，其他子 bean 可以从父 bean 继承所需的配置。<br>当您使用基于 XML 的配置元数据时，您可以通过使用 parent 属性来指示子 bean 定义，并将父 bean 指定为该属性的值。</p>
<h4 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h4><p>Spring 容器可以在协作 bean 之间自动装配关系，而无需使用 &lt;constructor-arg&gt; 和 &lt;property&gt; 元素，这有助于减少您为基于 Spring 的大型应用程序编写的 XML 配置量。</p>
<h3 id="基于注解的配置"><a href="#基于注解的配置" class="headerlink" title="基于注解的配置"></a>基于注解的配置</h3><p>从 Spring 2.5 开始，可以使用 annotations 配置依赖注入。 因此，您可以通过在相关类、方法或字段声明上使用注解，将 bean 配置移动到组件类本身，而不是使用 XML 来描述 bean 连接。<br>注解注入在 XML 注入之前执行。 因此，对于通过这两种方法连接的属性，后一种配置将覆盖前者。<br>默认情况下，Spring 容器中未开启注解连接。 因此，在我们可以使用基于注解的连接之前，我们需要在 Spring 配置文件中启用它。 因此，如果您想在 Spring 应用程序中使用任何注解，请考虑以下配置文件。<br>重要注解：<br>@Required<br>@Required 注解适用于 bean 属性设置器方法。<br>@Autowired<br>@Autowired 注解可以应用于 bean 属性设置方法、非设置方法、构造函数和属性。<br>@Qualifier<br>@Qualifier 注解和@Autowired 可用于通过指定将被连接的确切bean 来消除混淆。<br>JSR-250 注解<br>Spring 支持基于 JSR-250 的注解，其中包括 @Resource、@PostConstruct 和 @PreDestroy 注解。</p>
<h3 id="基于-Java-的配置"><a href="#基于-Java-的配置" class="headerlink" title="基于 Java 的配置"></a>基于 Java 的配置</h3><p>@Configuration &amp; @Bean 注解<br>使用 @Configuration 注解一个类表明该类可以被 Spring IoC 容器用作 bean 定义的来源。 @Bean 注解告诉 Spring，使用 @Bean 注解的方法将返回一个对象，该对象应在 Spring 应用程序上下文中注册为 bean。<br>@Bean 注解<br>当@Beans相互依赖时，表示依赖就像让一个bean方法调用另一个bean方法一样简单<br>@Import 注解<br>@Import 注解允许从另一个配置类加载@Bean 定义。<br>生命周期回调<br>@Bean 注解支持指定任意初始化和销毁回调方法，很像 Spring XML 的 bean 元素上的 init-method 和 destroy-method 属性<br>指定 Bean 作用域<br>默认作用域是 singleton (单例)，但您可以使用 @Scope 注解覆盖它</p>
<h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><p>ApplicationContext，它管理 bean 的完整生命周期。 ApplicationContext 在加载 bean 时发布某些类型的事件。 例如，ContextStartedEvent 在上下文启动时发布，ContextStoppedEvent 在上下文停止时发布。<br>ApplicationContext 中的事件处理是通过ApplicationEvent 类和ApplicationListener 接口提供的。 因此，如果 bean 实现了 ApplicationListener，那么每次 ApplicationEvent 发布到 ApplicationContext 时，都会通知该 bean。</p>
<hr>
<p>😎END</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>emoji</title>
    <url>/posts/b64bf632.html</url>
    <content><![CDATA[<p>😀😃😄😁🤣😂🥰😇<br>🤩🤪😎<br>👾💩🤡👻👽<br>💔💖<br>💬<br>❓❗❌✔</p>
]]></content>
      <categories>
        <category>资源</category>
        <category>杂项</category>
      </categories>
  </entry>
</search>
